{"version":3,"sources":["tool/Proxification.js"],"names":["TC","tool","Proxification","proxy","options","this","Consts","url","SPLIT_REGEX","undefined","TypeError","result","substr","window","location","protocol","encodeURIComponent","_location","preventMixedContent","allowedMixedContent","fetch","self","support","searchParams","iterable","Symbol","blob","Blob","e","formData","arrayBuffer","viewClasses","isDataView","obj","DataView","prototype","isPrototypeOf","isArrayBufferView","ArrayBuffer","isView","indexOf","Object","toString","call","Headers","append","name","value","normalizeName","normalizeValue","oldValue","map","get","has","hasOwnProperty","set","forEach","callback","thisArg","keys","items","push","iteratorFor","values","entries","iterator","methods","Request","clone","body","_bodyInit","Body","Response","status","statusText","headers","error","response","type","redirectStatuses","redirect","RangeError","input","init","Promise","resolve","reject","request","xhr","XMLHttpRequest","onload","parseHeaders","getAllResponseHeaders","responseURL","responseText","onerror","ontimeout","open","method","sync","credentials","withCredentials","responseType","setRequestHeader","send","polyfill","String","test","toLowerCase","next","shift","done","Array","isArray","header","getOwnPropertyNames","consumed","bodyUsed","fileReaderReady","reader","readBlobAsArrayBuffer","FileReader","promise","readAsArrayBuffer","bufferClone","buf","slice","view","Uint8Array","byteLength","buffer","_initBody","_bodyText","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","Error","rejected","then","text","readAsText","readBlobAsText","chars","length","i","fromCharCode","join","readArrayBufferAsText","decode","json","JSON","parse","upcased","mode","toUpperCase","referrer","form","trim","split","bytes","replace","decodeURIComponent","rawHeaders","line","parts","key","bodyInit","ok","srcToURL","src","anchor","document","createElement","href","origin","hostname","urlParts","exec","port","toolProto","cacheHost","toHost","_hosts","_hostsImage","is","host","getList","filtered","filter","h","exportable","forImage","addKey","newItem","action","removeKey","splice","getAction","cache","_actionPromise","_isServiceWorker","navigator","serviceWorker","controller","state","ready","registration","active","catch","console","log","_isSameOrigin","uri","match","uProtocol","uPort","lPort","_isSameProtocol","protocolRegex","uriProtocol","locationProtocol","_isSecureURL","ResponseError","changeProtocol","newProtocol","toHTTPS","toHTTP","_currentHTTP","_image","getImgTag","img","_actionHTTPS","ErrorType","PROTOCOL","_byProxy","sameOrigin","_actionProxy","getImgTagByAction","bind","_actionDirect","_actionHTTP","CORS","NOTFOUNDED","UNEXPECTED","checkHttpStatus","dataset","checkCORSHeaders","crossOrigin","canvas","ctx","getContext","height","width","drawImage","createCanvas","toDataURL","code","ignoreProxification","ex","_fetch","CONTENTTYPE","UNEXPECTEDCONTENTTYPE","validateResponse","validateContentType","expectedContentType","contentType","fetchImage","resolveActionPromise","rejectActionPromise","_caching","_reject","makeRequest","fetchRetry","n","fetchSync","fetchXML","fetchJSON","mimeType","fetchBlob","fetchImageAsBlob","data","_makeRequest","actions","retryAttempts","responseWithCharsetToDecodedString","charset","addEventListener","abort","DOMException","XML","hasCharset","DOMParser","parseFromString","DeveloperError","fnResolve","fnReject"],"mappings":"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","sourcesContent":["var TC = TC || {};\r\n\r\nTC.tool = TC.tool || {};\r\n\r\nTC.tool.Proxification = function (proxy, options) {\r\n    var self = this;\r\n\r\n    self.Consts = {\r\n        url: {\r\n            SPLIT_REGEX: /([^:]*:)?\\/\\/([^:]*:?[^@]*@)?([^:\\/\\?]*):?([^\\/\\?]*)/\r\n        }\r\n    };\r\n\r\n    if (proxy === undefined) {\r\n        throw new TypeError('\"proxy\" parameter is undefined', \"TC.tool.Proxification.js\");\r\n    }\r\n\r\n    if (typeof proxy == \"function\") {\r\n        self.proxy = proxy;\r\n    } else {\r\n        self.proxy = function (url) {\r\n            var result = proxy;\r\n            if (url.substr(0, 4) != \"http\") {\r\n                result += window.location.protocol;\r\n            }\r\n            result += encodeURIComponent(url);\r\n            return result;\r\n        };\r\n    }\r\n\r\n    options = options || {};\r\n\r\n    self._location = options.location || window.location;\r\n\r\n    self.preventMixedContent = options.allowedMixedContent !== undefined ? !options.allowedMixedContent : true;\r\n};\r\n\r\n(function () {\r\n    if (!window.fetch) {\r\n        (function (self) {\r\n            // polyfill https://github.com/github/fetch/\r\n            'use strict'; if (self.fetch) { return }\r\n            var support = {\r\n                searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () {\r\n                    try {\r\n                        new Blob()\r\n                        return !0\r\n                    } catch (e) { return !1 }\r\n                })(), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self\r\n            }\r\n            if (support.arrayBuffer) {\r\n                var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']\r\n                var isDataView = function (obj) { return obj && DataView.prototype.isPrototypeOf(obj) }\r\n                var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1 }\r\n            }\r\n            function normalizeName(name) {\r\n                if (typeof name !== 'string') { name = String(name) }\r\n                if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) { throw new TypeError('Invalid character in header field name') }\r\n                return name.toLowerCase()\r\n            }\r\n            function normalizeValue(value) {\r\n                if (typeof value !== 'string') { value = String(value) }\r\n                return value\r\n            }\r\n            function iteratorFor(items) {\r\n                var iterator = {\r\n                    next: function () {\r\n                        var value = items.shift()\r\n                        return { done: value === undefined, value: value }\r\n                    }\r\n                }\r\n                if (support.iterable) { iterator[Symbol.iterator] = function () { return iterator } }\r\n                return iterator\r\n            }\r\n            function Headers(headers) {\r\n                this.map = {}\r\n                if (headers instanceof Headers) { headers.forEach(function (value, name) { this.append(name, value) }, this) } else if (Array.isArray(headers)) { headers.forEach(function (header) { this.append(header[0], header[1]) }, this) } else if (headers) { Object.getOwnPropertyNames(headers).forEach(function (name) { this.append(name, headers[name]) }, this) }\r\n            }\r\n            Headers.prototype.append = function (name, value) {\r\n                name = normalizeName(name)\r\n                value = normalizeValue(value)\r\n                var oldValue = this.map[name]\r\n                this.map[name] = oldValue ? oldValue + ',' + value : value\r\n            }\r\n            Headers.prototype['delete'] = function (name) { delete this.map[normalizeName(name)] }\r\n            Headers.prototype.get = function (name) {\r\n                name = normalizeName(name)\r\n                return this.has(name) ? this.map[name] : null\r\n            }\r\n            Headers.prototype.has = function (name) { return this.map.hasOwnProperty(normalizeName(name)) }\r\n            Headers.prototype.set = function (name, value) { this.map[normalizeName(name)] = normalizeValue(value) }\r\n            Headers.prototype.forEach = function (callback, thisArg) { for (var name in this.map) { if (this.map.hasOwnProperty(name)) { callback.call(thisArg, this.map[name], name, this) } } }\r\n            Headers.prototype.keys = function () {\r\n                var items = []\r\n                this.forEach(function (value, name) { items.push(name) })\r\n                return iteratorFor(items)\r\n            }\r\n            Headers.prototype.values = function () {\r\n                var items = []\r\n                this.forEach(function (value) { items.push(value) })\r\n                return iteratorFor(items)\r\n            }\r\n            Headers.prototype.entries = function () {\r\n                var items = []\r\n                this.forEach(function (value, name) { items.push([name, value]) })\r\n                return iteratorFor(items)\r\n            }\r\n            if (support.iterable) { Headers.prototype[Symbol.iterator] = Headers.prototype.entries }\r\n            function consumed(body) {\r\n                if (body.bodyUsed) { return Promise.reject(new TypeError('Already read')) }\r\n                body.bodyUsed = !0\r\n            }\r\n            function fileReaderReady(reader) {\r\n                return new Promise(function (resolve, reject) {\r\n                    reader.onload = function () { resolve(reader.result) }\r\n                    reader.onerror = function () { reject(reader.error) }\r\n                })\r\n            }\r\n            function readBlobAsArrayBuffer(blob) {\r\n                var reader = new FileReader()\r\n                var promise = fileReaderReady(reader)\r\n                reader.readAsArrayBuffer(blob)\r\n                return promise\r\n            }\r\n            function readBlobAsText(blob) {\r\n                var reader = new FileReader()\r\n                var promise = fileReaderReady(reader)\r\n                reader.readAsText(blob)\r\n                return promise\r\n            }\r\n            function readArrayBufferAsText(buf) {\r\n                var view = new Uint8Array(buf)\r\n                var chars = new Array(view.length)\r\n                for (var i = 0; i < view.length; i++) { chars[i] = String.fromCharCode(view[i]) }\r\n                return chars.join('')\r\n            }\r\n            function bufferClone(buf) {\r\n                if (buf.slice) { return buf.slice(0) } else {\r\n                    var view = new Uint8Array(buf.byteLength)\r\n                    view.set(new Uint8Array(buf))\r\n                    return view.buffer\r\n                }\r\n            }\r\n            function Body() {\r\n                this.bodyUsed = !1\r\n                this._initBody = function (body) {\r\n                    this._bodyInit = body\r\n                    if (!body) { this._bodyText = '' } else if (typeof body === 'string') { this._bodyText = body } else if (support.blob && Blob.prototype.isPrototypeOf(body)) { this._bodyBlob = body } else if (support.formData && FormData.prototype.isPrototypeOf(body)) { this._bodyFormData = body } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) { this._bodyText = body.toString() } else if (support.arrayBuffer && support.blob && isDataView(body)) {\r\n                        this._bodyArrayBuffer = bufferClone(body.buffer)\r\n                        this._bodyInit = new Blob([this._bodyArrayBuffer])\r\n                    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) { this._bodyArrayBuffer = bufferClone(body) } else { throw new Error('unsupported BodyInit type') }\r\n                    if (!this.headers.get('content-type')) { if (typeof body === 'string') { this.headers.set('content-type', 'text/plain;charset=UTF-8') } else if (this._bodyBlob && this._bodyBlob.type) { this.headers.set('content-type', this._bodyBlob.type) } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) { this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8') } }\r\n                }\r\n                if (support.blob) {\r\n                    this.blob = function () {\r\n                        var rejected = consumed(this)\r\n                        if (rejected) { return rejected }\r\n                        if (this._bodyBlob) { return Promise.resolve(this._bodyBlob) } else if (this._bodyArrayBuffer) { return Promise.resolve(new Blob([this._bodyArrayBuffer])) } else if (this._bodyFormData) { throw new Error('could not read FormData body as blob') } else { return Promise.resolve(new Blob([this._bodyText])) }\r\n                    }\r\n                    this.arrayBuffer = function () { if (this._bodyArrayBuffer) { return consumed(this) || Promise.resolve(this._bodyArrayBuffer) } else { return this.blob().then(readBlobAsArrayBuffer) } }\r\n                }\r\n                this.text = function () {\r\n                    var rejected = consumed(this)\r\n                    if (rejected) { return rejected }\r\n                    if (this._bodyBlob) { return readBlobAsText(this._bodyBlob) } else if (this._bodyArrayBuffer) { return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer)) } else if (this._bodyFormData) { throw new Error('could not read FormData body as text') } else { return Promise.resolve(this._bodyText) }\r\n                }\r\n                if (support.formData) { this.formData = function () { return this.text().then(decode) } }\r\n                this.json = function () { return this.text().then(JSON.parse) }\r\n                return this\r\n            }\r\n            var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\r\n            function normalizeMethod(method) {\r\n                var upcased = method.toUpperCase()\r\n                return (methods.indexOf(upcased) > -1) ? upcased : method\r\n            }\r\n            function Request(input, options) {\r\n                options = options || {}\r\n                var body = options.body\r\n                if (input instanceof Request) {\r\n                    if (input.bodyUsed) { throw new TypeError('Already read') }\r\n                    this.url = input.url\r\n                    this.credentials = input.credentials\r\n                    if (!options.headers) { this.headers = new Headers(input.headers) }\r\n                    this.method = input.method\r\n                    this.mode = input.mode\r\n                    if (!body && input._bodyInit != null) {\r\n                        body = input._bodyInit\r\n                        input.bodyUsed = !0\r\n                    }\r\n                } else { this.url = String(input) }\r\n                this.credentials = options.credentials || this.credentials || 'omit'\r\n                if (options.headers || !this.headers) { this.headers = new Headers(options.headers) }\r\n                this.method = normalizeMethod(options.method || this.method || 'GET')\r\n                this.mode = options.mode || this.mode || null\r\n                this.referrer = null\r\n                if ((this.method === 'GET' || this.method === 'HEAD') && body) { throw new TypeError('Body not allowed for GET or HEAD requests') }\r\n                this._initBody(body)\r\n            }\r\n            Request.prototype.clone = function () { return new Request(this, { body: this._bodyInit }) }\r\n            function decode(body) {\r\n                var form = new FormData()\r\n                body.trim().split('&').forEach(function (bytes) {\r\n                    if (bytes) {\r\n                        var split = bytes.split('=')\r\n                        var name = split.shift().replace(/\\+/g, ' ')\r\n                        var value = split.join('=').replace(/\\+/g, ' ')\r\n                        form.append(decodeURIComponent(name), decodeURIComponent(value))\r\n                    }\r\n                })\r\n                return form\r\n            }\r\n            function parseHeaders(rawHeaders) {\r\n                var headers = new Headers()\r\n                var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\r\n                preProcessedHeaders.split(/\\r?\\n/).forEach(function (line) {\r\n                    var parts = line.split(':')\r\n                    var key = parts.shift().trim()\r\n                    if (key) {\r\n                        var value = parts.join(':').trim()\r\n                        headers.append(key, value)\r\n                    }\r\n                })\r\n                return headers\r\n            }\r\n            Body.call(Request.prototype)\r\n            function Response(bodyInit, options) {\r\n                if (!options) { options = {} }\r\n                this.type = 'default'\r\n                this.status = options.status === undefined ? 200 : options.status\r\n                this.ok = this.status >= 200 && this.status < 300\r\n                this.statusText = 'statusText' in options ? options.statusText : 'OK'\r\n                this.headers = new Headers(options.headers)\r\n                this.url = options.url || ''\r\n                this._initBody(bodyInit)\r\n            }\r\n            Body.call(Response.prototype)\r\n            Response.prototype.clone = function () { return new Response(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new Headers(this.headers), url: this.url }) }\r\n            Response.error = function () {\r\n                var response = new Response(null, { status: 0, statusText: '' })\r\n                response.type = 'error'\r\n                return response\r\n            }\r\n            var redirectStatuses = [301, 302, 303, 307, 308]\r\n            Response.redirect = function (url, status) {\r\n                if (redirectStatuses.indexOf(status) === -1) { throw new RangeError('Invalid status code') }\r\n                return new Response(null, { status: status, headers: { location: url } })\r\n            }\r\n            self.Headers = Headers\r\n            self.Request = Request\r\n            self.Response = Response\r\n            self.fetch = function (input, init) {\r\n                return new Promise(function (resolve, reject) {\r\n                    var request = new Request(input, init);\r\n                    init = init || {};\r\n                    var xhr = new XMLHttpRequest();\r\n                    xhr.onload = function () {\r\n                        if (xhr.status === 0) {\r\n                            return new Response(null, { status: xhr.status });\r\n                        } else {\r\n                            var options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') }\r\n                            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\r\n                            var body = 'response' in xhr ? xhr.response : xhr.responseText\r\n                            resolve(new Response(body, options))\r\n                        }\r\n                    }\r\n                    xhr.onerror = function () { reject(new TypeError('Network request failed')) }\r\n                    xhr.ontimeout = function () { reject(new TypeError('Network request failed')) }\r\n                    xhr.open(request.method, request.url, !init.sync)\r\n                    if (request.credentials === 'include') { xhr.withCredentials = !0 } else if (request.credentials === 'omit') { xhr.withCredentials = !1 }\r\n                    if (!init.sync && ('responseType' in xhr && support.blob)) { xhr.responseType = 'blob' }\r\n                    request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) })\r\n                    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\r\n                })\r\n            }\r\n            self.fetch.polyfill = !0\r\n        })(typeof self !== 'undefined' ? self : this);\r\n    }\r\n\r\n    var srcToURL = function (src) {\r\n        // GLS: 30/01/2019 Se carga un polyfill que no implementa correctamente el origin\r\n        //if (window.URL && !(src.indexOf('//') == 0)) {\r\n        //    try {\r\n        //        var url = new URL(src);\r\n        //        if (url.origin && url.origin.length > 0) {\r\n        //            return url;\r\n        //        }\r\n        //    }\r\n        //    catch (error) {\r\n        //        // no hacemos nada y seguimos adelante\r\n        //    }\r\n        //}\r\n\r\n        var anchor = document.createElement('a');\r\n        anchor.href = src;\r\n\r\n        if (!anchor.origin) {\r\n\r\n            if (!(anchor.protocol && anchor.hostname)) {\r\n                var urlParts = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(anchor.href);\r\n\r\n                anchor.protocol = urlParts[1];\r\n\r\n                if (urlParts[4].indexOf(':') > -1) {\r\n                    var hostname = urlParts[4].split(':');\r\n                    anchor.hostname = hostname[0];\r\n                    anchor.port = hostname[1];\r\n                } else {\r\n                    anchor.hostname = urlParts[4];\r\n                }\r\n            }\r\n\r\n            anchor.origin = (anchor.protocol.length === 0 ? window.location.protocol : anchor.protocol) + \"//\" + anchor.hostname + (anchor.port && (src.indexOf(anchor.port) > -1) ? ':' + anchor.port : '');\r\n        }\r\n\r\n        return anchor;\r\n    };\r\n\r\n    function HostCacheService(objectStoreName) {\r\n        this.database = null;\r\n        this.objectStoreName = objectStoreName;\r\n    }\r\n\r\n    HostCacheService.prototype = {\r\n        /* createDB : create the scheme of the database  */\r\n        createDB: function () {\r\n\r\n            // In the following line, you should include the prefixes of implementations you want to test.\r\n            window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n            // DON'T use \"var indexedDB = ...\" if you're not in a function.\r\n            // Moreover, you may need references to some window.IDB* objects:\r\n            window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\r\n            window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\r\n            if (!window.indexedDB) {\r\n                window.alert(\"Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.\");\r\n            }\r\n\r\n            var request = window.indexedDB.open('HostCacheService', 1);\r\n            var that = this;\r\n            request.onsuccess = function (evt) {\r\n                that.database = evt.target.result;\r\n            };\r\n            request.onerror = function (evt) {\r\n                console.log(\"IndexedDB--> onerror \");\r\n            };\r\n            request.onupgradeneeded = function (evt) {\r\n                var thisDB = evt.target.result;\r\n                if (!thisDB.objectStoreNames.contains('HostAction')) {\r\n                    var store = thisDB.createObjectStore('HostAction', { keyPath: 'id' });\r\n                    store.createIndex(\"host\", [\"action\"], { unique: true });\r\n                }\r\n            };\r\n        },\r\n        /* info on available storage */\r\n        info: function () {\r\n            // Request storage usage and capacity left\r\n            window.webkitStorageInfo.queryUsageAndQuota(window.TEMPORARY, //the type can be either TEMPORARY or PERSISTENT\r\n                function (used, remaining) {\r\n                    console.log(\"Used quota: \" + used + \", remaining quota: \" + remaining);\r\n                }, function (e) {\r\n                    console.log('Error', e);\r\n                });\r\n        },\r\n        /* isReady when objectStore has been created  */\r\n        isReady: function () {\r\n            if (!this.database)\r\n                return false;\r\n\r\n            return this.database.objectStoreNames.contains(this.objectStoreName);\r\n        },\r\n        getHost: function (host) {\r\n            return new Promise(function (resolve, reject) {\r\n                if (!this.database) {\r\n                    console.log(\"getAction no database\", this.database);\r\n                    reject(\"no IndexedDB\");\r\n                }\r\n                else {\r\n                    var transaction = this.database.transaction(this.objectStoreName);\r\n                    var hostIndex = transaction.objectStore(this.objectStoreName).index(\"host\");\r\n\r\n                    var requestGet = hostIndex.get([host]);\r\n                    requestGet.onsuccess = function (evt) {\r\n                        if (evt.target.result) {\r\n                            resolve({ data: evt.target.result });\r\n                        }\r\n                        else { reject(\"no action\"); }\r\n                    };\r\n\r\n                    requestGet.onerror = function (evt) {\r\n                        reject(\"no action get failed\");\r\n                    };\r\n                }\r\n            });\r\n        },\r\n        addHost: function (host, action) {\r\n\r\n            if (this.database) {\r\n                var transaction = this.database.transaction(this.objectStoreName, \"readwrite\");\r\n                try {\r\n                    // the transaction could abort because of a QuotaExceededError error\r\n                    var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8; return v.toString(16); });\r\n                    transaction.objectStore(this.objectStoreName).add({ id: guid, host: host, action: action });\r\n                }\r\n                catch (ex) {\r\n                    console.log(ex);\r\n                }\r\n\r\n            }\r\n            else {\r\n                console.log(\"addHost no database\");\r\n            }\r\n        },\r\n        removeHost: function (host) {\r\n            this.getHost(host).then(function (host) {\r\n                var transaction = this.database.transaction(this.objectStoreName, \"readwrite\");\r\n                transaction.objectStore(this.objectStoreName).delete(host.data.id);\r\n            });\r\n        }\r\n    };\r\n\r\n    const HostCacheItem = function () {\r\n        this.key = \"\";\r\n        this.action = null;\r\n        this.actionName = \"\";\r\n    };\r\n\r\n    const HostCache = function () {\r\n        var toHost = function (src) {\r\n            var url = srcToURL(src);\r\n            if (url) {\r\n                return url.origin;\r\n            }\r\n\r\n            return null;\r\n        };\r\n\r\n        //this.hostCacheService = new HostCacheService(\"HostAction\");\r\n        //this.hostCacheService.createDB();\r\n\r\n        this._hosts = [];\r\n        this._hostsImage = [];\r\n\r\n        this.is = function (src, options) {\r\n            var host = toHost(src);\r\n\r\n            return this.get(host, options) !== null;\r\n        };\r\n\r\n        this.get = function (host, options) {\r\n            if (this.getList(options).length === 0) {\r\n                return null;\r\n            } else {\r\n                var filtered = this.getList(options).filter(function (h) {\r\n                    return h.key === host && options.exportable == h.exportable;\r\n                });\r\n                if (filtered.length === 0) {\r\n                    return null;\r\n                } else {\r\n                    return filtered[0];\r\n                }\r\n            }\r\n        };\r\n\r\n        this.getList = function (options) {\r\n            return options.forImage ? this._hostsImage : this._hosts;\r\n        };\r\n\r\n        this.addKey = function (src, options) {\r\n            var host = toHost(src);\r\n            var newItem = { key: host, action: null };\r\n            if (options.exportable) {\r\n                newItem.exportable = options.exportable;\r\n            }\r\n            this.getList(options).push(newItem);\r\n            return this.getList(options)[this.getList(options).length - 1];\r\n        };\r\n\r\n        this.removeKey = function (src, options) {\r\n            var host = toHost(src);\r\n\r\n            for (var i = 0; i < this.getList(options).length; i++) {\r\n                if (this.getList(options)[i].key === host && options.exportable == this.getList(options)[i].exportable) {\r\n                    this.getList(options).splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        this.getAction = function (src, options) {\r\n            options = options || {};\r\n\r\n            var host = toHost(src);\r\n            var cache = this.get(host, options);\r\n            if (!cache) {\r\n                return Promise.reject(new Error('Cache null'));\r\n            }\r\n            return cache._actionPromise;\r\n        };\r\n    };\r\n\r\n    var toolProto = TC.tool.Proxification.prototype;\r\n\r\n    toolProto.cacheHost = new HostCache();\r\n\r\n    toolProto._isServiceWorker = function () {\r\n        if (navigator.serviceWorker) {\r\n            if (navigator.serviceWorker.controller && navigator.serviceWorker.controller.state === \"activated\") {\r\n                return true;\r\n            } else {\r\n                navigator.serviceWorker.ready\r\n                    .then(function (registration) {\r\n                        if (registration.active) {\r\n                            return true;\r\n                        } else {\r\n                            return false;\r\n                        }\r\n                    })\r\n                    .catch(() => {\r\n                        console.log('Capturamos error que se produce en FF por configuración del navegador.');\r\n                    });\r\n\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    };\r\n\r\n    toolProto._isSameOrigin = function (uri) {\r\n        var self = this;\r\n\r\n        var result = uri.indexOf(\"http\") !== 0 && uri.indexOf(\"//\") !== 0;\r\n        var urlParts = !result && uri.match(self.Consts.url.SPLIT_REGEX);\r\n        if (urlParts) {\r\n            var uProtocol = urlParts[1];\r\n            result = (uProtocol == self._location.protocol || uProtocol == undefined) && urlParts[3] == self._location.hostname;\r\n            var uPort = urlParts[4], lPort = self._location.port;\r\n            if (uPort != 80 && uPort !== \"\" || lPort != \"80\" && lPort !== \"\") {\r\n                result = result && uPort == lPort;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    toolProto._isSameProtocol = function (uri) {\r\n        var protocolRegex = /^(https?:\\/\\/)/i;\r\n        var uriProtocol = uri.match(protocolRegex);\r\n        if (uriProtocol && uriProtocol.length > 1) {\r\n            var locationProtocol = self._location.match(protocolRegex);\r\n            if (locationProtocol && locationProtocol.length > 1) {\r\n                return uriProtocol[0].trim() === locationProtocol[0].trim();\r\n            }\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    toolProto._isSecureURL = function (url) {\r\n        //sino empieza por http ni por https la consideramos segura\r\n        if (!/^(f|ht)tps?:\\/\\//i.test(url))\r\n            return true;\r\n        return (/^(f|ht)tps:\\/\\//i.test(url));\r\n    };\r\n\r\n    const ResponseError = function (status, text, url) {\r\n        this.status = status;\r\n        this.text = text;\r\n        this.url = url;\r\n    };\r\n\r\n    var changeProtocol = function (src, newProtocol) {\r\n        var url = srcToURL(src);\r\n        return src.replace(url.protocol, newProtocol);\r\n    };\r\n\r\n    var toHTTPS = function (src) {\r\n        return changeProtocol(src, \"https:\");\r\n    };\r\n\r\n    var toHTTP = function (src) {\r\n        return changeProtocol(src, \"http:\");\r\n    };\r\n\r\n    var _currentHTTP = function (src, options, resolve, reject) {\r\n        var self = this;\r\n        src = toHTTPS(src);\r\n\r\n        self._image.getImgTag(src, options).then(function (img) {\r\n            resolve(img, self._actionHTTPS);\r\n        }, function (error) {\r\n            if (error === self._image.ErrorType.PROTOCOL) {\r\n                reject(error);\r\n            } else {\r\n                _byProxy.call(self, toHTTP(src), options, resolve, reject);\r\n            }\r\n        });\r\n    };\r\n\r\n    var _currentHTTPS = function (src, options, resolve, reject) {\r\n        var self = this;\r\n        src = toHTTP(src);\r\n\r\n        self._image.getImgTag(src, options).then(function (img) {\r\n            resolve(img, self._actionHTTP);\r\n        }, function (error) {\r\n            if (error === self._image.ErrorType.PROTOCOL) {\r\n                reject(error);\r\n            } else {\r\n                _byProxy.call(self, toHTTPS(src), options, resolve, reject);\r\n            }\r\n        });\r\n    };\r\n\r\n    var _byProxy = function (src, options, resolve, reject) {\r\n        var self = this;\r\n\r\n        options.sameOrigin = self._isSameOrigin(self._actionProxy.call(self, src));\r\n\r\n        self._image.getImgTagByAction(src, options, self._actionProxy.bind(self)).then(function (img) {\r\n            resolve(img, self._actionProxy);\r\n        }, function (error) {\r\n            reject(error);\r\n        });\r\n    };\r\n\r\n    toolProto._actionDirect = function (src) {\r\n        return src;\r\n    };\r\n\r\n    toolProto._actionHTTP = function (src) {\r\n        return changeProtocol(src, \"http:\");\r\n    };\r\n\r\n    toolProto._actionHTTPS = function (src) {\r\n        return changeProtocol(src, \"https:\");\r\n    };\r\n\r\n    toolProto._actionProxy = function (src) {\r\n        var self = this;\r\n\r\n        return self.proxy(src);\r\n    };\r\n\r\n    toolProto._image = {\r\n        ErrorType: {\r\n            CORS: 'cors',\r\n            PROTOCOL: 'protocol',\r\n            NOTFOUNDED: 'notfounded',\r\n            UNEXPECTED: 'unexpected'\r\n        },\r\n        checkHttpStatus: function (src) {\r\n            const self = this;\r\n            return fetch(src, { credentials: 'omit' })\r\n                .then(function (response) {\r\n                    return { status: response.status, statusText: response.statusText };\r\n                })\r\n                .catch(function (error) {\r\n                    return self.ErrorType.UNEXPECTED;\r\n                });\r\n        },\r\n        getImgTag: function (src, options) {\r\n            return new Promise(function (resolve, reject) {\r\n                var self = this;\r\n\r\n                var img = document.createElement(\"img\");\r\n\r\n                if (options.exportable && !options.sameOrigin) {\r\n                    img.dataset.checkCORSHeaders = true;\r\n                    img.crossOrigin = \"anonymous\";\r\n                }\r\n\r\n                img.onload = function () {\r\n\r\n                    console.log('Load OK: ' + img.src);\r\n\r\n                    img.onload = img.onerror = undefined;\r\n\r\n                    if (options.exportable && !options.sameOrigin) {\r\n                        var createCanvas = function (img) {\r\n                            var canvas = document.createElement('CANVAS');\r\n                            var ctx = canvas.getContext('2d');\r\n                            canvas.height = img.height;\r\n                            canvas.width = img.width;\r\n                            ctx.drawImage(img, 0, 0);\r\n\r\n                            return canvas;\r\n                        };\r\n\r\n                        try {\r\n                            var canvas = createCanvas(img);\r\n                            result = canvas.toDataURL(\"image/png\");\r\n                            resolve(img);\r\n                        } catch (e) {\r\n                            if (e.code === 18) { // GLS: 18 - SECURITY_ERR\r\n                                reject(self.ErrorType.CORS);\r\n                            } else {\r\n                                resolve(img);\r\n                            }\r\n                        }\r\n                    } else { resolve(img); }\r\n                };\r\n\r\n                img.onerror = function (error) {\r\n\r\n                    console.log('Load crossOrigin ERROR: ' + img.src);\r\n\r\n                    if (img.dataset.checkCORSHeaders) {\r\n                        img.crossOrigin = null;\r\n\r\n                        img.onerror = undefined;\r\n                        img.onerror = function (error) {\r\n                            console.log('Load ERROR: ' + img.src);\r\n\r\n                            self.checkHttpStatus(img.src).then(function (error) {\r\n                                if (options.ignoreProxification) {\r\n                                    reject(self.ErrorType.PROTOCOL);\r\n                                } else {\r\n                                    if (error.status === 400) {\r\n                                        reject(self.ErrorType.PROTOCOL);\r\n                                    } else {\r\n                                        reject(error);\r\n                                    }\r\n                                }\r\n                            }).catch(reject);\r\n                            img.onload = img.onerror = undefined;\r\n                        };\r\n\r\n                        img.src = src;\r\n\r\n                    } else {\r\n                        console.log('Load ERROR: ' + img.src);\r\n\r\n                        img.onload = img.onerror = undefined;\r\n\r\n                        self.checkHttpStatus(img.src).then(function (error) {\r\n                            if (options.ignoreProxification) {\r\n                                reject(self.ErrorType.PROTOCOL);\r\n                            } else {\r\n                                if (error.status === 400) {\r\n                                    reject(self.ErrorType.PROTOCOL);\r\n                                } else {\r\n                                    reject(error);\r\n                                }\r\n                            }\r\n                        }).catch(reject);\r\n                    }\r\n                };\r\n\r\n                try {\r\n                    img.src = src;\r\n                } catch (ex) {\r\n                    console.log('Load ERROR: ' + img.src);\r\n\r\n                    reject(self.ErrorType.UNEXPECTED);\r\n                }\r\n            }.bind(toolProto._image));\r\n        },\r\n        getImgTagByAction: function (src, options, action) {\r\n            return new Promise(function (resolve, reject) {\r\n                var self = this;\r\n\r\n                var img = document.createElement(\"img\");\r\n\r\n                if (!options.sameOrigin) {\r\n                    if (options.exportable) {\r\n                        img.crossOrigin = \"anonymous\";\r\n                    }\r\n                }\r\n\r\n                img.onload = function () {\r\n                    img.onload = img.onerror = undefined;\r\n                    resolve(img);\r\n                };\r\n                img.onerror = function (error) {\r\n                    console.log('Load ERROR: ' + img.src);\r\n                    img.onload = img.onerror = undefined;\r\n\r\n                    self.checkHttpStatus(img.src).then(function (error) {\r\n                        if (options.ignoreProxification) {\r\n                            reject(self.ErrorType.PROTOCOL);\r\n                        } else {\r\n                            if (error.status === 400) {\r\n                                reject(self.ErrorType.PROTOCOL);\r\n                            } else {\r\n                                reject(error);\r\n                            }\r\n                        }\r\n                    }).catch(reject);\r\n                };\r\n                img.src = action(src);\r\n            }.bind(toolProto._image));\r\n        }\r\n    };\r\n\r\n    toolProto._fetch = {\r\n        Headers: {\r\n            CONTENTTYPE: \"content-type\"\r\n        },\r\n        ErrorType: {\r\n            CORS: 'cors',\r\n            NOTFOUNDED: 'Not_Founded',\r\n            UNEXPECTED: 'Un_Expected',\r\n            UNEXPECTEDCONTENTTYPE: 'Un_Expected_ContentType'\r\n        },\r\n        validateResponse: function (response) {\r\n            if (!response.ok) { // status no está en el rango 200-299\r\n                throw new ResponseError(response.status, response.statusText, response.url);\r\n            }\r\n            return response;\r\n        },\r\n        validateContentType: function (expectedContentType, response) {\r\n            const self = this;\r\n\r\n            if (!expectedContentType) {\r\n                return response;\r\n            }\r\n\r\n            var contentType = response.headers.get(self._fetch.Headers.CONTENTTYPE);\r\n            if (contentType && contentType.indexOf(expectedContentType) === -1) {\r\n                throw Error(self._fetch.ErrorType.UNEXPECTEDCONTENTTYPE);\r\n            }\r\n\r\n            return response;\r\n        }\r\n    };\r\n\r\n    /* Sólo GET */\r\n    toolProto.fetchImage = function (src, options) {\r\n        var self = this;\r\n\r\n        options = options || {};\r\n        options.forImage = true;\r\n\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            if (self.cacheHost.is(src, options)) {\r\n                self.cacheHost.getAction(src, options).then(function (cache) {\r\n                    options.sameOrigin = self._isSameOrigin(cache.action(src));\r\n                    self._image.getImgTagByAction(src, options, cache.action).then(function (img) {\r\n                        resolve(img);\r\n                    }, function (error) {\r\n                        reject(error);\r\n                    });\r\n                });\r\n            } else {\r\n                var cache = self.cacheHost.addKey(src, options);\r\n                cache._actionPromise = new Promise(function (resolveActionPromise, rejectActionPromise) {\r\n\r\n                    const _caching = function (img, action) {\r\n                        cache.action = action.bind(self);\r\n                        cache.exportable = options.exportable;\r\n\r\n                        resolveActionPromise({ action: cache.action });\r\n\r\n                        resolve(img);\r\n                    };\r\n\r\n                    const _reject = function (error) {\r\n                        if (error.status == 200) {\r\n                            //options.useCredentials = true;\r\n\r\n                            // GLS: 04/01/2019 comento la siguiente línea porque no para de pedir al obtener una respuesta correcta y en el cuerpo viene una excepción\r\n                            //makeRequest(options);\r\n\r\n                            self.cacheHost.removeKey(src, options);\r\n                            reject(error);\r\n                        } else {\r\n                            self.cacheHost.removeKey(src, options);\r\n                            reject(error);\r\n                        }\r\n                    };\r\n\r\n                    const makeRequest = function (options) {\r\n                        if (self._isSameOrigin(src)) {\r\n                            options.sameOrigin = true;\r\n                            self._image.getImgTag(src, options).then(function (img) {\r\n                                _caching(img, self._actionDirect);\r\n                            }, _reject);\r\n                        } else {\r\n                            if (!self._isSecureURL(src)) {\r\n                                if (self._isServiceWorker() || (self._isSecureURL(self._location) && self.preventMixedContent)) {\r\n                                    // HTTP (sin intento) -> HTTPS -> (HTTP)Proxy\r\n                                    _currentHTTP.call(self, src, options, _caching, _reject);\r\n                                } else {\r\n                                    // HTTP -> HTTPS (si el visor no es HTTP) -> (HTTP)Proxy\r\n                                    self._image.getImgTag(src, options).then(function (img) {\r\n                                        _caching(img, self._actionDirect);\r\n                                    }, function (error) {\r\n                                        if ((options.exportable && error === self._image.ErrorType.CORS) || !self._isSecureURL(self._location)) {\r\n                                            // Si la imagen debe ser exportable y en la solicitud por HTTP tenemos error de CORS, deducimos que por HTTPS pasará lo mismo\r\n                                            if (error === self._image.ErrorType.PROTOCOL && options.ignoreProxification) {\r\n                                                _reject(error);\r\n                                            } else {\r\n                                                _byProxy.call(self, src, options, _caching, _reject);\r\n                                            }\r\n                                        } else {\r\n                                            _currentHTTP.call(self, src, options, _caching, _reject);\r\n                                        }\r\n                                    });\r\n\r\n                                }\r\n                            } else {\r\n                                // HTTPS -> HTTP -> (HTTPS)Proxy\r\n                                self._image.getImgTag(src, options).then(function (img) {\r\n                                    _caching(img, self._actionDirect);\r\n                                }, function (error) {\r\n                                    if ((options.exportable && error === self._image.ErrorType.CORS) || self._isServiceWorker() || (self._isSecureURL(self._location) && self.preventMixedContent)) {\r\n                                        // Si la imagen debe ser exportable y en la solicitud por HTTPS tenemos error de CORS, deducimos que por HTTP pasará lo mismo\r\n                                        if (error === self._image.ErrorType.PROTOCOL && options.ignoreProxification) {\r\n                                            _reject(error);\r\n                                        } else {\r\n                                            _byProxy.call(self, src, options, _caching, _reject);\r\n                                        }\r\n                                    } else {\r\n                                        _currentHTTPS.call(self, src, options, _caching, _reject);\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    makeRequest(options);\r\n                });\r\n            }\r\n        });\r\n    };\r\n\r\n    toolProto.fetchRetry = function (url, options, n) {\r\n        const self = this;\r\n        var _fetch = fetch;\r\n\r\n        if (options.sync) {\r\n            _fetch = self.fetchSync;\r\n        }\r\n\r\n        return _fetch(url, options).catch(function (error) {\r\n            if (n === 1) throw error;\r\n            return self.fetchRetry(url, options, n - 1);\r\n        });\r\n    };\r\n\r\n    toolProto.fetchSync = function (url, options) {\r\n        var self = this;\r\n\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            var support = {\r\n                searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () {\r\n                    try {\r\n                        new Blob()\r\n                        return !0\r\n                    } catch (e) { return !1 }\r\n                })(), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self\r\n            }\r\n\r\n            if (support.arrayBuffer) {\r\n                var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']\r\n                var isDataView = function (obj) { return obj && DataView.prototype.isPrototypeOf(obj) }\r\n                var isArrayBufferView = ArrayBuffer.isView || function (obj) { return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1 }\r\n            }\r\n\r\n            function parseHeaders(rawHeaders) {\r\n                var headers = new Headers()\r\n                var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\r\n                preProcessedHeaders.split(/\\r?\\n/).forEach(function (line) {\r\n                    var parts = line.split(':')\r\n                    var key = parts.shift().trim()\r\n                    if (key) {\r\n                        var value = parts.join(':').trim()\r\n                        headers.append(key, value)\r\n                    }\r\n                })\r\n                return headers\r\n            }\r\n\r\n\r\n            var request = new Request(url, options);\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.onload = function () {\r\n                var options = { status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') };\r\n                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\r\n                var body = 'response' in xhr ? xhr.response : xhr.responseText;\r\n                resolve(new Response(body, options));\r\n            };\r\n            xhr.onerror = function () { reject(new TypeError('Network request failed')) };\r\n            xhr.ontimeout = function () { reject(new TypeError('Network request failed')) };\r\n            xhr.open(request.method, request.url, false);\r\n            if (request.credentials === 'include') { xhr.withCredentials = !options.sync } else if (request.credentials === 'omit') { xhr.withCredentials = !1 };\r\n            if (!options.sync && ('responseType' in xhr && support.blob)) { xhr.responseType = 'blob' };\r\n            request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) });\r\n            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\r\n        })\r\n    };\r\n\r\n    toolProto.fetchXML = function (url, options) {\r\n        const self = this;\r\n\r\n        options = options || {};\r\n        options.responseType = \"xml\"; // No puedo usar la constante de la API porque está como application/xml y hay servicios que devuelven text/xml //TC.Consts.mimeType.XML;\r\n\r\n        return self.fetch(url, options);\r\n    };\r\n\r\n    toolProto.fetchJSON = function (url, options) {\r\n        const self = this;\r\n\r\n        options = options || {};\r\n        options.responseType = TC.Consts.mimeType.JSON;\r\n\r\n        return self.fetch(url, options);\r\n    };\r\n\r\n    toolProto.fetchBlob = function (url, options) {\r\n        const self = this;\r\n\r\n        options = options || {};\r\n        options.responseType = \"blob\";\r\n\r\n        return self.fetch(url, options);\r\n    };\r\n\r\n    /* Para imágenes por POST */\r\n    toolProto.fetchImageAsBlob = function (url, options) {\r\n        const self = this;\r\n\r\n        options = options || {};\r\n        options.responseType = \"image\";\r\n\r\n        return self.fetch(url, options);\r\n    };\r\n\r\n    /*\r\n        type: GET|POST\r\n        data: cuerpo del mensaje\r\n        contentType: tipo del cuerpo del mensaje\r\n        responseType: tipo de respuesta esperada\r\n        retryAttempts: número de intentos por llamada\r\n    */\r\n    // indicar responseType en options\r\n    toolProto.fetch = function (url, options) {\r\n        const self = this;\r\n\r\n        options = options || {};\r\n\r\n        if (options.type) {\r\n            options.method = options.type;\r\n\r\n            delete options.type;\r\n        }\r\n\r\n        if (options.data) {\r\n            options.body = options.data;\r\n\r\n            delete options.data;\r\n        }\r\n\r\n        if (options.contentType) {\r\n            options.headers = new Headers();\r\n            options.headers.append('Content-Type', options.contentType);\r\n\r\n            delete options.contentType;\r\n        }\r\n\r\n        if (!options.responseType) {\r\n            options.responseType = '';\r\n        }\r\n\r\n        var _makeRequest = function (url, options, actions, cache) {\r\n            var request;\r\n\r\n            // fetch no incluye por defecto las cookies de autenticación, hay que indicarlo.\r\n            //options.credentials = 'include';\r\n\r\n            return (options.retryAttempts ? self.fetchRetry(actions[0].call(self, url), options, options.retryAttempts) : fetch(actions[0].call(self, url), options))\r\n                .then(self._fetch.validateResponse)\r\n                .then(self._fetch.validateContentType.bind(self, options.responseType))\r\n                .then(function (response) {\r\n                    if (cache) {\r\n                        cache.action = actions[0].bind(self);\r\n                    }\r\n\r\n                    const contentType = response.headers.get(self._fetch.Headers.CONTENTTYPE);\r\n\r\n                    //if (!options.responseType) {\r\n                    //    if (contentType) {\r\n                    //        options.responseType = contentType;\r\n                    //    } else {\r\n                    //        return response.text();\r\n                    //    }\r\n                    //}\r\n\r\n                    const responseWithCharsetToDecodedString = function (charset) {\r\n                        /*\r\n                                2018 08 16\r\n                                https://developer.mozilla.org/en-US/docs/Web/API/Response#Methods\r\n                                No existe método xml\r\n\r\n                                https://developer.mozilla.org/en-US/docs/Web/API/Body/text\r\n                                The text() method of the Body mixin takes a Response stream and reads it to completion.\r\n                                It returns a promise that resolves with a USVString object (text).\r\n                                The response is always decoded using UTF-8.\r\n                            */\r\n\r\n                        return response.blob().then(function (blob) {\r\n                            const reader = new FileReader();\r\n\r\n                            return new Promise(function (resolve, reject) {\r\n\r\n                                reader.addEventListener(\"error\", function () {\r\n                                    reader.abort();\r\n                                    reject(new DOMException(\"Problem decoding\"));\r\n                                });\r\n\r\n                                reader.addEventListener(\"loadend\", function () {\r\n                                    resolve(reader.result);\r\n                                });\r\n\r\n                                reader.readAsText(blob, charset);\r\n                            });\r\n                        });\r\n                    };\r\n\r\n                    switch (true) {\r\n                        case options.responseType.indexOf('xml') > -1:\r\n                        case options.responseType.indexOf('text/xml') > -1:\r\n                        case options.responseType.indexOf(TC.Consts.mimeType.XML) > -1:\r\n                            var hasCharset = /charset=([^;]*)/i.exec(contentType);\r\n                            if (hasCharset && hasCharset.length === 2 && hasCharset[1] !== \"UTF-8\") {\r\n                                return responseWithCharsetToDecodedString(hasCharset[1]).then(function (text) {\r\n                                    return (new window.DOMParser()).parseFromString(text, \"text/xml\");\r\n                                });\r\n                            } else {\r\n                                return response.text().then(function (data) {\r\n                                    return (new window.DOMParser()).parseFromString(data, \"text/xml\");\r\n                                });\r\n                            }\r\n                        case options.responseType.indexOf('arraybuffer') > -1:\r\n                            return response.arrayBuffer();\r\n                        case options.responseType.indexOf('image') > -1:\r\n                        case options.responseType.indexOf('blob') > -1:\r\n                            return response.blob().then(function (blob) {\r\n                                return new Blob([blob], { type: contentType });\r\n                            });\r\n                        case options.responseType.indexOf('document') > -1:\r\n                            throw new DeveloperError('Unhandled responseType: ' + options.responseType);\r\n                        case options.responseType.indexOf(TC.Consts.mimeType.JSON) > -1:\r\n                            return response.json();\r\n                        case options.responseType == '':\r\n                        case options.responseType.indexOf('text') > -1:\r\n                        default:\r\n                            var hasCharset = /charset=([^;]*)/i.exec(contentType);\r\n                            if (hasCharset && hasCharset.length === 2 && hasCharset[1] !== \"UTF-8\") {\r\n                                return responseWithCharsetToDecodedString(hasCharset[1]).then(function (text) {\r\n                                    if (options.responseType == '') {\r\n                                        return { responseText: text, contentType: contentType };\r\n                                    } else {\r\n                                        return text;\r\n                                    }\r\n                                });\r\n                            } else {\r\n                                return response.text().then(function (text) {\r\n                                    if (options.responseType == '') {\r\n                                        return { responseText: text, contentType: contentType };\r\n                                    } else {\r\n                                        return text;\r\n                                    }\r\n                                });\r\n                            }\r\n                    }\r\n                })\r\n                .catch(function (error) {\r\n                    if (actions.length === 1) {\r\n                        console.log('request failed', error);\r\n                        return Promise.reject(error);\r\n                    }\r\n\r\n                    actions.shift();\r\n                    return _makeRequest(url, options, actions, cache);\r\n                });\r\n        };\r\n\r\n        if (self.cacheHost.is(url, options)) {\r\n            return new Promise(function (resolve, reject) {\r\n                self.cacheHost.getAction(url, options).then(function (cache) {\r\n                    resolve(_makeRequest(url, options, [cache.action]));\r\n                }).catch(function (error) {\r\n                    if (!error.status || error.status > 400) {\r\n                        reject(new Error(error.text));\r\n                    } else {\r\n                        resolve(self.fetch(url, options));\r\n                    }\r\n                });\r\n            });            \r\n        } else {\r\n            var cache = self.cacheHost.addKey(url, options);\r\n            return new Promise(function (resolve, reject) {\r\n                cache._actionPromise = new Promise(function (resolveActionPromise, rejectActionPromise) {\r\n\r\n                    url = srcToURL(url).href;\r\n\r\n                    const fnResolve = function (data) {\r\n                        //self.cacheHost.hostCacheService.addHost(cache.key, cache.action);\r\n                        resolveActionPromise({ action: cache.action });\r\n                        resolve(data);\r\n                    };\r\n\r\n                    const fnReject = function (error) {\r\n                        //self.cacheHost.hostCacheService.removeHost(cache.key);\r\n                        self.cacheHost.removeKey(url, options);\r\n\r\n                        rejectActionPromise(error);\r\n                        reject(new Error(error.text));\r\n                    };\r\n\r\n                    if (self._isSameOrigin(url)) {\r\n                        _makeRequest(url, options, [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);\r\n                    } else {\r\n                        if (!self._isSecureURL(url)) {\r\n                            if (self._isServiceWorker()) {\r\n                                // HTTP (sin intento) -> HTTPS -> (HTTP)Proxy\r\n                                _makeRequest(url, options, [self._actionHTTPS, self._actionProxy], cache).then(fnResolve).catch(fnReject);\r\n                            } else {\r\n                                // HTTP (si el visor no es HTTPS) -> HTTPS -> (HTTP)Proxy\r\n                                _makeRequest(url, options, !self._isSecureURL(self._location) ? [self._actionDirect, self._actionHTTPS, self._actionProxy] : [self._actionHTTPS, self._actionProxy], cache).then(fnResolve).catch(fnReject);\r\n                            }\r\n                        } else {\r\n                            if (self._isServiceWorker()) {\r\n                                // HTTPS -> (HTTPS)Proxy\r\n                                _makeRequest(url, options, [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);\r\n                            } else {\r\n                                // HTTPS -> HTTP (si el visor no es HTTPS) -> (HTTPS)Proxy\r\n                                _makeRequest(url, options, !self._isSecureURL(self._location) ? [self._actionDirect, self._actionHTTP, self._actionProxy] : [self._actionDirect, self._actionProxy], cache).then(fnResolve).catch(fnReject);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                cache._actionPromise.catch(function (error) {\r\n                    if (!error.status || error.status > 400) {\r\n                        reject(new Error(error.text));\r\n                    } else {\r\n                        resolve(self.fetch(url, options));\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    };\r\n})();"]}