{"version":3,"sources":["tool/ElevationServiceGoogle.js"],"names":["TC","tool","ElevationService","syncLoadJS","apiLocation","ElevationServiceGoogle","options","self","this","apply","arguments","url","intIdx","lastIndexOf","length","googleMapsKey","minimumElevation","nativeCRS","maxCoordinateCountPerRequest","minRetryInterval","maxRetries","Number","isInteger","inherit","toolProto","prototype","googleElevator","currentRequestIds","Map","downRequestId","id","currentCount","get","delete","request","Promise","reject","Error","requestId","cancelledResponse","status","geomType","coordinateList","coordinates","Consts","geom","POINT","POLYLINE","allowedGeometryTypes","includes","resolve","chunks","i","ii","push","slice","count","set","upRequestId","retries","subrequests","map","subrequest","chunk","requestOptions","Util","extend","res","rej","has","then","result","console","log","setTimeout","r","catch","e","all","responses","results","Array","concat","filter","elevations","crs","reproject","googleMapsIsLoaded","window","google","maps","Cfg","proxyExceptions","loadJS","coords","p","lat","lng","getElevationForLocations","locations","parseResponse","response","location","elevation","cancelRequest"],"mappings":"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","sourcesContent":["\r\n// https://developers.google.com/maps/documentation/javascript/elevation?hl=es\r\n\r\nTC.tool = TC.tool || {};\r\n\r\nif (!TC.tool.ElevationService) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/tool/ElevationService');\r\n}\r\n\r\nTC.tool.ElevationServiceGoogle = function (options) {\r\n    const self = this;\r\n    TC.tool.ElevationService.apply(self, arguments);\r\n    self.url = self.options.url || '//maps.googleapis.com/maps/api/js?v=3';\r\n    const intIdx = self.url.lastIndexOf('?');\r\n    if (intIdx < 0) {\r\n        self.url += '?';\r\n    }\r\n    else if (intIdx < self.url.length - 1) {\r\n        self.url += '&';\r\n    }\r\n    self.url += 'key=' + self.options.googleMapsKey;\r\n    self.minimumElevation = self.options.minimumElevation || -9998;\r\n    self.nativeCRS = 'EPSG:4326';\r\n    self.maxCoordinateCountPerRequest = 512;\r\n    self.minRetryInterval = 5100;\r\n    self.maxRetries = Number.isInteger(self.options.maxRetries) ? self.options.maxRetries : 0;\r\n};\r\n\r\nTC.inherit(TC.tool.ElevationServiceGoogle, TC.tool.ElevationService);\r\n\r\n(function () {\r\n    const toolProto = TC.tool.ElevationServiceGoogle.prototype;\r\n\r\n    let googleElevator;\r\n    const currentRequestIds = new Map();\r\n\r\n    const upRequestId = function (id, count) {\r\n        let currentCount = currentRequestIds.get(id) || 0;\r\n        currentCount += count;\r\n        currentRequestIds.set(id, currentCount);\r\n    };\r\n\r\n    const downRequestId = function (id) {\r\n        let currentCount = currentRequestIds.get(id);\r\n        if (currentCount) {\r\n            currentCount -= 1;\r\n            if (currentCount <= 0) {\r\n                currentRequestIds.delete(id);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    toolProto.request = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        if (!self.options.googleMapsKey) {\r\n            return Promise.reject(Error('Missing Google Maps key'));\r\n        }\r\n        const requestId = options.id;\r\n\r\n        const cancelledResponse = { status: 'CANCELLED' };\r\n        let geomType;\r\n        let coordinateList = options.coordinates;\r\n        if (coordinateList.length === 1) {\r\n            geomType = TC.Consts.geom.POINT;\r\n        }\r\n        else {\r\n            geomType = TC.Consts.geom.POLYLINE;\r\n        }\r\n\r\n        if (self.options.allowedGeometryTypes && !self.options.allowedGeometryTypes.includes(geomType)) {\r\n            return Promise.reject(Error(geomType + ' geometry type not allowed by configuration'));\r\n        }\r\n\r\n        if (coordinateList.length > self.maxCoordinateCountPerRequest) {\r\n            // Google no soporta tantos puntos por petición, dividimos la petición en varias\r\n            return new Promise(function (resolve, reject) {\r\n                const chunks = [];\r\n                for (i = 0, ii = coordinateList.length; i < ii; i += self.maxCoordinateCountPerRequest) {\r\n                    chunks.push(coordinateList.slice(i, i + self.maxCoordinateCountPerRequest));\r\n                }\r\n                upRequestId(requestId, chunks.length);\r\n                let retries = 0;\r\n                const subrequests = chunks.map(function subrequest(chunk) {\r\n                    const requestOptions = TC.Util.extend({}, options, { coordinates: chunk, id: requestId });\r\n                    return new Promise(function (res, rej) {\r\n                        if (!currentRequestIds.has(requestId)) {\r\n                            res(cancelledResponse);\r\n                        }\r\n                        else {\r\n                            self.request(requestOptions)\r\n                                .then(function (result) {\r\n                                    if (result.status === 'OVER_QUERY_LIMIT') {\r\n                                        console.log(\"OVER_QUERY_LIMIT status reached for request \" + requestId);\r\n                                        if (!currentRequestIds.has(requestId)) {\r\n                                            res(cancelledResponse);\r\n                                        }\r\n                                        else {\r\n                                            // Peticiones demasiado seguidas: esperamos y volvemos a pedir\r\n                                            if (!self.maxRetries || retries < self.maxRetries) {\r\n                                                retries = retries + 1;\r\n                                                setTimeout(function () {\r\n                                                    subrequest(chunk)\r\n                                                        .then(r => res(r))\r\n                                                        .catch(e => rej(e));\r\n                                                }, self.minRetryInterval);\r\n                                            }\r\n                                            else {\r\n                                                res(result);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        res(result);\r\n                                    }\r\n                                })\r\n                                .catch(e => rej(e));\r\n                        }\r\n                    });\r\n                });\r\n                Promise.all(subrequests).then(function mergeResponses(responses) {\r\n                    const results = Array.prototype.concat.apply([], responses\r\n                        .filter(r => r.status === 'OK')\r\n                        .map(r => r.elevations));\r\n                    downRequestId(requestId);\r\n                    resolve({\r\n                        status: 'OK',\r\n                        elevations: results\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (options.crs && options.crs !== self.nativeCRS) {\r\n            coordinateList = TC.Util.reproject(coordinateList, options.crs, self.nativeCRS);\r\n        }\r\n\r\n        return new Promise(function (resolve, reject) {\r\n            const googleMapsIsLoaded = window.google && window.google.maps;\r\n            if (!googleMapsIsLoaded) {\r\n                TC.Cfg.proxyExceptions = TC.Cfg.proxyExceptions || [];\r\n                TC.Cfg.proxyExceptions.push(self.url);\r\n            }\r\n            TC.loadJS(\r\n                !googleMapsIsLoaded,\r\n                self.url,\r\n                function () {\r\n                    googleElevator = googleElevator || new google.maps.ElevationService();\r\n                    const coords = coordinateList.map(p => ({ lat: p[1], lng: p[0] }));\r\n                    googleElevator.getElevationForLocations({\r\n                        locations: coords\r\n                    }, function (elevations, status) {\r\n                        downRequestId(requestId);\r\n                        resolve({\r\n                            elevations: elevations,\r\n                            status: status\r\n                        });\r\n                    })\r\n                },\r\n                false,\r\n                true\r\n            );\r\n        });\r\n    };\r\n\r\n    toolProto.parseResponse = function (response, options) {\r\n        const self = this;\r\n        switch (response.status) {\r\n            case 'OK':\r\n                return response.elevations.map(function (r) {\r\n                    if (options.crs && options.crs !== self.nativeCRS) {\r\n                        return TC.Util.reproject([r.location.lng(), r.location.lat()], self.nativeCRS, options.crs).concat(r.elevation);\r\n                    }\r\n                    else {\r\n                        return [r.location.lng(), r.location.lat(), r.elevation];\r\n                    }\r\n                });\r\n            //case 'OVER_DAILY_LIMIT':\r\n            //case 'OVER_QUERY_LIMIT':\r\n            //case 'REQUEST_DENIED':\r\n            //    self.serviceIsDisabled = true;\r\n            default:\r\n                return [];\r\n        }\r\n    };\r\n\r\n    toolProto.cancelRequest = function (id) {\r\n        currentRequestIds.delete(id);\r\n    };\r\n})();"]}