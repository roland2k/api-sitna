{"version":3,"sources":["tool/ElevationServiceIDENA.js"],"names":["TC","tool","ElevationService","syncLoadJS","apiLocation","ElevationServiceIDENA","options","apply","this","arguments","url","process","coverageClass","minimumElevation","inherit","toolProto","prototype","request","geometryOptions","coordinates","type","Consts","geom","POLYLINE","length","POINT","sepIdx","indexOf","includeHeights","substr","dataInputs","geometry","mimeType","JSON","value","wrap","Geometry","toGeoJSON","crs","idx","lastIndexOf","srid","call","parseResponse","response","self","coverageClassCount","split","coords","coordinateCount","result","slice","i","point","offset","j","elevation","push"],"mappings":"AAAAA,GAAGC,KAAOD,GAAGC,MAAQ,GAEhBD,GAAGC,KAAKC,kBACTF,GAAGG,WAAWH,GAAGI,YAAc,4BAGnCJ,GAAGC,KAAKI,sBAAwB,SAAUC,GAEtCN,GAAGC,KAAKC,iBAAiBK,MADZC,KACwBC,WADxBD,KAERE,IAFQF,KAEGF,QAAQI,KAAO,6BAFlBF,KAGRG,QAHQH,KAGOF,QAAQK,SAAW,yBAH1BH,KAIRI,cAJQJ,KAIaF,QAAQM,eAAiB,kDAJtCJ,KAKRK,iBALQL,KAKgBF,QAAQO,mBAAqB,MAG9Db,GAAGc,QAAQd,GAAGC,KAAKI,sBAAuBL,GAAGC,KAAKC,mBAElD,WACI,MAAMa,EAAYf,GAAGC,KAAKI,sBAAsBW,UAEhDD,EAAUE,QAAU,SAAUX,GAC1B,MAEMY,EAAkB,CACpBC,aAFJb,EAAUA,GAAW,IAEIa,YACrBC,KAAMpB,GAAGqB,OAAOC,KAAKC,UAEzB,GAAmC,IAA/BjB,EAAQa,YAAYK,OAAc,CAClCN,EAAgBC,YAAcb,EAAQa,YAAY,GAClDD,EAAgBE,KAAOpB,GAAGqB,OAAOC,KAAKG,MAE1C,IAAIb,EAAgBN,EAAQM,eAVfJ,KAUqCI,cAClD,MAAMc,EAASd,EAAce,QAAQ,KACjCf,GAAiBc,GAAU,IAAMpB,EAAQsB,iBACzChB,EAAgBA,EAAciB,OAAO,EAAGH,IAE5C,MAAMI,EAAa,CACflB,cAAeA,EACfmB,SAAU,CACNC,SAAUhC,GAAGqB,OAAOW,SAASC,KAC7BC,MAAOlC,GAAGmC,KAAKC,SAASC,UAAUnB,KAG1C,GAAIZ,EAAQgC,IAAK,CACb,IAAIC,EAAMjC,EAAQgC,IAAIE,YAAY,KAC9BD,EAAM,IACNA,EAAMjC,EAAQgC,IAAIE,YAAY,MAElCV,EAAWW,KAAOnC,EAAQgC,IAAIT,OAAOU,EAAM,GAE/C,OAAOvC,GAAGC,KAAKC,iBAAiBc,UAAUC,QAAQyB,KA7BrClC,KA6BgD,CAAEsB,WAAYA,GAAcxB,IAG7FS,EAAU4B,cAAgB,SAAUC,EAAUtC,GAC1C,MAAMuC,EAAOrC,KACPI,EAAgBN,EAAQM,eAAiBiC,EAAKjC,cAC9CkC,EAAsBxC,EAAQsB,gBAAkBhB,EAAiBA,EAAcmC,MAAM,KAAKvB,OAAS,EACzG,GAAIsB,GAAsB,EACtB,OAAO9C,GAAGC,KAAKC,iBAAiBc,UAAU2B,cAAcD,KAAKG,EAAMD,EAAUtC,GAEjF,GAAIsC,EAASzB,YAAa,CACtB,MAAM6B,EAASJ,EAASzB,YAClB8B,EAAkBD,EAAOxB,OAASsB,EAClCI,EAASF,EAAOG,MAAM,EAAGF,GAC/B,IAAK,IAAIG,EAAI,EAAGA,EAAIH,EAAiBG,IAAK,CACtC,MAAMC,EAAQH,EAAOE,GACjBC,EAAM,GAAKR,EAAKhC,mBAChBwC,EAAM,GAAK,MAGnB,IAASD,EAAI,EAAGA,EAAIN,EAAoBM,IAAK,CACzC,MAAME,EAASF,EAAIH,EACnB,IAAK,IAAIM,EAAI,EAAGA,EAAIN,EAAiBM,IAAK,CACtC,MAAMC,EAAYR,EAAOO,EAAID,GAAQ,GACrCJ,EAAOK,GAAGE,KAAKD,EAAYX,EAAKhC,iBAAmB,KAAO2C,IAGlE,OAAON,EAEX,MAAO,IA9Df","sourcesContent":["TC.tool = TC.tool || {};\r\n\r\nif (!TC.tool.ElevationService) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/tool/ElevationService');\r\n}\r\n\r\nTC.tool.ElevationServiceIDENA = function (options) {\r\n    const self = this;\r\n    TC.tool.ElevationService.apply(self, arguments);\r\n    self.url = self.options.url || '//idena.navarra.es/ogc/wps';\r\n    self.process = self.options.process || 'gs:ExtractRasterPoints';\r\n    self.coverageClass = self.options.coverageClass || 'MDT_maxima_actualidad,Alturas_maxima_actualidad',\r\n    self.minimumElevation = self.options.minimumElevation || -9998;\r\n};\r\n\r\nTC.inherit(TC.tool.ElevationServiceIDENA, TC.tool.ElevationService);\r\n\r\n(function () {\r\n    const toolProto = TC.tool.ElevationServiceIDENA.prototype;\r\n\r\n    toolProto.request = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const geometryOptions = {\r\n            coordinates: options.coordinates,\r\n            type: TC.Consts.geom.POLYLINE\r\n        };\r\n        if (options.coordinates.length === 1) {\r\n            geometryOptions.coordinates = options.coordinates[0];\r\n            geometryOptions.type = TC.Consts.geom.POINT;\r\n        }\r\n        let coverageClass = options.coverageClass || self.coverageClass;\r\n        const sepIdx = coverageClass.indexOf(',');\r\n        if (coverageClass && sepIdx >= 0 && !options.includeHeights) {\r\n            coverageClass = coverageClass.substr(0, sepIdx);\r\n        }\r\n        const dataInputs = {\r\n            coverageClass: coverageClass,\r\n            geometry: {\r\n                mimeType: TC.Consts.mimeType.JSON,\r\n                value: TC.wrap.Geometry.toGeoJSON(geometryOptions)\r\n            }\r\n        };\r\n        if (options.crs) {\r\n            var idx = options.crs.lastIndexOf(':');\r\n            if (idx < 0) {\r\n                idx = options.crs.lastIndexOf('#');\r\n            }\r\n            dataInputs.srid = options.crs.substr(idx + 1);\r\n        }\r\n        return TC.tool.ElevationService.prototype.request.call(self, { dataInputs: dataInputs }, options);\r\n    };\r\n\r\n    toolProto.parseResponse = function (response, options) {\r\n        const self = this;\r\n        const coverageClass = options.coverageClass || self.coverageClass\r\n        const coverageClassCount = (options.includeHeights && coverageClass) ? coverageClass.split(',').length : 1;\r\n        if (coverageClassCount <= 1) {\r\n            return TC.tool.ElevationService.prototype.parseResponse.call(self, response, options);\r\n        }\r\n        if (response.coordinates) {\r\n            const coords = response.coordinates;\r\n            const coordinateCount = coords.length / coverageClassCount;\r\n            const result = coords.slice(0, coordinateCount);\r\n            for (var i = 0; i < coordinateCount; i++) {\r\n                const point = result[i];\r\n                if (point[2] < self.minimumElevation) {\r\n                    point[2] = null;\r\n                }\r\n            }\r\n            for (var i = 1; i < coverageClassCount; i++) {\r\n                const offset = i * coordinateCount;\r\n                for (var j = 0; j < coordinateCount; j++) {\r\n                    const elevation = coords[j + offset][2];\r\n                    result[j].push(elevation < self.minimumElevation ? null : elevation);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        return [];\r\n    };\r\n})();"]}