{"version":3,"sources":["tool/Elevation.js"],"names":["TC","tool","Elevation","options","self","this","_servicePromises","serviceOptions","services","abstractServicePromise","Promise","resolve","reject","loadJS","ElevationService","apiLocation","forEach","srv","idx","serviceName","name","ctorName","substr","toUpperCase","path","srvOptions","then","toolProto","prototype","requestUID","getService","getServices","all","getElevation","id","undefined","resolution","sampleNumber","partialResult","partialCallback","done","Util","isFunction","Geometry","coordinateList","coordinates","isSinglePoint","length","newCoordinateList","point","arr","prev","distance","getDistance","pos","n","Math","ceil","x","sin","cos","xpos","ypos","dx","dy","i","push","numPoints","milestones","accumulatedDistance","index","intervalLength","nextMilestoneDistance","milestone","dd","included","prevMilestone","filter","m","p","insertBefore","count","p1","p2","y","spliceParams","Array","ii","splice","apply","totalDistance","distances","map","slice","defaultCount","leftCount","insertionCount","obj","partialInsertionCount","min","round","hasOwnProperty","includeHeights","responses","fill","res","rej","request","response","parseResponse","_updatePartialResult","r","ri","cancelRequest","some","error","console","msg","setGeometry","features","conditionToPromises","promises","results","maxCoordQuantity","reduce","acc","feat","getCoords","pointArray","feature","Polyline","Polygon","MultiPolyline","MultiPolygon","floor","getLength","Error","errors","MAX_COORD_QUANTITY_EXCEEDED","getElevOptions","coords","crs","getRingElevPromises","ring","coordPromises","polPromises","polygon","rs","rj","ringPromises","Point","coordsArray","copyElevation","source","target","isPoint","isArray","node","getNumVertices","cur","log","CLASSNAME","featCoords","setCoords","pending","elevation","height","validResponses","j","jj","rPoint","every","UNDEFINED","getElevationGain"],"mappings":"AAAAA,GAAGC,KAAOD,GAAGC,MAAQ,GAErBD,GAAGC,KAAKC,UAAY,SAAUC,GAC1B,MAAMC,EAAOC,KACbD,EAAKD,QAAUA,GAAW,GAC1BC,EAAKE,iBAAmB,GACxB,MAAMC,EAAiBH,EAAKD,QAAQK,UAAY,CAC5C,wBACA,wBACA,wBACA,0BAGEC,EAAyB,IAAIC,QAAQ,SAAUC,EAASC,GAC1DZ,GAAGa,QACEb,GAAGC,KAAKa,iBACTd,GAAGe,YAAc,2BACjB,WACIJ,QAKZJ,EAAeS,QAAQ,SAAUC,EAAKC,GAClCd,EAAKE,iBAAiBY,GAAO,IAAIR,QAAQ,SAAUC,EAASC,GACxD,MAAMO,EAA8B,iBAARF,EAAoBA,EAAMA,EAAIG,KACpDC,EAAWF,EAAYG,OAAO,EAAG,GAAGC,cAAgBJ,EAAYG,OAAO,GACvEE,EAAOxB,GAAGe,YAAc,WAAaM,EACrCI,EAA6B,iBAARR,EAAoB,GAAKA,EACpDjB,GAAGa,QACEb,GAAGC,KAAKoB,GACTG,EACA,WACIf,EAAuBiB,KAAK,WACxBf,EAAQ,IAAIX,GAAGC,KAAKoB,GAAUI,cAQtD,WACI,MAAME,EAAY3B,GAAGC,KAAKC,UAAU0B,UAEpC,IAAIC,EAAa,EAKjBF,EAAUG,WAAa,SAAUZ,GAC7B,OAAOb,KAAKC,iBAAiBY,IAGjCS,EAAUI,YAAc,WACpB,OAAOrB,QAAQsB,IAAI3B,KAAKC,mBAG5BqB,EAAUM,aAAe,SAAU9B,GAC/B,MAAMC,EAAOC,MACbF,EAAUA,GAAW,IACb+B,GAdDL,SAeoBM,IAAvBhC,EAAQiC,aACRjC,EAAQiC,WAAahC,EAAKD,QAAQiC,iBAETD,IAAzBhC,EAAQkC,eACRlC,EAAQkC,aAAejC,EAAKD,QAAQkC,cAExC,IACIC,EACAC,EAFAC,GAAO,EAGPxC,GAAGyC,KAAKC,WAAWvC,EAAQoC,mBAC3BA,EAAkBpC,EAAQoC,iBAG9B,OAAO,IAAI7B,QAAQ,SAAUC,EAASC,GAClCZ,GAAGa,QACEb,GAAG2C,SACJ3C,GAAGe,YAAc,cACjB,WACI,IAAI6B,EAAiBzC,EAAQ0C,YAC7B,MAAMC,EAA0C,IAA1BF,EAAeG,OAErC,IAAKD,EACD,GAAI3C,EAAQiC,WAAY,CACpB,MAAMY,EAAoB,GAC1BJ,EAAe5B,QAAQ,SAAUiC,EAAO/B,EAAKgC,GACzC,GAAIhC,EAAK,CACL,MAAMiC,EAAOD,EAAIhC,EAAM,GACjBkC,EAAWpD,GAAG2C,SAASU,YAAYF,EAAMF,GAC/C,GAAIG,EAAWjD,EAAQiC,WAAY,CAE/B,IAAIkB,EAAOF,EAAWjD,EAAQiC,WAAc,EAExCmB,EAAIC,KAAKC,KAAKL,EAAWjD,EAAQiC,YACrC,GAAY,IAARkB,EAAW,CACXC,GAAQ,EACRD,EAAMnD,EAAQiC,WAElB,MAAMsB,EAAIT,EAAM,GAAKE,EAAK,GAEpBQ,GADIV,EAAM,GAAKE,EAAK,IACVC,EACVQ,EAAMF,EAAIN,EAChB,IAAIS,EAAOV,EAAK,GAAKG,EAAMM,EACvBE,EAAOX,EAAK,GAAKG,EAAMK,EACvBI,EAAK5D,EAAQiC,WAAawB,EAC1BI,EAAK7D,EAAQiC,WAAauB,EAC9B,IAAK,IAAIM,EAAI,EAAGA,EAAIV,EAAGU,IAAK,CACxBjB,EAAkBkB,KAAK,CAACL,EAAMC,IAC9BD,GAAQE,EACRD,GAAQE,IAIpBhB,EAAkBkB,KAAKjB,KAE3BL,EAAiBI,EACjB7C,EAAQiC,WAAa,EACrBjC,EAAQkC,aAAe,OAEtB,GAAIlC,EAAQkC,aAAc,CAC3B,MAAM8B,EAAYvB,EAAeG,OACjC,GAAIoB,EAAYhE,EAAQkC,aAAc,CAGlC,MAAM+B,EAAa,GACnB,IAAIC,EAAsB,EAC1BzB,EAAe5B,QAAQ,SAAUiC,EAAO/B,EAAKgC,GACrChC,IACAmD,GAAuBrE,GAAG2C,SAASU,YAAYH,EAAIhC,EAAM,GAAI+B,IAEjEmB,EAAWF,KAAK,CACZI,MAAOpD,EACPkC,SAAUiB,MAGlB,MAAME,EAAiBF,EAAsBlE,EAAQkC,aACrD,IAAImC,EAAwB,EAC5BJ,EAAWpD,QAAQ,SAAUyD,EAAWvD,EAAKgC,GACzC,MAAMwB,EAAKD,EAAUrB,SAAWoB,EAChC,GAAW,IAAPE,EACAD,EAAUE,UAAW,OAEpB,GAAID,EAAK,EAAG,CACb,GAAID,EAAUH,MAAO,CACjB,MAAMM,EAAgB1B,EAAIhC,EAAM,GAC5BsD,EAAwBI,EAAcxB,SAAWsB,EACjDE,EAAcD,UAAW,EAGzBF,EAAUE,UAAW,EAG7B,KAAOF,EAAUrB,SAAWoB,GACxBA,GAAyBD,KAIrCH,EAAWS,OAAOC,IAAMA,EAAEH,UAAU3D,QAAQ,SAAU8D,GAClDlC,EAAekC,EAAER,OAAS,OAE9B1B,EAAiBA,EAAeiC,OAAOE,GAAW,OAANA,QAE3C,GAAIZ,EAAYhE,EAAQkC,aAAc,CAEvC,MAAM2C,EAAe,SAAU9B,EAAKhC,EAAK+D,GACrC,MAAMC,EAAKhC,EAAIhC,EAAM,GACfiE,EAAKjC,EAAIhC,GACTqC,EAAI0B,EAAQ,EAClB,IAAIvB,EAAIwB,EAAG,GACPE,EAAIF,EAAG,GACX,MAAMnB,GAAMoB,EAAG,GAAKzB,GAAKH,EACnBS,GAAMmB,EAAG,GAAKC,GAAK7B,EACnB8B,EAAe,IAAIC,MAAML,EAAQ,GACvCI,EAAa,GAAKnE,EAClBmE,EAAa,GAAK,EAClB,IAAK,IAAIpB,EAAI,EAAGsB,EAAKF,EAAatC,OAAQkB,EAAIsB,EAAItB,IAAK,CACnDP,GAAKK,EACLqB,GAAKpB,EACLqB,EAAapB,GAAK,CAACP,EAAG0B,GAE1BlC,EAAIsC,OAAOC,MAAMvC,EAAKmC,IAE1B,IAAIK,EAAgB,EACpB,MAAMC,EAAY/C,EAAegD,IAAI,SAAU3C,EAAO/B,EAAKgC,GACvD,IAAIE,EAAW,EACf,GAAIlC,EAAK,CACLkC,EAAWpD,GAAG2C,SAASU,YAAYH,EAAIhC,EAAM,GAAI+B,GACjDyC,GAAiBtC,EAErB,MAAO,CACHkB,MAAOpD,EACPkC,SAAUA,KAIlBR,EAAiBA,EAAeiD,QAChC,MAAMC,EAAe3F,EAAQkC,aAAe8B,EAC5C,IAAI4B,EAAYD,EACZE,EAAiB,EACrB,IAAK,IAAI/B,EAAI,EAAGsB,EAAKI,EAAU5C,OAAQgD,GAAa9B,EAAIsB,EAAItB,IAAK,CAC7D,MAAMgC,EAAMN,EAAU1B,GACtB,GAAqB,IAAjBgC,EAAI7C,SAAgB,CACpB,MAAM8C,EAAwB1C,KAAK2C,IAAI3C,KAAK4C,MAAMN,EAAeG,EAAI7C,SAAWsC,GAAgBK,IAAc,EAC9GA,GAAaG,EACblB,EAAapC,EAAgBqD,EAAI3B,MAAQ0B,EAAgBE,GACzDF,GAAkBE,IAI9B/F,EAAQiC,WAAa,EACrBjC,EAAQkC,aAAe,EAI/BlC,EAAQ0C,YAAcD,EACtBN,EAAgBM,EAAegD,IAAIb,GAAK,CAACA,EAAE,GAAIA,EAAE,GAAI,OAEhD5E,EAAQkG,eAAe,oBACxBlG,EAAQmG,eAAiBxD,GAE7B1C,EAAK2B,cAAcL,KAAK,SAAUlB,GAC9B,MAAM+F,EAAY,IAAIjB,MAAM9E,EAASuC,QACrCwD,EAAUC,MAAK,GACfhG,EACKQ,QAAQ,SAAUC,EAAKC,GAEE,IAAIR,QAAQ,SAAU+F,EAAKC,GAC7CzF,EAAI0F,QAAQxG,GAASuB,KACjB,SAAUkF,GAEFH,EADAjE,EACI,KAGAvB,EAAI4F,cAAcD,EAAUzG,KAGxC,WACIsG,EAAI,UAIF/E,KAAK,SAAUkF,GACzB,IAAKpE,EAAM,CACP+D,EAAUrF,GAAO0F,EACjB,GAAiB,OAAbA,EAAmB,CACfxG,EAAK0G,qBAAqBxE,EAAeiE,KACzC/D,GAAO,GAEPD,GACAA,EAAgBD,GAGxB,GAAIE,EAAM,CACN+D,EAAUvF,QAAQ,CAAC+F,EAAGC,KAAa,IAAND,GAAevG,EAASwG,GAAIC,cAAc9G,EAAQ+B,KAC/EvB,EAAQ2B,EAAc4E,KAAKnC,GAAc,OAATA,EAAE,IAAezC,EAAgB,OAG1E,SAAU6E,GACTC,QAAQD,MAAMA,QAG3B,SAAUE,GACTzG,EAAOyG,UAO3B1F,EAAU2F,YAAc,SAAUnH,GAC9B,MAAMC,EAAOC,KAEPkH,GADNpH,EAAUA,GAAW,IACIoH,UAAY,GAErC,GAAIA,EAASxE,OAAQ,CAEjB,MAAMyE,EAAsB,SAAUC,EAAU9G,EAASC,GACrDF,QAAQsB,IAAIyF,GAAU/F,KAClB,SAAUgG,GACN/G,EAAQ+G,IAEZ,SAAUP,GACNvG,EAAOuG,MAKnB,OAAO,IAAIzG,QAAQ,SAAUC,EAASC,GAClC,GAAIT,EAAQwH,kBACJxH,EAAQiC,WAAY,CAkBpB,GAhBkBmF,EAASK,OAAO,SAAUC,EAAKC,GAC7C,GAAIA,EAAM,CACND,GAAYC,EAAKC,UAAU,CAAEC,YAAY,IAAQjF,OACjD,QAAQ,GACJ,KAAK/C,GAAGiI,QAAQC,UAAYJ,aAAgB9H,GAAGiI,QAAQC,SACvD,KAAKlI,GAAGiI,QAAQE,SAAWL,aAAgB9H,GAAGiI,QAAQE,QACtD,KAAKnI,GAAGiI,QAAQG,eAAiBN,aAAgB9H,GAAGiI,QAAQG,cAC5D,KAAKpI,GAAGiI,QAAQI,cAAgBP,aAAgB9H,GAAGiI,QAAQI,aACvDR,GAAYrE,KAAK8E,MAAMR,EAAKS,YAAcpI,EAAQiC,aAM9D,OAAOyF,GACR,GACa1H,EAAQwH,iBAAkB,CACtC/G,EAAO4H,MAAMxI,GAAGC,KAAKC,UAAUuI,OAAOC,8BACtC,QAIZ,MAAMtG,EAAajC,EAAQiC,YAAc,EACnCuG,EAAiB,SAAUC,GAC7B,MAAO,CACHC,IAAK1I,EAAQ0I,IACbhG,YAAa+F,EACbxG,WAAYA,EACZC,aAAc,IAGhByG,EAAsB,SAAUC,GAClC,OAAO3I,EAAK6B,aAAa0G,EAAeI,KAEtCC,EAAgBzB,EAAS3B,IAAI,SAAUqC,GACzC,OAAO,IAAIvH,QAAQ,SAAU+F,EAAKC,GAE9B,QAAQ,GACJ,KAAMuB,EACFxB,EAAI,MACJ,MACJ,KAAKzG,GAAGiI,SAAWjI,GAAGiI,QAAQI,cAAgBJ,aAAmBjI,GAAGiI,QAAQI,aACxE,MAAMY,EAAchB,EACfF,YACAnC,IAAI,SAAUsD,GACX,OAAO,IAAIxI,QAAQ,SAAUyI,EAAIC,GAC7B5B,EAAoB0B,EAAQtD,IAAIkD,GAAsBK,EAAIC,OAGtE5B,EAAoByB,EAAaxC,EAAKC,GACtC,MACJ,KAAK1G,GAAGiI,SAAWjI,GAAGiI,QAAQE,SAAWF,aAAmBjI,GAAGiI,QAAQE,QACvE,KAAKnI,GAAGiI,SAAWjI,GAAGiI,QAAQG,eAAiBH,aAAmBjI,GAAGiI,QAAQG,cACzE,MAAMiB,EAAepB,EAChBF,YACAnC,IAAIkD,GACTtB,EAAoB6B,EAAc5C,EAAKC,GACvC,MACJ,KAAK1G,GAAGiI,SAAWjI,GAAGiI,QAAQC,UAAYD,aAAmBjI,GAAGiI,QAAQC,SACpE9H,EAAK6B,aAAa0G,EAAeV,EAAQF,cAAcrG,KACnD,SAAUkH,GACNnC,EAAImC,IAER,SAAUzB,GACNT,EAAI8B,MAAMrB,MAGlB,MACJ,KAAKnH,GAAGiI,SAAWjI,GAAGiI,QAAQqB,OAASrB,aAAmBjI,GAAGiI,QAAQqB,MACjElJ,EAAK6B,aAAa0G,EAAe,CAACV,EAAQF,eAAerG,KACrD,SAAUkH,GACNnC,EAAImC,EAAO,KAEf,SAAUzB,GACNT,EAAI8B,MAAMrB,MAGlB,MACJ,QACIT,EAAI8B,MAAM,gCAM1B9H,QAAQsB,IAAIgH,GAAetH,KACvB,SAAU6H,GACN,MAAMC,EAAgB,SAAUC,EAAQC,GACpC,GAAI1J,GAAG2C,SAASgH,QAAQF,GAAS,CAC7BC,EAAO,GAAKD,EAAO,GACfA,EAAO1G,OAAS,IAChB2G,EAAO,GAAKD,EAAO,SAGlBnE,MAAMsE,QAAQH,IACnBA,EAAOzI,QAAQ,SAAU6I,EAAM3I,GAC3BsI,EAAcK,EAAMH,EAAOxI,OAIjC4I,EAAiB,SAAUlB,GAC7B,OAAI5I,GAAG2C,SAASgH,QAAQf,GACb,EAEPtD,MAAMsE,QAAQhB,GACPA,EAAOhB,OAAO,CAACzE,EAAM4G,IAAQ5G,EAAO2G,EAAeC,GAAM,QADpE,GAIJR,EAAYvI,QAAQ,SAAU4H,EAAQ1H,GAClC,MAAM4G,EAAOP,EAASrG,GACtB,GAAI4G,EAAM,CACNV,QAAQ4C,IAAI,oDAAmDlC,EAAKmC,WACpE,MAAMC,EAAapC,EAAKC,YACxB,GAAI+B,EAAeI,KAAgBJ,EAAelB,GAAS,CACvDY,EAAcZ,EAAQsB,GACtBpC,EAAKqC,UAAUD,QAGfpC,EAAKqC,UAAUvB,MAI3BjI,EAAQ4G,IAEZ,SAAUJ,GACNvG,EAAOuG,OAMnB,OAAOzG,QAAQC,QAAQ,KAI/BgB,EAAUmF,qBAAuB,SAAUjE,EAAa0D,GACpD,IAAI/D,GAAO,EACP4H,GAAU,EACd,IAAK,IAAInG,EAAI,EAAGsB,EAAK1C,EAAYE,OAAQkB,EAAIsB,EAAItB,IAAK,CAClD,MAAMhB,EAAQJ,EAAYoB,GAC1B,IAAIoG,EAAY,KACZC,EAAS,KACb,MAAMC,EAAiBhE,EAAU1B,OAAOkC,GAAW,OAANA,GAC7C,IAAK,IAAIyD,EAAI,EAAGC,EAAKF,EAAexH,OAAQyH,EAAIC,EAAID,IAAK,CACrD,MAAMzD,EAAIwD,EAAeC,IACf,IAANzD,IACAqD,GAAU,GAEd,GAAI9E,MAAMsE,QAAQ7C,GAAI,CAClB,MAAM2D,EAAS3D,EAAE9C,GACjB,GAAkB,OAAdoG,GAAsBK,EAAQ,CAC9BL,EAAYK,EAAO,GACfA,EAAO3H,OAAS,GAAgB,OAAXuH,IACrBA,EAASI,EAAO,KAI5B,GAAkB,OAAdL,EAAoB,CACpBpH,EAAM,GAAKoH,EACI,OAAXC,IACArH,EAAM,GAAKqH,GAEf,QAQZ,OADA9H,GAAS4H,GAAWvH,EAAY8H,MAAM5F,GAAc,OAATA,EAAE,KAAiBwB,EAAUoE,MAAM5D,IAAW,IAANA,IAna3F,GAyaA/G,GAAGC,KAAKC,UAAUuI,OAAS,CACvBC,4BAA6B,8BAC7BkC,UAAW,aAGf5K,GAAGC,KAAKC,UAAU2K,iBAAmB,SAAU1K,GAC3C,OAAOH,GAAGyC,KAAKoI,iBAAiB1K","sourcesContent":["TC.tool = TC.tool || {};\r\n\r\nTC.tool.Elevation = function (options) {\r\n    const self = this;\r\n    self.options = options || {};\r\n    self._servicePromises = [];\r\n    const serviceOptions = self.options.services || [\r\n        'elevationServiceIDENA',\r\n        'elevationServiceIGNFr',\r\n        'elevationServiceIGNEs',\r\n        'elevationServiceGoogle'\r\n    ];\r\n\r\n    const abstractServicePromise = new Promise(function (resolve, reject) {\r\n        TC.loadJS(\r\n            !TC.tool.ElevationService,\r\n            TC.apiLocation + 'TC/tool/ElevationService',\r\n            function () {\r\n                resolve();\r\n            }\r\n        );\r\n    });\r\n\r\n    serviceOptions.forEach(function (srv, idx) {\r\n        self._servicePromises[idx] = new Promise(function (resolve, reject) {\r\n            const serviceName = (typeof srv === 'string') ? srv : srv.name;\r\n            const ctorName = serviceName.substr(0, 1).toUpperCase() + serviceName.substr(1);\r\n            const path = TC.apiLocation + 'TC/tool/' + ctorName;\r\n            const srvOptions = (typeof srv === 'string') ? {} : srv;\r\n            TC.loadJS(\r\n                !TC.tool[ctorName],\r\n                path,\r\n                function () {\r\n                    abstractServicePromise.then(function () {\r\n                        resolve(new TC.tool[ctorName](srvOptions));\r\n                    });\r\n                }\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\n(function () {\r\n    const toolProto = TC.tool.Elevation.prototype;\r\n\r\n    let requestUID = 0;\r\n    const getRequestUID = function () {\r\n        return requestUID++;\r\n    };\r\n\r\n    toolProto.getService = function (idx) {\r\n        return this._servicePromises[idx];\r\n    };\r\n\r\n    toolProto.getServices = function () {\r\n        return Promise.all(this._servicePromises);\r\n    };\r\n\r\n    toolProto.getElevation = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        options.id = getRequestUID();\r\n        if (options.resolution === undefined) {\r\n            options.resolution = self.options.resolution;\r\n        }\r\n        if (options.sampleNumber === undefined) {\r\n            options.sampleNumber = self.options.sampleNumber;\r\n        }\r\n        let done = false;\r\n        let partialResult;\r\n        let partialCallback;\r\n        if (TC.Util.isFunction(options.partialCallback)) {\r\n            partialCallback = options.partialCallback;\r\n        }\r\n\r\n        return new Promise(function (resolve, reject) {\r\n            TC.loadJS(\r\n                !TC.Geometry,\r\n                TC.apiLocation + 'TC/Geometry',\r\n                function () {\r\n                    let coordinateList = options.coordinates;\r\n                    const isSinglePoint = coordinateList.length === 1;\r\n\r\n                    if (!isSinglePoint) {\r\n                        if (options.resolution) {\r\n                            const newCoordinateList = [];\r\n                            coordinateList.forEach(function (point, idx, arr) {\r\n                                if (idx) {\r\n                                    const prev = arr[idx - 1];\r\n                                    const distance = TC.Geometry.getDistance(prev, point);\r\n                                    if (distance > options.resolution) {\r\n                                        // posición en el segmento del primer punto interpolado\r\n                                        let pos = (distance % options.resolution) / 2;\r\n                                        // x··$·····|·····|··x\r\n                                        let n = Math.ceil(distance / options.resolution);\r\n                                        if (pos === 0) {\r\n                                            n = n - 1;\r\n                                            pos = options.resolution;\r\n                                        }\r\n                                        const x = point[0] - prev[0];\r\n                                        const y = point[1] - prev[1];\r\n                                        const sin = y / distance;\r\n                                        const cos = x / distance;\r\n                                        let xpos = prev[0] + pos * cos;\r\n                                        let ypos = prev[1] + pos * sin;\r\n                                        let dx = options.resolution * cos;\r\n                                        let dy = options.resolution * sin;\r\n                                        for (var i = 0; i < n; i++) {\r\n                                            newCoordinateList.push([xpos, ypos]);\r\n                                            xpos += dx;\r\n                                            ypos += dy;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                newCoordinateList.push(point);\r\n                            });\r\n                            coordinateList = newCoordinateList;\r\n                            options.resolution = 0;\r\n                            options.sampleNumber = 0;\r\n                        }\r\n                        else if (options.sampleNumber) {\r\n                            const numPoints = coordinateList.length;\r\n                            if (numPoints > options.sampleNumber) {\r\n                                // Sobran puntos. Nos quedamos con los puntos más cercanos a los puntos kilométricos\r\n                                // de los intervalos definidos por sampleNumber.\r\n                                const milestones = [];\r\n                                let accumulatedDistance = 0;\r\n                                coordinateList.forEach(function (point, idx, arr) {\r\n                                    if (idx) {\r\n                                        accumulatedDistance += TC.Geometry.getDistance(arr[idx - 1], point);\r\n                                    }\r\n                                    milestones.push({\r\n                                        index: idx,\r\n                                        distance: accumulatedDistance\r\n                                    });\r\n                                });\r\n                                const intervalLength = accumulatedDistance / options.sampleNumber;\r\n                                let nextMilestoneDistance = 0;\r\n                                milestones.forEach(function (milestone, idx, arr) {\r\n                                    const dd = milestone.distance - nextMilestoneDistance;\r\n                                    if (dd === 0) {\r\n                                        milestone.included = true;\r\n                                    }\r\n                                    else if (dd > 0) {\r\n                                        if (milestone.index) {\r\n                                            const prevMilestone = arr[idx - 1];\r\n                                            if (nextMilestoneDistance - prevMilestone.distance < dd) {\r\n                                                prevMilestone.included = true;\r\n                                            }\r\n                                            else {\r\n                                                milestone.included = true;\r\n                                            }\r\n                                        }\r\n                                        while (milestone.distance > nextMilestoneDistance) {\r\n                                            nextMilestoneDistance += intervalLength;\r\n                                        }\r\n                                    }\r\n                                });\r\n                                milestones.filter(m => !m.included).forEach(function (m) {\r\n                                    coordinateList[m.index] = null;\r\n                                });\r\n                                coordinateList = coordinateList.filter(p => p !== null);\r\n                            }\r\n                            else if (numPoints < options.sampleNumber) {\r\n                                // Faltan puntos. Insertamos puntos en las segmentos más largos.\r\n                                const insertBefore = function (arr, idx, count) {\r\n                                    const p1 = arr[idx - 1];\r\n                                    const p2 = arr[idx];\r\n                                    const n = count + 1;\r\n                                    let x = p1[0];\r\n                                    let y = p1[1];\r\n                                    const dx = (p2[0] - x) / n;\r\n                                    const dy = (p2[1] - y) / n;\r\n                                    const spliceParams = new Array(count + 2);\r\n                                    spliceParams[0] = idx;\r\n                                    spliceParams[1] = 0;\r\n                                    for (var i = 2, ii = spliceParams.length; i < ii; i++) {\r\n                                        x += dx;\r\n                                        y += dy;\r\n                                        spliceParams[i] = [x, y];\r\n                                    }\r\n                                    arr.splice.apply(arr, spliceParams);\r\n                                };\r\n                                let totalDistance = 0;\r\n                                const distances = coordinateList.map(function (point, idx, arr) {\r\n                                    let distance = 0;\r\n                                    if (idx) {\r\n                                        distance = TC.Geometry.getDistance(arr[idx - 1], point);\r\n                                        totalDistance += distance;\r\n                                    }\r\n                                    return {\r\n                                        index: idx,\r\n                                        distance: distance\r\n                                    };\r\n                                });\r\n                                // Hacemos copia de la lista porque vamos a insertar puntos\r\n                                coordinateList = coordinateList.slice();\r\n                                const defaultCount = options.sampleNumber - numPoints;\r\n                                let leftCount = defaultCount;\r\n                                let insertionCount = 0;\r\n                                for (var i = 0, ii = distances.length; leftCount && i < ii; i++) {\r\n                                    const obj = distances[i];\r\n                                    if (obj.distance !== 0) {\r\n                                        const partialInsertionCount = Math.min(Math.round(defaultCount * obj.distance / totalDistance), leftCount) || 1;\r\n                                        leftCount -= partialInsertionCount;\r\n                                        insertBefore(coordinateList, obj.index + insertionCount, partialInsertionCount);\r\n                                        insertionCount += partialInsertionCount;\r\n                                    }\r\n                                }\r\n                            }\r\n                            options.resolution = 0;\r\n                            options.sampleNumber = 0;\r\n                        }\r\n                    }\r\n\r\n                    options.coordinates = coordinateList;\r\n                    partialResult = coordinateList.map(p => [p[0], p[1], null]);\r\n                    \r\n                    if (!options.hasOwnProperty('includeHeights')) {\r\n                        options.includeHeights = isSinglePoint;\r\n                    }\r\n                    self.getServices().then(function (services) {\r\n                        const responses = new Array(services.length);\r\n                        responses.fill(false);\r\n                        services\r\n                            .forEach(function (srv, idx) {\r\n                                // Creamos una promesa que se resuelve falle o no la petición\r\n                                const alwaysPromise = new Promise(function (res, rej) {\r\n                                    srv.request(options).then(\r\n                                        function (response) {\r\n                                            if (done) {\r\n                                                res(null); // Ya no escuchamos a esta respuesta porque hemos terminado el proceso antes\r\n                                            }\r\n                                            else {\r\n                                                res(srv.parseResponse(response, options));\r\n                                            }\r\n                                        },\r\n                                        function () {\r\n                                            res(null);\r\n                                        }\r\n                                    );\r\n                                });\r\n                                alwaysPromise.then(function (response) {\r\n                                    if (!done) {\r\n                                        responses[idx] = response;\r\n                                        if (response !== null) {\r\n                                            if (self._updatePartialResult(partialResult, responses)) {\r\n                                                done = true;\r\n                                            }\r\n                                            if (partialCallback) {\r\n                                                partialCallback(partialResult);\r\n                                            }\r\n                                        }\r\n                                        if (done) {\r\n                                            responses.forEach((r, ri) => r === false && services[ri].cancelRequest(options.id));\r\n                                            resolve(partialResult.some(p => p[2] !== null) ? partialResult : []);\r\n                                        }\r\n                                    }\r\n                                }, function (error) {\r\n                                    console.error(error);\r\n                                });\r\n                            });\r\n                    }, function (msg) {\r\n                        reject(msg);\r\n                    });\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    toolProto.setGeometry = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        const features = options.features || [];\r\n\r\n        if (features.length) {\r\n\r\n            const conditionToPromises = function (promises, resolve, reject) {\r\n                Promise.all(promises).then(\r\n                    function (results) {\r\n                        resolve(results);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            };\r\n\r\n            return new Promise(function (resolve, reject) {\r\n                if (options.maxCoordQuantity) {\r\n                    if (options.resolution) {\r\n                        // Validador de número de coordenadas máximo\r\n                        const numPoints = features.reduce(function (acc, feat) {\r\n                            if (feat) {\r\n                                acc = acc + feat.getCoords({ pointArray: true }).length;\r\n                                switch (true) {\r\n                                    case TC.feature.Polyline && feat instanceof TC.feature.Polyline:\r\n                                    case TC.feature.Polygon && feat instanceof TC.feature.Polygon:\r\n                                    case TC.feature.MultiPolyline && feat instanceof TC.feature.MultiPolyline:\r\n                                    case TC.feature.MultiPolygon && feat instanceof TC.feature.MultiPolygon:\r\n                                        acc = acc + Math.floor(feat.getLength() / options.resolution);\r\n                                        break;\r\n                                    default:\r\n                                        break;\r\n                                }\r\n                            }\r\n                            return acc;\r\n                        }, 0);\r\n                        if (numPoints > options.maxCoordQuantity) {\r\n                            reject(Error(TC.tool.Elevation.errors.MAX_COORD_QUANTITY_EXCEEDED));\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                const resolution = options.resolution || 0;\r\n                const getElevOptions = function (coords) {\r\n                    return {\r\n                        crs: options.crs,\r\n                        coordinates: coords,\r\n                        resolution: resolution,\r\n                        sampleNumber: 0\r\n                    };\r\n                };\r\n                const getRingElevPromises = function (ring) {\r\n                    return self.getElevation(getElevOptions(ring));\r\n                }\r\n                const coordPromises = features.map(function (feature) {\r\n                    return new Promise(function (res, rej) {\r\n\r\n                        switch (true) {\r\n                            case !feature:\r\n                                res(null);\r\n                                break;\r\n                            case TC.feature && TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon:\r\n                                const polPromises = feature\r\n                                    .getCoords()\r\n                                    .map(function (polygon) {\r\n                                        return new Promise(function (rs, rj) {\r\n                                            conditionToPromises(polygon.map(getRingElevPromises), rs, rj);\r\n                                        });\r\n                                    });\r\n                                conditionToPromises(polPromises, res, rej);\r\n                                break;\r\n                            case TC.feature && TC.feature.Polygon && feature instanceof TC.feature.Polygon:\r\n                            case TC.feature && TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline:\r\n                                const ringPromises = feature\r\n                                    .getCoords()\r\n                                    .map(getRingElevPromises);\r\n                                conditionToPromises(ringPromises, res, rej);\r\n                                break;\r\n                            case TC.feature && TC.feature.Polyline && feature instanceof TC.feature.Polyline:\r\n                                self.getElevation(getElevOptions(feature.getCoords())).then(\r\n                                    function (coords) {\r\n                                        res(coords);\r\n                                    },\r\n                                    function (error) {\r\n                                        rej(Error(error));\r\n                                    }\r\n                                );\r\n                                break;\r\n                            case TC.feature && TC.feature.Point && feature instanceof TC.feature.Point:\r\n                                self.getElevation(getElevOptions([feature.getCoords()])).then(\r\n                                    function (coords) {\r\n                                        res(coords[0]);\r\n                                    },\r\n                                    function (error) {\r\n                                        rej(Error(error));\r\n                                    }\r\n                                );\r\n                                break;\r\n                            default:\r\n                                rej(Error(\"Geometry not supported\"));\r\n                                break;\r\n                        }\r\n                    });\r\n                });\r\n\r\n                Promise.all(coordPromises).then(\r\n                    function (coordsArray) {\r\n                        const copyElevation = function (source, target) {\r\n                            if (TC.Geometry.isPoint(source)) {\r\n                                target[2] = source[2];\r\n                                if (source.length > 3) {\r\n                                    target[3] = source[3];\r\n                                }\r\n                            }\r\n                            else if (Array.isArray(source)) {\r\n                                source.forEach(function (node, idx) {\r\n                                    copyElevation(node, target[idx]);\r\n                                });\r\n                            }\r\n                        };\r\n                        const getNumVertices = function (coords) {\r\n                            if (TC.Geometry.isPoint(coords)) {\r\n                                return 1;\r\n                            }\r\n                            if (Array.isArray(coords)) {\r\n                                return coords.reduce((prev, cur) => prev + getNumVertices(cur), 0);\r\n                            }\r\n                        };\r\n                        coordsArray.forEach(function (coords, idx) {\r\n                            const feat = features[idx];\r\n                            if (feat) {\r\n                                console.log(\"Estableciendo elevaciones a geometría de tipo \" + feat.CLASSNAME);\r\n                                const featCoords = feat.getCoords();\r\n                                if (getNumVertices(featCoords) === getNumVertices(coords)) {\r\n                                    copyElevation(coords, featCoords);\r\n                                    feat.setCoords(featCoords);\r\n                                }\r\n                                else {\r\n                                    feat.setCoords(coords);\r\n                                }\r\n                            }\r\n                        });\r\n                        resolve(features);\r\n                    },\r\n                    function (error) {\r\n                        reject(error);\r\n                    }\r\n                );\r\n            });\r\n        }\r\n        else {\r\n            return Promise.resolve([]);\r\n        }\r\n    };\r\n\r\n    toolProto._updatePartialResult = function (coordinates, responses) {\r\n        let done = false;\r\n        let pending = false;\r\n        for (var i = 0, ii = coordinates.length; i < ii; i++) {\r\n            const point = coordinates[i];\r\n            let elevation = null;\r\n            let height = null;\r\n            const validResponses = responses.filter(r => r !== null);\r\n            for (var j = 0, jj = validResponses.length; j < jj; j++) {\r\n                const r = validResponses[j];\r\n                if (r === false) {\r\n                    pending = true;\r\n                }\r\n                if (Array.isArray(r)) {\r\n                    const rPoint = r[i];\r\n                    if (elevation === null && rPoint) {\r\n                        elevation = rPoint[2];\r\n                        if (rPoint.length > 3 && height === null) {\r\n                            height = rPoint[3];\r\n                        }\r\n                    }\r\n                }\r\n                if (elevation !== null) {\r\n                    point[2] = elevation;\r\n                    if (height !== null) {\r\n                        point[3] = height;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // Condiciones para acabar:\r\n        // 1: Tengo todas las elevaciones y no hay peticiones más prioritarias pendientes\r\n        // 2: Han contestado todos los servicios\r\n        done = (!pending && coordinates.every(p => p[2] !== null)) || responses.every(r => r !== false);\r\n        return done;\r\n    };\r\n\r\n})();\r\n\r\nTC.tool.Elevation.errors = {\r\n    MAX_COORD_QUANTITY_EXCEEDED: 'max_coord_quantity_exceeded',\r\n    UNDEFINED: 'undefined'\r\n};\r\n\r\nTC.tool.Elevation.getElevationGain = function (options) {\r\n    return TC.Util.getElevationGain(options);\r\n};\r\n"]}