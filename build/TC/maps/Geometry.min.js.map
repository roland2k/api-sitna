{"version":3,"sources":["Geometry.js"],"names":["TC","root","factory","exports","module","define","amd","Geometry","intersectBox","a","b","edge","bbox","bitCode","p","code","isPoint","geometry","Array","isArray","length","isRing","isRingCollection","isMultiRingCollection","getNearest","point","candidates","wrap","isInside","ring","result","i","j","xi","yi","xj","yj","insideHole","len","getSquaredDistance","p1","p2","dx","dy","getDistance","Math","sqrt","getFlatCoordinates","geom","reductionFn","prev","cur","concat","reduce","intersects","geom1","geom2","flatIntersects","coords","ii","clipPolygon","map","clipRing","filter","prevInside","inside","forEach","push","clipPolyline","codeB","lastCode","codeA","part"],"mappings":"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","sourcesContent":["; var TC = TC || {};\r\n(function (root, factory) {\r\n    if (typeof exports === \"object\") { // CommonJS\r\n        module.exports = factory();\r\n    } else if (typeof define === \"function\" && define.amd) { // AMD\r\n        define([], factory);\r\n    } else {\r\n        root.Geometry = factory();\r\n    }\r\n})(TC, function () {\r\n\r\n    // intersect a segment against one of the 4 lines that make up the bbox\r\n    const intersectBox = function (a, b, edge, bbox) {\r\n        return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\r\n            edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\r\n                edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\r\n                    edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\r\n                        null;\r\n    };\r\n\r\n    // bit code reflects the point position relative to the bbox:\r\n\r\n    //         left  mid  right\r\n    //    top  1001  1000  1010\r\n    //    mid  0001  0000  0010\r\n    // bottom  0101  0100  0110\r\n    const bitCode = function (p, bbox) {\r\n        let code = 0;\r\n\r\n        if (p[0] < bbox[0]) code |= 1; // left\r\n        else if (p[0] > bbox[2]) code |= 2; // right\r\n\r\n        if (p[1] < bbox[1]) code |= 4; // bottom\r\n        else if (p[1] > bbox[3]) code |= 8; // top\r\n\r\n        return code;\r\n    };\r\n\r\n    const Geometry = {\r\n        isPoint: function (geometry) {\r\n            return Array.isArray(geometry) && geometry.length >= 2 && typeof geometry[0] === 'number' && typeof geometry[1] === 'number';\r\n        },\r\n        isRing: function (geometry) {\r\n            return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isPoint(geometry[0]));\r\n        },\r\n        isRingCollection: function (geometry) {\r\n            return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isRing(geometry[0]));\r\n        },\r\n        isMultiRingCollection: function (geometry) {\r\n            return Array.isArray(geometry) && (geometry.length === 0 || Geometry.isRingCollection(geometry[0]));\r\n        },\r\n        getNearest: function getNearest(point, candidates) {\r\n            return TC.wrap.Geometry.getNearest(point, candidates);\r\n        },\r\n        isInside: function isInside(point, ring) {\r\n            var result = false;\r\n            if (Geometry.isPoint(point)) {\r\n                if (Geometry.isPoint(ring)) {\r\n                    result = point[0] === ring[0] && point[1] === ring[1];\r\n                }\r\n                else if (Geometry.isRing(ring)) {\r\n                    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\r\n                        var xi = ring[i][0], yi = ring[i][1];\r\n                        var xj = ring[j][0], yj = ring[j][1];\r\n\r\n                        var intersect = ((yi > point[1]) != (yj > point[1]))\r\n                            && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);\r\n                        if (intersect) result = !result;\r\n                    }\r\n                }\r\n                else if (Geometry.isRingCollection(ring) && ring.length > 0) {\r\n                    // polígono con agujeros\r\n                    // miramos si está en el polígono exterior\r\n                    if (isInside(point, ring[0])) {\r\n                        var insideHole = false;\r\n                        // miramos si está en un agujero\r\n                        for (var i = 1; i < ring.length; i++) {\r\n                            if (isInside(point, ring[i])) {\r\n                                insideHole = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!insideHole) {\r\n                            result = true;\r\n                        }\r\n                    }\r\n                }\r\n                else if (Geometry.isMultiRingCollection(ring) && ring.length > 0) {\r\n                    // multipolígono\r\n                    // miramos si está en alguno de los polígonos\r\n                    for (var i = 0, len = ring.length; i < len; i++) {\r\n                        if (isInside(point, ring[i])) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n        getSquaredDistance: function (p1, p2) {\r\n            const dx = p2[0] - p1[0];\r\n            const dy = p2[1] - p1[1];\r\n            return dx * dx + dy * dy;\r\n        },\r\n        getDistance: function (p1, p2) {\r\n            return Math.sqrt(Geometry.getSquaredDistance(p1, p2));\r\n        },\r\n        getFlatCoordinates: function (geom) {\r\n            const reductionFn = function (prev, cur) {\r\n                return prev.concat(cur);\r\n            };\r\n            switch (true) {\r\n                case Geometry.isPoint(geom):\r\n                    return [geom];\r\n                case Geometry.isRing(geom):\r\n                    return geom;\r\n                case Geometry.isRingCollection(geom):\r\n                    return geom.reduce(reductionFn);\r\n                case Geometry.isMultiRingCollection(geom):\r\n                    return geom.reduce(reductionFn).reduce(reductionFn);\r\n                default:\r\n                    return [];\r\n            }\r\n        },\r\n        intersects: function (geom1, geom2) {\r\n            const flatIntersects = function (coords, geom) {\r\n                for (var i = 0, ii = coords.length; i < ii; i++) {\r\n                    if (Geometry.isInside(coords[i], geom)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n            if (flatIntersects(Geometry.getFlatCoordinates(geom1), geom2) || flatIntersects(Geometry.getFlatCoordinates(geom2), geom1)) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        clipPolygon: function (coords, bbox) {\r\n            return coords\r\n                .map(ring => Geometry.clipRing(ring, bbox))\r\n                .filter(ring => ring.length);\r\n        },\r\n        clipRing: function (coords, bbox) {\r\n            // Algoritmo Sutherland-Hodgeman de recorte de anillos\r\n            let result, edge, prev, prevInside, inside;\r\n\r\n            // clip against each side of the clip rectangle\r\n            for (edge = 1; edge <= 8; edge *= 2) {\r\n                result = [];\r\n                prev = coords[coords.length - 1];\r\n                prevInside = !(bitCode(prev, bbox) & edge);\r\n\r\n                coords.forEach(point => {\r\n                    inside = !(bitCode(point, bbox) & edge);\r\n\r\n                    // if segment goes through the clip window, add an intersection\r\n                    if (inside !== prevInside) result.push(intersectBox(prev, point, edge, bbox));\r\n\r\n                    if (inside) result.push(point); // add a point if it's inside\r\n\r\n                    prev = point;\r\n                    prevInside = inside;\r\n                });\r\n\r\n                coords = result;\r\n\r\n                if (!coords.length) break;\r\n            }\r\n\r\n            return result;\r\n        },\r\n        clipPolyline: function (coords, bbox) {\r\n            // Algoritmo Cohen-Sutherland de clipping de líneas\r\n            let len = coords.length,\r\n                codeA = bitCode(coords[0], bbox),\r\n                part = [],\r\n                i, a, b, codeB, lastCode;\r\n\r\n            let result = [];\r\n\r\n            for (i = 1; i < len; i++) {\r\n                a = coords[i - 1];\r\n                b = coords[i];\r\n                codeB = lastCode = bitCode(b, bbox);\r\n\r\n                while (true) {\r\n\r\n                    if (!(codeA | codeB)) { // accept\r\n                        part.push(a);\r\n\r\n                        if (codeB !== lastCode) { // segment went outside\r\n                            part.push(b);\r\n\r\n                            if (i < len - 1) { // start a new line\r\n                                result = result.concat(part);\r\n                                part = [];\r\n                            }\r\n                        } else if (i === len - 1) {\r\n                            part.push(b);\r\n                        }\r\n                        break;\r\n\r\n                    } else if (codeA & codeB) { // trivial reject\r\n                        break;\r\n\r\n                    } else if (codeA) { // a outside, intersect with clip edge\r\n                        a = intersectBox(a, b, codeA, bbox);\r\n                        codeA = bitCode(a, bbox);\r\n\r\n                    } else { // b outside\r\n                        b = intersectBox(a, b, codeB, bbox);\r\n                        codeB = bitCode(b, bbox);\r\n                    }\r\n                }\r\n\r\n                codeA = lastCode;\r\n            }\r\n\r\n            if (part.length) {\r\n                result = result.concat(part);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    };\r\n    return Geometry;\r\n});"]}