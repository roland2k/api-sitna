{"version":3,"sources":["control/FeatureInfo.js"],"names":["TC","control","FeatureInfoCommons","syncLoadJS","apiLocation","FeatureInfo","apply","this","arguments","wrap","Consts","classes","FROMLEFT","FROMRIGHT","inherit","ctlProto","prototype","roundCoordinates","obj","precision","result","Array","isArray","i","len","slice","length","Math","round","toFixed","register","map","self","Promise","resolve","reject","call","then","ctl","document","createElement","appendChild","div","error","callback","coords","xy","querying","elevationTool","getElevationTool","tool","elevationRequest","getElevation","crs","coordinates","filterLayer","title","getLocaleString","markerOptions","Util","extend","options","styles","marker","markerStyle","set","showsPopup","clearFeatures","highlightedFeature","filterFeature","addMarker","putLayerOnTop","renderResults","geometry","displayElevation","loading","displayResults","visibleLayers","workLayers","layer","type","layerType","WMS","getVisibility","names","queryResolution","getResolution","getFeatureInfo","setTimeout","responseCallback","sendRequest","filter","getCoords","services","service","j","layers","features","splice","info","defaultFeature","insertLinks","sharedFeatureInfo","querySelectorAll","CLASS","forEach","li","classList","add","CHECKED","sharedFeature","featureObj","ii","mapLayers","some","ml","url","s","jj","name","l","k","kk","feature","id","f","hash","hex_md5","JSON","stringify","data","getData","DEGREE_PRECISION","h","alert","addLayer","getUID","VECTOR","owner","stealth","sharedFeatureLayer","addFeature","zoomToFeatures","label","addEventListener","event","CLICK","e","stopPropagation","passive","displayResultsCallback","getDisplayControl","getDisplayTarget","elm","HIDDEN","elevationCoords","currentFeature","currentCoords","elevPoint","elevationValues","displayElevationValues","isGeo","value","METER_PRECISION","formatCoord","renderData","tValue","sValue","locale","Cfg","elevationString","formatNumber","heightString","toLocaleString","maximumFractionDigits","elevationDisplay","querySelector","heightDisplay","toggle","innerHTML","loadSharedFeature","item","getDisgregatedLayerNames","indexOf","msgErrorMode","TOAST","loadJS","window","HASH","beforeRequest","r","serviceUrl","layerName","featureId","exportQuery","res","importQuery","query","setResolution"],"mappings":"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","sourcesContent":["\r\n/**\r\n  * Opciones de control de obtención de información de entidades de mapa por click.\r\n  * @typedef FeatureInfoOptions\r\n  * @see MapControlOptions\r\n  * @property {boolean} [active] - Si se establece a `true`, el control asociado está activo, es decir, responde a los clics hechos en el mapa desde el que se carga.\r\n  * Como máximo puede haber solamente un control activo en el mapa en cada momento.\r\n  * @property {boolean} [persistentHighlights] - Cuando el control `featureInfo` muestra los resultados de la consulta, si el servicio lo soporta, mostrará resaltadas sobre el mapa las geometrías\r\n  * de las entidades geográficas de la respuesta. Si este valor es `true`, dichas geometrías se quedan resaltadas en el mapa indefinidamente. En caso contrario, las geometrías resaltadas se borran en el \r\n  * momento en que se cierra el bocadillo de resultados o se hace una nueva consulta.\r\n  * @example <caption>[Ver en vivo](../examples/cfg.FeatureInfoOptions.persistentHighlights.html)</caption> {@lang html} \r\n  * <div id=\"mapa\"></div>\r\n  * <script>\r\n  *     // Añadimos el control featureInfo.\r\n  *     SITNA.Cfg.controls.featureInfo = {\r\n  *         persistentHighlights: true\r\n  *     };\r\n  *     // Añadimos una capa WMS sobre la que hacer las consultas.\r\n  *     SITNA.Cfg.workLayers = [\r\n  *         {\r\n  *             id: \"masas\",\r\n  *             title: \"Masas de agua\",\r\n  *             type: SITNA.Consts.layerType.WMS,\r\n  *             url: \"https://servicios.idee.es/wms-inspire/hidrografia\",\r\n  *             layerNames: [\"HY.PhysicalWaters.Waterbodies\"]\r\n  *         }\r\n  *     ];\r\n  *     var map = new SITNA.Map(\"mapa\");\r\n  * </script> \r\n  */\r\n\r\nTC.control = TC.control || {};\r\n\r\nif (!TC.control.FeatureInfoCommons) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');\r\n}\r\n\r\n(function () {\r\n    TC.control.FeatureInfo = function () {\r\n        var self = this;\r\n        TC.control.FeatureInfoCommons.apply(this, arguments);\r\n        self.wrap = new TC.wrap.control.FeatureInfo(self);\r\n\r\n        TC.Consts.classes.FROMLEFT = 'tc-fromleft';\r\n        TC.Consts.classes.FROMRIGHT = 'tc-fromright';\r\n    };\r\n\r\n    TC.inherit(TC.control.FeatureInfo, TC.control.FeatureInfoCommons);\r\n\r\n    var ctlProto = TC.control.FeatureInfo.prototype;\r\n\r\n    var roundCoordinates = function roundCoordinates(obj, precision) {\r\n        var result;\r\n        var n = 20;\r\n        if (Array.isArray(obj)) {\r\n            result = obj.slice();\r\n            for (var i = 0, len = result.length; i < len; i++) {\r\n                result[i] = roundCoordinates(result[i]);\r\n            }\r\n        }\r\n        else if (typeof obj === \"number\") {\r\n            result = Math.round(obj.toFixed(precision));\r\n        }\r\n        else {\r\n            result = obj;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    ctlProto.register = function (map) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            TC.control.FeatureInfoCommons.prototype.register.call(self, map).then(\r\n                function (ctl) {\r\n                    // Le ponemos un padre al div. Evitamos con esto que se añada el div al mapa (no es necesario, ya que es un mero buffer)\r\n                    document.createElement('div').appendChild(self.div);\r\n                    resolve(ctl);\r\n                },\r\n                error => reject(error)\r\n            );\r\n        });\r\n    };\r\n\r\n    ctlProto.callback = function (coords, xy) {\r\n        const self = this;\r\n\r\n        self.querying = true;\r\n        return new Promise(function (resolve, reject) {\r\n            const elevationTool = self.getElevationTool();\r\n            elevationTool.then(function (tool) {\r\n                if (tool) {\r\n                    self.elevationRequest = tool.getElevation({\r\n                        crs: self.map.crs,\r\n                        coordinates: [coords]\r\n                    });\r\n                }\r\n            });\r\n\r\n            if (self.map && self.filterLayer) {\r\n                //aquí se pone el puntito temporal\r\n                var title = self.getLocaleString('featureInfo');\r\n                var markerOptions = TC.Util.extend({}, self.map.options.styles.marker, self.markerStyle, { title: title, set: title, showsPopup: false });\r\n                self.filterLayer.clearFeatures();\r\n                self.highlightedFeature = null;\r\n                self.filterFeature = null;\r\n                self.filterLayer.addMarker(coords, markerOptions).then(function afterMarkerAdd(marker) {\r\n                    ////cuando se queda el puntito es porque esto sucede tras el cierre de la popup\r\n                    ////o sea\r\n                    ////lo normal es que primero se ejecute esto, y luego se procesen los eventos FEATUREINFO o NOFEATUREINFO\r\n                    ////pero en el caso raro (la primera vez), ocurre al revés. Entonces, ya se habrá establecido lastFeatureCount (no será null)\r\n                    //if (self.lastFeatureCount === null) {\r\n                    //    self.map.putLayerOnTop(self.filterLayer);\r\n                    //    self.filterFeature = marker;\r\n                    //}\r\n                    //else {\r\n                    //    self.filterLayer.clearFeatures();\r\n                    //}\r\n                    self.map.putLayerOnTop(self.filterLayer);\r\n                    self.filterFeature = marker;\r\n\r\n                    elevationTool.then(function (tool) {\r\n                        self.renderResults({ coords: marker.geometry, displayElevation: tool, loading: true }, function () {\r\n                            self.displayResults();\r\n                        });\r\n                    });\r\n\r\n                    var visibleLayers = false;\r\n                    for (var i = 0; i < self.map.workLayers.length; i++) {\r\n                        var layer = self.map.workLayers[i];\r\n                        if (layer.type === TC.Consts.layerType.WMS) {\r\n                            if (layer.getVisibility() && layer.names.length > 0) {\r\n                                visibleLayers = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    self.queryResolution = self.map.getResolution();\r\n                    if (visibleLayers) {\r\n                        self.wrap.getFeatureInfo(coords, self.queryResolution).then(() => resolve());\r\n                    }\r\n                    else {\r\n                        // Metemos setTimeout para salirnos del hilo. Sin él se corre el riesgo de que se ejecute esto antes del evento BEFOREFEATUREINFO\r\n                        setTimeout(function () {\r\n                            self.responseCallback({ coords: coords });\r\n                            resolve();\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    };\r\n\r\n    ctlProto.sendRequest = function (filter) {\r\n        const self = this;\r\n        return self.callback(filter.getCoords());\r\n    };\r\n\r\n    ctlProto.responseCallback = function (options) {\r\n        const self = this;\r\n\r\n        TC.control.FeatureInfoCommons.prototype.responseCallback.call(self, options);\r\n        if (self.filterFeature) {\r\n            var services = options.services;\r\n\r\n            // Eliminamos capas sin resultados\r\n            if (services) {\r\n                for (var i = 0; i < services.length; i++) {\r\n                    var service = services[i];\r\n                    for (var j = 0; j < service.layers.length; j++) {\r\n                        if (!service.layers[j].features.length) {\r\n                            service.layers.splice(j, 1);\r\n                            j = j - 1;\r\n                        }\r\n                    }\r\n                    if (!service.layers.length) {\r\n                        services.splice(i, 1);\r\n                        i = i - 1;\r\n                    }\r\n                }\r\n            }\r\n\r\n            self.info.defaultFeature = options.defaultFeature;\r\n\r\n            if (self.elevationRequest) {\r\n                options.displayElevation = true;\r\n            }\r\n            self.renderResults(options, function () {\r\n                self.insertLinks();\r\n\r\n                if (self.sharedFeatureInfo) {\r\n                    self.div.querySelectorAll('ul.' + self.CLASS + '-services li').forEach(function (li) {\r\n                        li.classList.add(TC.Consts.classes.CHECKED);\r\n                    })\r\n                    var sharedFeature;\r\n                    var featureObj = self.sharedFeatureInfo;\r\n                    for (var i = 0, ii = self.info.services.length; i < ii; i++) {\r\n                        var service = self.info.services[i];\r\n                        if (service.mapLayers.some(function (ml) { return ml.url === featureObj.s })) {\r\n                            for (var j = 0, jj = service.layers.length; j < jj; j++) {\r\n                                var layer = service.layers[j];\r\n                                if (layer.name === featureObj.l) {\r\n                                    for (var k = 0, kk = layer.features.length; k < kk; k++) {\r\n                                        var feature = layer.features[k];\r\n                                        if (feature.id === featureObj.f) {\r\n                                            sharedFeature = feature;\r\n                                            var hash = hex_md5(JSON.stringify({\r\n                                                data: feature.getData(),\r\n                                                geometry: roundCoordinates(feature.geometry, TC.Consts.DEGREE_PRECISION) // Redondeamos a la precisión más fina (grado)\r\n                                            }));\r\n                                            if (featureObj.h !== hash) {\r\n                                                TC.alert(self.getLocaleString('finfo.featureChanged.warning'));\r\n                                            }\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (sharedFeature) {\r\n                        self.highlightedFeature = sharedFeature;\r\n                        self.map.addLayer({\r\n                            id: self.getUID(),\r\n                            type: TC.Consts.layerType.VECTOR,\r\n                            title: self.getLocaleString('foi'),\r\n                            owner: self,\r\n                            stealth: true\r\n                        }).then(function (layer) {\r\n                            self.sharedFeatureLayer = layer;\r\n                            self.filterLayer.clearFeatures();\r\n                            self.filterFeature = null;\r\n                            layer.addFeature(sharedFeature);\r\n                            self.map.zoomToFeatures([sharedFeature]);\r\n                        });\r\n                    }\r\n                    delete self.sharedFeatureInfo;\r\n                }\r\n                else {\r\n                    self.displayResults();\r\n                }\r\n                //capturamos el click de label y enlaces para no propagarlos a las tablas y que haga zoom cuando no se quiere\r\n                self.div.querySelectorAll('ul.' + self.CLASS + '-services label, ul.' + self.CLASS + '-services a').forEach(function (label) {\r\n                    label.addEventListener(TC.Consts.event.CLICK, function (e) {\r\n                        e.stopPropagation();\r\n                    }, { passive: true })\r\n                })\r\n            });\r\n        }\r\n    };\r\n\r\n    ctlProto.displayResultsCallback = function () {\r\n        const self = this;\r\n        TC.control.FeatureInfoCommons.prototype.displayResultsCallback.call(self);\r\n\r\n        if (self.elevationRequest) {\r\n            const ctl = self.getDisplayControl();\r\n            self.getDisplayTarget().querySelectorAll(`.${self.CLASS}-elev,.${self.CLASS}-height`).forEach(elm => elm.classList.add(TC.Consts.classes.HIDDEN));\r\n            self.elevationRequest.then(function (elevationCoords) {\r\n                if (ctl.currentFeature && elevationCoords.length) {\r\n                    const currentCoords = ctl.currentFeature.geometry;\r\n                    const elevPoint = elevationCoords[0];\r\n                    if (currentCoords[0] === elevPoint[0] && currentCoords[1] === elevPoint[1]) {\r\n                        const elevationValues = elevationCoords.length ? elevationCoords[0].slice(2) : null;\r\n                        self.displayElevationValues(elevationValues);\r\n                    }\r\n                }\r\n                //self.elevationRequest = null;\r\n            });\r\n        }\r\n\r\n        // 26/04/2021 ahora siempre mostramos XY aunque no haya elevación o resultado GFI\r\n        //else if (!self.querying && (!self.info || !self.info.services)) {\r\n        //    self.closeResults();\r\n        //}\r\n    };\r\n\r\n    ctlProto.renderResults = function (options, callback) {\r\n        const self = this;\r\n        if (self.filterFeature) {\r\n            const currentCoords = self.filterFeature.geometry;\r\n            if (options.coords && currentCoords[0] === options.coords[0] && currentCoords[1] === options.coords[1]) {\r\n                options.isGeo = self.map.wrap.isGeo();\r\n                if (options.coords) {\r\n                    options.crs = self.map.crs;\r\n                    options.coords = options.coords.map(function (value) {\r\n                        const precision = options.isGeo ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION;\r\n                        return TC.Util.formatCoord(value, precision);\r\n                    });\r\n                }\r\n                self.renderData(options, callback);\r\n            }\r\n        }\r\n    };\r\n\r\n    ctlProto.displayElevationValues = function (value) {\r\n        const self = this;\r\n        let tValue, sValue;\r\n        if (Array.isArray(value)) {\r\n            tValue = value[0];\r\n            sValue = value.length > 1 ? value[1] : null;\r\n        }\r\n        else {\r\n            tValue = value;\r\n            sValue = null;\r\n        }\r\n        const locale = self.map.options.locale || TC.Cfg.locale;\r\n        let elevationString = tValue === null ? '-' : TC.Util.formatNumber(Math.round(tValue), locale) + ' m';\r\n        let heightString = sValue ? sValue.toLocaleString(locale, { maximumFractionDigits: 1 }) + ' m' : '-';\r\n        const elevationDisplay = self.getDisplayTarget().querySelector(`.${self.CLASS}-elev`);\r\n        const heightDisplay = self.getDisplayTarget().querySelector(`.${self.CLASS}-height`);\r\n        if (elevationDisplay && heightDisplay) {\r\n            elevationDisplay.classList.toggle(TC.Consts.classes.HIDDEN, tValue === null);\r\n            heightDisplay.classList.toggle(TC.Consts.classes.HIDDEN, !sValue);\r\n            elevationDisplay.querySelector(`.${self.CLASS}-coords-val`).innerHTML = elevationString;\r\n            heightDisplay.querySelector(`.${self.CLASS}-coords-val`).innerHTML = heightString;\r\n        }\r\n    };\r\n\r\n    ctlProto.loadSharedFeature = function (featureObj) {\r\n        // Función para dar compatibilidad hacia atrás, ahora las features se comparten por URL\r\n        const self = this;\r\n        if (featureObj) {\r\n            //buscamos si la feature compartida pertenece a alguna de las capas añadidas\r\n            if (self.map.workLayers.filter(function (item, i) {\r\n                return item.type === TC.Consts.layerType.WMS && item.url === featureObj.s && item.getDisgregatedLayerNames().indexOf(featureObj.l) >= 0\r\n            }).length === 0) {\r\n                TC.error(self.getLocaleString('sharedFeatureNotValid'), TC.Consts.msgErrorMode.TOAST);\r\n                return;\r\n            }\r\n            self.sharedFeatureInfo = featureObj;\r\n            TC.loadJS(\r\n                !window.hex_md5,\r\n                [TC.apiLocation + TC.Consts.url.HASH],\r\n                function () {\r\n                    // Creamos una consulta getFeatureInfo ad-hoc, con la resolución a la que estaba la consulta original.\r\n                    const coords = [-100, -100];\r\n                    self.beforeRequest({ xy: coords }); // xy negativo para que no se vea el marcador, ya que no sabemos dónde ponerlo.\r\n                    //aquí se pone el puntito temporal\r\n                    self.filterLayer.clearFeatures();\r\n                    self.filterFeature = null;\r\n                    self.filterLayer.addMarker(coords).then(function (marker) {\r\n                        self.filterFeature = marker;\r\n                        self.wrap.getFeatureInfo(featureObj.xy, featureObj.r, {\r\n                            serviceUrl: featureObj.s,\r\n                            layerName: featureObj.l,\r\n                            featureId: featureObj.f\r\n                        });\r\n                    });\r\n                }\r\n            );\r\n        }\r\n    };\r\n\r\n    ctlProto.exportQuery = function () {\r\n        const self = this;\r\n        const result = TC.control.FeatureInfoCommons.prototype.exportQuery.call(self);\r\n        result.res = self.queryResolution;\r\n        return result;\r\n    };\r\n\r\n    ctlProto.importQuery = function (query) {\r\n        const self = this;\r\n        if (query.filter) {\r\n            self.map.setResolution(query.res)\r\n                .then(() => TC.control.FeatureInfoCommons.prototype.importQuery.call(self, query));\r\n        }\r\n    };\r\n\r\n})();"]}