{"version":3,"sources":["control/GeometryFeatureInfo.js"],"names":["TC","control","FeatureInfoCommons","syncLoadJS","apiLocation","filter","GeometryFeatureInfo","apply","this","arguments","wrap","_isDrawing","_isSearching","_drawToken","inherit","ctlProto","prototype","register","map","self","result","call","on","Consts","event","CONTROLDEACTIVATE","e","cancelDraw","callback","coords","xy","Promise","resolve","reject","closeResults","highlightedFeature","visibleLayers","i","workLayers","length","layer","type","layerType","WMS","getVisibility","names","beginDraw","geometryType","filterLayer","feature","getFeaturesByGeometry","then","sendRequest","responseCallback","options","filterFeature","services","service","hasLimits","layers","j","features","splice","renderData","insertLinks","div","querySelector","CLASS","classList","add","classes","HIDDEN","displayResults"],"mappings":"AAaAA,GAAGC,QAAUD,GAAGC,SAAW,GAEtBD,GAAGC,QAAQC,oBACZF,GAAGG,WAAWH,GAAGI,YAAc,iCAE9BJ,GAAGK,QACJL,GAAGG,WAAWH,GAAGI,YAAc,cAGnC,WACIJ,GAAGC,QAAQK,oBAAsB,WAE7BN,GAAGC,QAAQC,mBAAmBK,MAAMC,KAAMC,WAD/BD,KAENE,KAAO,IAAIV,GAAGU,KAAKT,QAAQK,oBAFrBE,MAAAA,KAGNG,YAAa,EAHPH,KAINI,cAAe,EAJTJ,KAKNK,YAAa,GAGtBb,GAAGc,QAAQd,GAAGC,QAAQK,oBAAqBN,GAAGC,QAAQC,oBAEtD,IAAIa,EAAWf,GAAGC,QAAQK,oBAAoBU,UAE9CD,EAASE,SAAW,SAAUC,GAC1B,MAAMC,EAAOX,KACPY,EAASpB,GAAGC,QAAQC,mBAAmBc,UAAUC,SAASI,KAAKF,EAAMD,GAE3EC,EAAKG,GAAGtB,GAAGuB,OAAOC,MAAMC,kBAAmB,SAAUC,GACjDP,EAAKT,KAAKiB,eAGd,OAAOP,GAGXL,EAASa,SAAW,SAAUC,EAAQC,GAClC,IAAIX,EAAOX,KACX,OAAO,IAAIuB,QAAQ,SAAUC,EAASC,GAClC,GAAId,EAAKN,WACLmB,QADJ,CAIAb,EAAKe,eAELf,EAAKgB,mBAAqB,KAE1B,IADA,IAAIC,GAAgB,EACXC,EAAI,EAAGA,EAAIlB,EAAKD,IAAIoB,WAAWC,OAAQF,IAAK,CACjD,IAAIG,EAAQrB,EAAKD,IAAIoB,WAAWD,GAChC,GAAIG,EAAMC,OAASzC,GAAGuB,OAAOmB,UAAUC,KAC/BH,EAAMI,iBAAmBJ,EAAMK,MAAMN,OAAS,EAAG,CACjDH,GAAgB,EAChB,OAIZ,GAAIA,EAAe,CACfjB,EAAKe,eACLf,EAAKT,KAAKoC,UAAU,CAChBC,aAAc5B,EAAK4B,aACnBjB,GAAID,EACJW,MAAOrB,EAAK6B,YACZpB,SAAU,SAAUqB,GAChB9B,EAAKT,KAAKwC,sBAAsBD,GAASE,KAAK,IAAMnB,aAK5DA,QAKZjB,EAASqC,YAAc,SAAU/C,GAC7B,OAAOG,KAAKE,KAAKwC,sBAAsB7C,IAG3CU,EAASsC,iBAAmB,SAAUC,GAClC,IAAInC,EAAOX,KAEXR,GAAGC,QAAQC,mBAAmBc,UAAUqC,iBAAiBhC,KAAKF,EAAMmC,GAEpE,GAAInC,EAAKoC,cAAe,CAIpB,IAHA,IAAIC,EAAWF,EAAQE,SAGdnB,EAAI,EAAGA,EAAImB,EAASjB,OAAQF,IAAK,CACtC,IAAIoB,EAAUD,EAASnB,GACvB,GAAIoB,EAAQC,UAAW,QACZD,EAAQE,OACfF,EAAQC,UAAYD,EAAQC,cAE3B,CACD,IAAK,IAAIE,EAAI,EAAGA,EAAIH,EAAQE,OAAOpB,OAAQqB,IACvC,IAAKH,EAAQE,OAAOC,GAAGC,SAAStB,OAAQ,CACpCkB,EAAQE,OAAOG,OAAOF,EAAG,GACzBA,GAAQ,EAGhB,IAAKH,EAAQE,OAAOpB,OAAQ,CACxBiB,EAASM,OAAOzB,EAAG,GACnBA,GAAQ,IAKpBlB,EAAK4C,WAAWT,EAAS,WACjBE,EAASjB,QACTpB,EAAK6C,cAET7C,EAAK8C,IAAIC,kBAAkB/C,EAAKgD,gBAAgBC,UAAUC,IAAIrE,GAAGuB,OAAO+C,QAAQC,QAChFpD,EAAKqD,qBApGrB","sourcesContent":["\r\n/**\r\n  * Opciones de control de obtención de información de entidades de mapa por línea o por recinto.\r\n  * @typedef GeometryFeatureInfoOptions\r\n  * @ignore\r\n  * @extends FeatureInfoOptions\r\n  * @see MultiFeatureInfoOptions\r\n  * @property {LineStyleOptions|PolygonStyleOptions} [filterStyle] - Estilo de la entidad cuya geometría servirá de filtro espacial para la consulta.\r\n  * @property {boolean} [persistentHighlights] - Cuando el control muestra los resultados de la consulta muestra también resaltadas sobre el mapa las geometrías\r\n  * de las entidades geográficas de la respuesta. Si este valor es verdadero, dichas geometrías se quedan resaltadas en el mapa indefinidamente. \r\n  * En caso contrario, las geometrías resaltadas se borran en el momento en que se cierra el bocadillo de resultados o se hace una nueva consulta.\r\n  */\r\n\r\nTC.control = TC.control || {};\r\n\r\nif (!TC.control.FeatureInfoCommons) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/control/FeatureInfoCommons');\r\n}\r\nif (!TC.filter) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Filter');\r\n}\r\n\r\n(function () {\r\n    TC.control.GeometryFeatureInfo = function () {\r\n        var self = this;\r\n        TC.control.FeatureInfoCommons.apply(this, arguments);\r\n        self.wrap = new TC.wrap.control.GeometryFeatureInfo(self);\r\n        self._isDrawing = false;\r\n        self._isSearching = false;\r\n        self._drawToken = false;\r\n    };\r\n\r\n    TC.inherit(TC.control.GeometryFeatureInfo, TC.control.FeatureInfoCommons);\r\n\r\n    var ctlProto = TC.control.GeometryFeatureInfo.prototype;\r\n\r\n    ctlProto.register = function (map) {\r\n        const self = this;\r\n        const result = TC.control.FeatureInfoCommons.prototype.register.call(self, map);\r\n\r\n        self.on(TC.Consts.event.CONTROLDEACTIVATE, function (e) {\r\n            self.wrap.cancelDraw();\r\n        });\r\n\r\n        return result;\r\n    };\r\n\r\n    ctlProto.callback = function (coords, xy) {\r\n        var self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (self._drawToken) {\r\n                resolve();\r\n                return;\r\n            }\r\n            self.closeResults();\r\n            //self.filterLayer.clearFeatures();\r\n            self.highlightedFeature = null;\r\n            var visibleLayers = false;\r\n            for (var i = 0; i < self.map.workLayers.length; i++) {\r\n                var layer = self.map.workLayers[i];\r\n                if (layer.type === TC.Consts.layerType.WMS) {\r\n                    if (layer.getVisibility() && layer.names.length > 0) {\r\n                        visibleLayers = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (visibleLayers) {\r\n                self.closeResults();\r\n                self.wrap.beginDraw({\r\n                    geometryType: self.geometryType,\r\n                    xy: coords,\r\n                    layer: self.filterLayer,\r\n                    callback: function (feature) {\r\n                        self.wrap.getFeaturesByGeometry(feature).then(() => resolve());\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    };\r\n\r\n    ctlProto.sendRequest = function (filter) {\r\n        return this.wrap.getFeaturesByGeometry(filter);\r\n    };\r\n\r\n    ctlProto.responseCallback = function (options) {\r\n        var self = this;\r\n\r\n        TC.control.FeatureInfoCommons.prototype.responseCallback.call(self, options);\r\n\r\n        if (self.filterFeature) {\r\n            var services = options.services;\r\n\r\n            // Eliminamos capas sin resultados a no ser que tenga un error\r\n            for (var i = 0; i < services.length; i++) {\r\n                var service = services[i];\r\n                if (service.hasLimits) {\r\n                    delete service.layers;\r\n                    service.hasLimits = service.hasLimits;\r\n                }\r\n                else {\r\n                    for (var j = 0; j < service.layers.length; j++) {\r\n                        if (!service.layers[j].features.length) {\r\n                            service.layers.splice(j, 1);\r\n                            j = j - 1;\r\n                        }\r\n                    }\r\n                    if (!service.layers.length) {\r\n                        services.splice(i, 1);\r\n                        i = i - 1;\r\n                    }\r\n                }\r\n\r\n            }\r\n            self.renderData(options, function () {\r\n                if (services.length) {\r\n                    self.insertLinks();\r\n                }\r\n                self.div.querySelector(`.${self.CLASS}-coords`).classList.add(TC.Consts.classes.HIDDEN);\r\n                self.displayResults();\r\n            });\r\n        }\r\n    };\r\n\r\n})();"]}