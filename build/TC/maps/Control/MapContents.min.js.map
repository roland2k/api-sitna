{"version":3,"sources":["control/MapContents.js"],"names":["TC","control","Control","syncLoadJS","apiLocation","MapContents","apply","this","arguments","layerTrees","inherit","ctlProto","prototype","CLASS","render","callback","options","self","_set1stRenderPromise","map","renderData","Util","extend","getLayerTree","addUIEventListeners","Promise","reject","Error","register","resolve","all","call","renderPromise","then","i","len","layers","length","updateLayerTree","on","Consts","event","ZOOM","PROJECTIONCHANGE","updateScale","UPDATEPARAMS","e","layer","names","containsName","node","result","indexOf","name","children","id","update","LAYERVISIBILITY","updateLayerVisibility","LAYERADD","VECTORUPDATE","FEATUREADD","FEATURESADD","_updateLayerTreeTimeouts","clearTimeout","setTimeout","workLayers","LAYERREMOVE","removeLayer","LAYERORDER","updateLayerOrder","oldIndex","newIndex","LAYERERROR","onErrorLayer","catch","err","getTree","oldIdx","newIdx","collection","currentElm","previousElm","elms","getLayerUIElements","l","j","jj","elm","dataset","layerId","insertAdjacentElement","parentElement","firstChild","liCollection","li","removeChild","div","querySelector","classList","remove","classes","HIDDEN","styleLegendImage","img","getAttribute","imgSrc","toolProxification","tool","Proxification","proxify","method","getLegendGraphicImage","src","error","test","watch","colorStr","style","color","openIdx","closeIdx","substr","split","component","parseInt","toString","replace","fontFamily","fontSize","params","sld_body","addURLParameters","fetchImage","status","getLocaleString","locale","url"],"mappings":"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","sourcesContent":["TC.control = TC.control || {};\r\n\r\nif (!TC.Control) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Control');\r\n}\r\n\r\nTC.control.MapContents = function () {\r\n    var self = this;\r\n\r\n    TC.Control.apply(self, arguments);\r\n\r\n    self.layerTrees = {};\r\n};\r\n\r\nTC.inherit(TC.control.MapContents, TC.Control);\r\n\r\n(function () {\r\n    var ctlProto = TC.control.MapContents.prototype;\r\n\r\n    ctlProto.CLASS = 'tc-ctl-mc';\r\n\r\n    ctlProto.render = function (callback, options) {\r\n        const self = this;\r\n        return self._set1stRenderPromise(self.map ? self.renderData(options ? TC.Util.extend(self.map.getLayerTree(), options) : self.map.getLayerTree(), function () {\r\n            self.addUIEventListeners();\r\n            if (typeof callback === 'function') {\r\n                callback();\r\n            }\r\n        }) : Promise.reject(Error('Cannot render: control has no map')));\r\n    };\r\n\r\n    ctlProto.register = function (map) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            Promise.all([TC.Control.prototype.register.call(self, map), self.renderPromise()]).then(function () {\r\n                for (var i = 0, len = map.layers.length; i < len; i++) {\r\n                    self.updateLayerTree(map.layers[i]);\r\n                }\r\n\r\n                map\r\n                    .on(TC.Consts.event.ZOOM + ' ' + TC.Consts.event.PROJECTIONCHANGE, function () {\r\n                        self.updateScale();\r\n                    })\r\n                    .on(TC.Consts.event.UPDATEPARAMS, function (e) {\r\n                        const layer = e.layer;\r\n                        var names = layer.names;\r\n                        var containsName = function containsName(node) {\r\n                            var result = false;\r\n                            if (node) {\r\n                                if (names.indexOf(node.name) >= 0) {\r\n                                    result = true;\r\n                                }\r\n                                else {\r\n                                    for (var i = 0; i < node.children.length; i++) {\r\n                                        if (containsName(node.children[i])) {\r\n                                            result = true;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            return result;\r\n                        };\r\n                        if (containsName(self.layerTrees[layer.id]) || names.length === 0) {\r\n                            self.update();\r\n                        }\r\n                        else {\r\n                            self.updateLayerTree(layer);\r\n                        }\r\n                    })\r\n                    .on(TC.Consts.event.LAYERVISIBILITY, function (e) {\r\n                        self.updateLayerVisibility(e.layer);\r\n                    })\r\n                    .on(TC.Consts.event.LAYERADD, function (e) {\r\n                        self.updateLayerTree(e.layer);\r\n                    })\r\n                    .on(TC.Consts.event.VECTORUPDATE + ' ' + TC.Consts.event.FEATUREADD + ' ' + TC.Consts.event.FEATURESADD, function (e) {\r\n                        const layer = e.layer;\r\n                        // Se introduce un timeout porque pueden venir muchos eventos de este tipo seguidos y no tiene sentido actualizar con cada uno\r\n                        self._updateLayerTreeTimeouts = self._updateLayerTreeTimeouts || {};\r\n                        if (self._updateLayerTreeTimeouts[layer.id]) {\r\n                            clearTimeout(self._updateLayerTreeTimeouts[layer.id]);\r\n                        }\r\n                        self._updateLayerTreeTimeouts[layer.id] = setTimeout(function () {\r\n                            if (self.map.workLayers.indexOf(layer) > -1) {\r\n                                // GLS: Validamos si la capa que ha provocado el evento sigue en worklayers, si es borrada debido a la espera del timeout el TOC puede reflejar capas que ya no están\r\n                                self.updateLayerTree(layer);\r\n                                delete self._updateLayerTreeTimeouts[layer.id];\r\n                            }\r\n                        }, 100);\r\n                    })\r\n                    .on(TC.Consts.event.LAYERREMOVE, function (e) {\r\n                        self.removeLayer(e.layer);\r\n                    })\r\n                    .on(TC.Consts.event.LAYERORDER, function (e) {\r\n                        self.updateLayerOrder(e.layer, e.oldIndex, e.newIndex);\r\n                    })\r\n                    .on(TC.Consts.event.LAYERERROR, function (e) {\r\n                        self.onErrorLayer(e.layer);                                                    \r\n                    });\r\n\r\n                resolve(self);\r\n            }).catch(function (err) {\r\n                reject(err instanceof Error ? err : Error(err));\r\n            });\r\n        });\r\n    };\r\n\r\n    ctlProto.updateScale = function () {\r\n    };\r\n\r\n    ctlProto.updateLayerVisibility = function (layer) {\r\n    };\r\n\r\n    ctlProto.updateLayerTree = function (layer) {\r\n        this.layerTrees[layer.id] = layer.getTree();\r\n    };\r\n\r\n    ctlProto.updateLayerOrder = function (layer, oldIdx, newIdx, collection) {\r\n        const self = this;\r\n        if (oldIdx >= 0 && oldIdx !== newIdx) {\r\n            var currentElm, previousElm;\r\n            const elms = self.getLayerUIElements();\r\n\r\n            collection = collection || self.map.workLayers;\r\n\r\n            for (var i = collection.length - 1; i >= 0; i--) {\r\n                const l = collection[i];\r\n                previousElm = currentElm;\r\n                for (var j = 0, jj = elms.length; j < jj; j++) {\r\n                    const elm = elms[j];\r\n                    if (elm.dataset.layerId === l.id) {\r\n                        currentElm = elm;\r\n                        break;\r\n                    }\r\n                }\r\n                if (l === layer) {\r\n                    if (currentElm) {\r\n                        if (previousElm) {\r\n                            previousElm.insertAdjacentElement('afterend', currentElm);\r\n                        }\r\n                        else {\r\n                            currentElm.parentElement.firstChild.insertAdjacentElement('beforebegin', currentElm);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    ctlProto.removeLayer = function (layer) {\r\n        const self = this;\r\n        const liCollection = self.getLayerUIElements();\r\n        for (var i = 0, len = liCollection.length; i < len; i++) {\r\n            const li = liCollection[i];\r\n            if (li.dataset.layerId === layer.id) {\r\n                li.parentElement.removeChild(li);\r\n                break;\r\n            }\r\n        }\r\n        if (self.getLayerUIElements().length === 0) {\r\n            self.div.querySelector('.' + self.CLASS + '-empty').classList.remove(TC.Consts.classes.HIDDEN);\r\n        }\r\n    };\r\n\r\n    ctlProto.onErrorLayer = function (layer) { };\r\n\r\n    ctlProto.getLayerUIElements = function () {\r\n        return this.div.querySelector('ul').children;\r\n    };\r\n\r\n    var isGetLegendGraphic = function (url) {\r\n        return /[&?]REQUEST=getLegendGraphic/i.test(url);\r\n    };\r\n\r\n    /*\r\n     * Carga y le da estilo a la imagen de la leyenda.\r\n     * @param {string} requestMethod Si queremos pedir la imagen de la leyenda por POST, podemos especificarlo utilizando el parámetro requestMethod.\r\n     */\r\n    ctlProto.styleLegendImage = function (img, layer) {\r\n        if (!img.getAttribute('src')) {\r\n            var imgSrc = img.dataset.img;\r\n\r\n            const toolProxification = new TC.tool.Proxification(TC.proxify);\r\n\r\n            if (layer && layer.options.method && layer.options.method === \"POST\") {\r\n                layer.getLegendGraphicImage()\r\n                    .then(function (src) {\r\n                        img.src = src; // ya se ha validado en getLegendGraphicImage\r\n                    }).catch(function (err) {\r\n                        TC.error(err);\r\n                    });\r\n            } else {\r\n                if (isGetLegendGraphic(imgSrc)) {\r\n                    const watch = img.parentElement;\r\n                    // A\\u00f1adimos el par\\u00e1metro que define el estilo de los textos en la imagen\r\n                    var colorStr = watch.style.color;\r\n                    // Convertimos el color de formato rgb(r,g,b) a 0xRRGGBB\r\n                    var openIdx = colorStr.indexOf('(');\r\n                    var closeIdx = colorStr.indexOf(')');\r\n                    if (openIdx >= 0 && closeIdx > openIdx) {\r\n                        color = colorStr\r\n                            .substr(0, closeIdx)\r\n                            .substr(openIdx + 1)\r\n                            .split(',');\r\n                        colorStr = '0x';\r\n                        for (var i = 0; i < 3; i++) {\r\n                            var component = parseInt(color[i]).toString(16);\r\n                            colorStr += component.length === 1 ? '0' + component : component;\r\n                        }\r\n                    }\r\n                    else {\r\n                        colorStr.replace('#', '0x');\r\n                    }\r\n                    imgSrc += '&LEGEND_OPTIONS=fontName:' + watch.style.fontFamily +\r\n                        ';fontSize:' + parseInt(watch.style.fontSize) +\r\n                        ';fontColor:' + colorStr +\r\n                        ';fontAntiAliasing:true';\r\n                    if (layer.params && layer.params.sld_body) {\r\n                        imgSrc = TC.Util.addURLParameters(imgSrc, { sld_body: layer.params.sld_body });\r\n                    }\r\n\r\n                    toolProxification.fetchImage(imgSrc).then(function (img) {\r\n                        img.dataset.img = img.src;\r\n                    }).catch(function (err) {\r\n                        TC.error(err);\r\n                    });\r\n                }\r\n\r\n                toolProxification.fetchImage(imgSrc).then(function (i) {\r\n                    img.src = i.src;\r\n                }).catch(function (err) {\r\n                    if (err.status && (err.status === 404 || err.status === 401))\r\n                        TC.error(TC.Util.getLocaleString(layer.map.options.locale, 'simbologyImgNotFound',\r\n                            { url: imgSrc }));\r\n                    else\r\n                        TC.error(err);\r\n                });                \r\n            }\r\n        }\r\n    };\r\n\r\n})();"]}