{"version":3,"sources":["layer/Vector.js"],"names":["TC","layer","Layer","syncLoadJS","apiLocation","capabilitiesPromises","Vector","self","this","_capabilitiesPromise","capabilities","apply","arguments","type","options","Consts","layerType","VECTOR","features","selectedFeatures","extension","url","idx","indexOf","substr","lastIndexOf","toLowerCase","getFileExtension","format","mimeType","KML","GPX","JSON","GEOJSON","GML","getFormatFromMimeType","WKT","TOPOJSON","getFormatFromExtension","title","result","regexp","RegExp","i","decodeURIComponent","match","exec","length","getFileName","wrap","_promise","Promise","resolve","reject","ollyr","createVectorLayer","setLayer","inherit","layerProto","prototype","getMergedLegendImage","images","offset","svgs","map","str","replace","widths","parseFloat","heights","width","reduce","acc","cur","height","Math","max","offsetSvgs","encodeURIComponent","join","getTree","stealth","children","path","getPath","node","Util","addArrayToTree","legend","getLegend","styles","cluster","legendImages","push","getLegendImageFromStyle","extend","point","radius","Cfg","geometryType","geom","POINT","line","POLYLINE","polygon","POLYGON","src","name","customLegend","uid","id","addFeatureInternal","multipleFeatureFunction","coord","call","then","trigger","event","FEATUREADD","feature","addFeaturesInternal","coordsArray","constructorName","styleType","opts","FeatureConstructor","endFn","Array","nativeFeatures","len","coords","isNative","Feature","CLASSNAME","_wrap","parent","layerStyle","hasStyleOptions","externalStyles","showPopup","showInfo","addFeatures","loadJS","addPoint","addPoints","addMultiPoint","addMultiPoints","addMarker","addMarkers","addMultiMarker","addMultiMarkers","addPolyline","addPolylines","addMultiPolyline","addMultiPolylines","addPolygon","addPolygons","addMultiPolygon","addMultiPolygons","addCircle","addCircles","addFeature","Point","Polyline","Polygon","MultiPolygon","MultiPolyline","Circle","removeFeature","getFeatureById","olFeat","clearFeatures","getControlsByClass","forEach","pu","isVisible","currentFeature","hide","getDescribeFeatureTypeUrl","layerNames","version","featureType","isArray","Operations","DescribeFeatureType","outputFormat","describeFeatureType","layerName","callback","error","getCapabilitiesPromise","window","hasOwnProperty","wwGetUrl","async","wwLocation","isSameOrigin","data","ajax","method","responseType","blob","Blob","URL","createObjectURL","err","wwInit","WebWorkerDFT","Worker","onmessage","e","Object","state","key","keys","DFTCollection","assign","toolProxification","fetchXML","postMessage","response","documentElement","outerHTML","wwProcess","layers","querySelector","textContent","trim","xml","document","location","protocol","split","arrPromises","entries","vi","va","preffix","substring","temp","params","collection","_getStoredFeatureTypes","all","objReturned","catch","isFunction","errorText","import","setNodeVisibility","visible","LOADING","BEFOREUPDATE","BEFORELAYERUPDATE","tree","findNode","setVisibility","_cache","visibilityStates","visibility","VISIBLE","NOT_VISIBLE","f","found","undefined","_path","IDLE","LAYERUPDATE","UPDATE","getNodeVisibility","getVisibility","r","setModifiable","modifiable","applyEdits","inserts","updates","deletes","sendTransaction","refresh","reloadSource","getFeaturesInCurrentExtent","tolerance","extent","getExtent","getFeaturesInExtent","setProjection","crs","oldCrs","feat","setGeometry","reproject","geometry","getGeometry","setStyles","exportState","lObj","precision","pow","isGeo","DEGREE_PRECISION","METER_PRECISION","fObj","Marker","marker","MultiPoint","MULTIPOINT","MULTIPOLYLINE","MULTIPOLYGON","CIRCLE","compactGeometry","getData","showsPopup","exportStyles","val","style","getStyle","importState","obj","promises","featureOptions","addFn","className","explodeGeometry","res","rej","one","PROJECTIONCHANGE","Error","clone","getGetCapabilitiesUrl","WFS","getUrl","SERVICE","VERSION","REQUEST","isSecureURL","toAbsolutePath","getBySSL_","getParamString","actualUrl","capabilitiesWFS","tool","Proxification","proxify","cachePromise","onlinePromise","getCapabilitiesOnline","storagePromise","getCapabilitiesFromStorage","processedCapabilities","LAYERERROR","reason"],"mappings":"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","sourcesContent":["TC.layer = TC.layer || {};\r\n\r\nif (!TC.Layer) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');\r\n}\r\n\r\n(function () {\r\n\r\n    var capabilitiesPromises = {};\r\n\r\n    /**\r\n     * Opciones de capa vectorial.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.VectorOptions\r\n     * @extend TC.cfg.LayerOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Tipo de capa.\r\n     * @property type\r\n     * @type TC.consts.LayerType\r\n     * @default TC.Consts.layerType.VECTOR\r\n     */\r\n    /**\r\n     * URL del servicio WFS o del documento que define la capa.\r\n     * @property url\r\n     * @type string|undefined\r\n     */\r\n\r\n    /**\r\n     * Capa de tipo vectorial, como la de un WFS o un KML.\r\n     * @class TC.layer.Vector\r\n     * @extends TC.Layer\r\n     * @constructor\r\n     * @async\r\n     * @param {TC.Cfg.layer} [options] Objeto de opciones de configuración de la capa.\r\n     */\r\n    TC.layer.Vector = function () {\r\n        var self = this;\r\n\r\n        //esta promise se resolverá cuando el capabilities esté descargado y parseado\r\n        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa\r\n        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)\r\n        self._capabilitiesPromise = null;\r\n        self.capabilities = null;\r\n\r\n        TC.Layer.apply(self, arguments);\r\n\r\n        self.type = self.options.type || TC.Consts.layerType.VECTOR;\r\n        /**\r\n         * Lista de entidades geográficas que hay en la capa.\r\n         * @property features\r\n         * @type array\r\n         * @default []\r\n         */\r\n        self.features = [];\r\n        /**\r\n         * Lista de entidades geográficas seleccionadas en la capa.\r\n         * @property selectedFeatures\r\n         * @type array\r\n         * @default []\r\n         */\r\n        self.selectedFeatures = [];\r\n\r\n        const getFileExtension = function (url) {\r\n            url = url || '';\r\n            var idx = url.indexOf('?');\r\n            if (idx >= 0) {\r\n                url = url.substr(0, idx);\r\n            }\r\n            else {\r\n                idx = url.indexOf('#');\r\n                if (idx >= 0) {\r\n                    url = url.substr(0, idx);\r\n                }\r\n            }\r\n            return url.substr(url.lastIndexOf('.')).toLowerCase();\r\n        };\r\n\r\n        const getFormatFromExtension = function (extension) {\r\n            switch (extension) {\r\n                case '.kml':\r\n                    return TC.Consts.format.KML;\r\n                case '.gpx':\r\n                    return TC.Consts.format.GPX;\r\n                case '.json':\r\n                case '.geojson':\r\n                    return TC.Consts.format.GEOJSON;\r\n                case '.gml':\r\n                    return TC.Consts.format.GML;\r\n                case '.wkt':\r\n                    return TC.Consts.format.WKT;\r\n                case '.topojson':\r\n                    return TC.Consts.format.TOPOJSON;\r\n                default:\r\n                    return null;\r\n            }\r\n        };\r\n        const getFormatFromMimeType = function (mimeType) {\r\n            switch (mimeType) {\r\n                case TC.Consts.mimeType.KML:\r\n                    return TC.Consts.format.KML;\r\n                case TC.Consts.mimeType.GPX:\r\n                    return TC.Consts.format.GPX;\r\n                case TC.Consts.mimeType.JSON:\r\n                case TC.Consts.mimeType.GEOJSON:\r\n                    return TC.Consts.format.GEOJSON;\r\n                case TC.Consts.mimeType.GML:\r\n                    return TC.Consts.format.GML;\r\n                default:\r\n                    return null;\r\n            }\r\n        };\r\n        /**\r\n         * URL del servicio o documento al que pertenenece la capa.\r\n         * @property url\r\n         * @type string\r\n         */\r\n        const extension = getFileExtension(self.url);\r\n        const format = getFormatFromMimeType(self.options.format) || getFormatFromExtension(extension);\r\n        if (format || self.type === TC.Consts.layerType.KML) {\r\n            if (format === TC.Consts.format.KML) {\r\n                self.type = TC.Consts.layerType.KML;\r\n            }\r\n\r\n            var getFileName = function (url) {\r\n                url = url || '';\r\n                var result = url;\r\n                var regexp = new RegExp('([^/]+' + extension + ')', 'i');\r\n                for (var i = 0; i < 3; i++) {\r\n                    url = decodeURIComponent(url);\r\n                    var match = regexp.exec(url);\r\n                    if (match.length > 1) {\r\n                        result = match[1];\r\n                        break;\r\n                    }\r\n\r\n                }\r\n                return result;\r\n            };\r\n            self.title = self.options.title || getFileName(self.url);\r\n        }\r\n\r\n        self.wrap = new TC.wrap.layer.Vector(self);\r\n\r\n        self.wrap._promise = new Promise((resolve, reject) => {\r\n            var ollyr = null;\r\n            ollyr = self.wrap.createVectorLayer();\r\n            self.wrap.setLayer(ollyr);\r\n            resolve(ollyr);\r\n        })//Promise.resolve(ollyr);\r\n\r\n    };\r\n\r\n    TC.inherit(TC.layer.Vector, TC.Layer);\r\n\r\n    (function () {\r\n        var layerProto = TC.layer.Vector.prototype;\r\n\r\n        const getMergedLegendImage = function (images) {\r\n            let offset = 0;\r\n            const margin = 2;\r\n            const svgs = images\r\n                .map(str => str.replace('data:image/svg+xml,', ''))\r\n                .map(str => decodeURIComponent(str));\r\n            const widths = svgs.map(str => parseFloat(str.match(/ width=\"([\\d\\.]*)\"/)[1]));\r\n            const heights = svgs.map(str => parseFloat(str.match(/ height=\"([\\d\\.]*)\"/)[1]));\r\n            const width = widths.reduce((acc, cur) => acc + cur + margin, 0);\r\n            const height = Math.max.apply(Math, heights);\r\n            const offsetSvgs = svgs\r\n                .map((str, idx) => {\r\n                    const result = str.replace('<svg xmlns=\"http://www.w3.org/2000/svg\"', `<svg x=\"${offset}\" y=\"${(height - heights[idx]) / 2}\" `);\r\n                    offset += widths[idx] + margin;\r\n                    return result;\r\n                });\r\n            return 'data:image/svg+xml,' + encodeURIComponent(`<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\">${offsetSvgs.join('')}</svg>`);\r\n        };\r\n\r\n        /*\r\n         *  getTree: returns service layer tree { name, title, children }\r\n         */\r\n        layerProto.getTree = function () {\r\n            const self = this;\r\n            let result = null;\r\n            if (!self.options.stealth) {\r\n                result = {};\r\n                result.children = [];\r\n                for (var i = 0; i < self.features.length; i++) {\r\n                    var path = self.features[i].getPath();\r\n                    if (path.length) {\r\n                        var node = TC.Util.addArrayToTree(path, result);\r\n                        if (node) {\r\n                            node.legend = self.features[i].getLegend();\r\n                        }\r\n                    }\r\n                }\r\n                if (self.styles || self.cluster) {\r\n                    const legendImages = [];\r\n                    if (self.cluster) {\r\n                        legendImages.push(TC.Util.getLegendImageFromStyle(\r\n                            TC.Util.extend({}, self.cluster.styles.point, { radius: TC.Cfg.styles.point.radius + 2, offset: [0, 6] }),\r\n                            { geometryType: TC.Consts.geom.POINT }\r\n                        ));\r\n                    }\r\n                    if (self.styles.point) {\r\n                        legendImages.push(TC.Util.getLegendImageFromStyle(self.styles.point, { geometryType: TC.Consts.geom.POINT }));\r\n                    }\r\n                    if (self.styles.line) {\r\n                        legendImages.push(TC.Util.getLegendImageFromStyle(self.styles.line, { geometryType: TC.Consts.geom.POLYLINE }));\r\n                    }\r\n                    if (self.styles.polygon) {\r\n                        legendImages.push(TC.Util.getLegendImageFromStyle(self.styles.polygon, { geometryType: TC.Consts.geom.POLYGON }));\r\n                    }\r\n                    result.legend = {\r\n                        src: getMergedLegendImage(legendImages)\r\n                    };\r\n                }\r\n                result.name = self.name || result.name;\r\n                result.customLegend = self.options.customLegend; //Atributo para pasar una plantilla HTML diferente a la por defecto (LegendNode.html)\r\n                result.title = self.title || result.title;\r\n                result.uid = self.id;\r\n            }\r\n            return result;\r\n        };\r\n\r\n        var addFeatureInternal = function (layer, multipleFeatureFunction, coord, options) {\r\n            return new Promise(function (resolve, reject) {\r\n                multipleFeatureFunction.call(layer, [coord], options).then(function (features) {\r\n                    resolve(features[0]);\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.FEATUREADD, { layer: layer, feature: features[0] });\r\n                    }\r\n                });\r\n            });\r\n        };\r\n\r\n        var addFeaturesInternal = function (layer, coordsArray, constructorName, styleType, options) {\r\n            var opts = TC.Util.extend(true, {}, options);\r\n            return new Promise(function (resolve, reject) {\r\n                var FeatureConstructor;\r\n                const endFn = function () {\r\n                    FeatureConstructor = FeatureConstructor || TC.feature[constructorName];\r\n                    var features = new Array(coordsArray.length);\r\n                    var nativeFeatures = [];\r\n                    for (var i = 0, len = coordsArray.length; i < len; i++) {\r\n                        var coords = coordsArray[i];\r\n                        var feature;\r\n                        const isNative = TC.wrap.Feature.prototype.isNative(coords);\r\n                        if (coords instanceof FeatureConstructor || \"TC.feature.\" + constructorName === coords.CLASSNAME) {\r\n                            feature = coords;\r\n                        }\r\n                        else {\r\n                            if (isNative) {\r\n                                feature = coords._wrap && coords._wrap.parent;\r\n                            }\r\n                            if (!feature) {\r\n                                opts.layer = layer;\r\n                                const layerStyle = layer.styles && layer.styles[styleType];\r\n                                if (TC.Util.hasStyleOptions(opts) || !layerStyle) {\r\n                                    // Si las opciones tienen estilos, o la capa no los tiene, creamos un objeto de estilos para la feature\r\n                                    const externalStyles = TC.Util.extend(true, {}, TC.Cfg.styles, layer.map ? layer.map.options.styles : null);\r\n                                    TC.Util.extend(true, opts, externalStyles[styleType], layerStyle || {}, options);\r\n                                }\r\n                                feature = new FeatureConstructor(coords, opts);\r\n                            }\r\n                        }\r\n                        feature.layer = layer;\r\n                        features[i] = feature;\r\n                        layer.features.push(feature);\r\n                        if (!isNative) {\r\n                            nativeFeatures.push(feature.wrap.feature);\r\n                        }\r\n                        if (feature.options.showPopup) {\r\n                            feature.showInfo();\r\n                        }\r\n                        // Este evento mata el rendimiento\r\n                        //self.map.trigger(TC.Consts.event.FEATUREADD, { layer: self, feature: marker });\r\n                    }\r\n                    if (nativeFeatures.length) {\r\n                        layer.wrap.addFeatures(nativeFeatures);\r\n                    }\r\n                    resolve(features);\r\n                };\r\n                if (constructorName) {\r\n                    TC.loadJS(\r\n                        !TC.feature || (TC.feature && !TC.feature[constructorName]),\r\n                        [TC.apiLocation + 'TC/feature/' + constructorName],\r\n                        endFn\r\n                    );\r\n                }\r\n                else {\r\n                    FeatureConstructor = TC.Feature;\r\n                    endFn();\r\n                }\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Añade un punto a la capa.\r\n         * @method addPoint\r\n         * @async\r\n         * @param {array|TC.feature.Point|ol.geom.Point|OpenLayers.Geometry.Point} coord Si es un array, contiene dos números (la coordenada del punto).\r\n         * @param {TC.cfg.PointStyleOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Point\r\n         */\r\n        layerProto.addPoint = function (coord, options) {\r\n            return addFeatureInternal(this, this.addPoints, coord, options);\r\n        };\r\n\r\n        /**\r\n         * Añade una lista de puntos a la capa.\r\n         * @method addPoints\r\n         * @async\r\n         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink \"TC.layer.Vector/addPoint:method\"}}{{/crossLink}}.\r\n         * @param {TC.cfg.PointStyleOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Point\r\n         */\r\n        layerProto.addPoints = function (coordsArray, options) {\r\n            return addFeaturesInternal(this, coordsArray, 'Point', TC.Consts.geom.POINT, options);\r\n        };\r\n\r\n        layerProto.addMultiPoint = function (coords, options) {\r\n            return addFeatureInternal(this, this.addMultiPoints, coords, options);\r\n        };\r\n\r\n\r\n        layerProto.addMultiPoints = function (coordsArray, options) {\r\n            return addFeaturesInternal(this, coordsArray, 'MultiPoint', \"point\", options);\r\n        };\r\n\r\n        /**\r\n         * Añade un marcador a la capa.\r\n         * @method addMarker\r\n         * @async\r\n         * @param {array|TC.feature.Marker|ol.geom.Point|OpenLayers.Geometry.Point} coord Si es un array, contiene dos números (la coordenada del punto).\r\n         * @param {TC.cfg.MarkerStyleOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Marker\r\n         */\r\n        layerProto.addMarker = function (coord, options) {\r\n            return addFeatureInternal(this, this.addMarkers, coord, options);\r\n        };\r\n\r\n        /**\r\n         * Añade una lista de marcadores a la capa.\r\n         * @method addMarkers\r\n         * @async\r\n         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink \"TC.layer.Vector/addMarker:method\"}}{{/crossLink}}.\r\n         * @param {TC.cfg.MarkerStyleOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Marker\r\n         */\r\n        layerProto.addMarkers = function (coordsArray, options) {\r\n            return addFeaturesInternal(this, coordsArray, 'Marker', 'marker', options);\r\n        };\r\n\r\n        layerProto.addMultiMarker = function (coords, options) {\r\n            return addFeatureInternal(this, this.addMultiMarkers, coords, options);\r\n        };\r\n\r\n\r\n        layerProto.addMultiMarkers = function (coordsArray, options) {\r\n            return addFeaturesInternal(this, coordsArray, 'MultiMarker', \"marker\", options);\r\n        };\r\n\r\n        /**\r\n         * Añade una polilínea a la capa.\r\n         * @method addPolyline\r\n         * @async\r\n         * @param {array|TC.feature.Polyline|ol.geom.MultiLineString|OpenLayers.Geometry.LineString} coords Si es un array, contiene arrays de dos números (coordenadas de puntos).\r\n         * @param {TC.cfg.PolylineOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Polyline\r\n         */\r\n        layerProto.addPolyline = function (coords, options) {\r\n            return addFeatureInternal(this, this.addPolylines, coords, options);\r\n        };\r\n\r\n\r\n        /**\r\n         * Añade una lista de polilíneas a la capa.\r\n         * @method addPolylines\r\n         * @async\r\n         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink \"TC.layer.Vector/addPolyline:method\"}}{{/crossLink}}.\r\n         * @param {TC.cfg.PolylineOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Polyline\r\n         */\r\n        layerProto.addPolylines = function (coordsArray, options) {\r\n            //URI: El tipo de estilo se especifica LINE pero realmente deberia ser TC.Const.Style.LINE\r\n            return addFeaturesInternal(this, coordsArray, 'Polyline', \"line\", options);\r\n        };\r\n\r\n        layerProto.addMultiPolyline = function (coords, options) {\r\n            return addFeatureInternal(this, this.addMultiPolylines, coords, options);\r\n        };\r\n\r\n\r\n        layerProto.addMultiPolylines = function (coordsArray, options) {\r\n            //URI: El tipo de estilo se especifica LINE pero realmente deberia ser TC.Const.Style.LINE\r\n            return addFeaturesInternal(this, coordsArray, 'MultiPolyline', \"line\", options);\r\n        };\r\n\r\n        /**\r\n         * Añade un polígono a la capa.\r\n         * @method addPolygon\r\n         * @async\r\n         * @param {array|TC.feature.Polygon|ol.geom.Polygon|OpenLayers.Geometry.Polygon} coords Si es un array, contiene arrays de coordenadas, que son a su vez arrays de dos números. El primer\r\n         * elemento de ese array es el anillo exterior, los siguientes son anillos interiores.\r\n         * @param {TC.cfg.PolygonOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Polygon\r\n         */\r\n        layerProto.addPolygon = function (coords, options) {\r\n            return addFeatureInternal(this, this.addPolygons, coords, options);\r\n        };\r\n\r\n        /**\r\n         * Añade una lista de polígonos a la capa.\r\n         * @method addPolygons\r\n         * @async\r\n         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink \"TC.layer.Vector/addPolygon:method\"}}{{/crossLink}}.\r\n         * @param {TC.cfg.PolygonOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Polygon\r\n         */\r\n        layerProto.addPolygons = function (coordsArray, options) {\r\n            //URI: El tipo de style se especifica POLIGON pero realmente deberia ser TC.Const.Style.POLYGON\r\n            return addFeaturesInternal(this, coordsArray, 'Polygon', TC.Consts.geom.POLYGON, options);\r\n        };\r\n\r\n        layerProto.addMultiPolygon = function (coords, options) {\r\n            return addFeatureInternal(this, this.addMultiPolygons, coords, options);\r\n        };\r\n\r\n\r\n        layerProto.addMultiPolygons = function (coordsArray, options) {\r\n            //URI: El tipo de style se especifica POLIGON pero realmente deberia ser TC.Const.Style.POLYGON\r\n            return addFeaturesInternal(this, coordsArray, 'MultiPolygon', TC.Consts.geom.POLYGON, options);\r\n        };\r\n\r\n        /**\r\n         * Añade un círculo a la capa.\r\n         * @method addCircle\r\n         * @async\r\n         * @param {array|TC.feature.Circle|ol.geom.Circle} coord Si es un array, contiene un array de dos números (la coordenada del centro) y un número (el radio).\r\n         * @param {TC.cfg.PolygonStyleOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.feature.Circle\r\n         */\r\n        layerProto.addCircle = function (coord, options) {\r\n            return addFeatureInternal(this, this.addCircles, coord, options);\r\n        };\r\n\r\n        /**\r\n         * Añade una lista de círculos a la capa.\r\n         * @method addCircles\r\n         * @async\r\n         * @param {array} coordsArray Los elementos de esta lista son cualquiera de los que acepta el método {{#crossLink \"TC.layer.Vector/addCircle:method\"}}{{/crossLink}}.\r\n         * @param {TC.cfg.PolygonStyleOptions} [options]\r\n         * @return {jQuery promise} La promesa al resolverse devuelve un array de objetos de la clase TC.feature.Circle\r\n         */\r\n        layerProto.addCircles = function (coordsArray, options) {\r\n            //URI: El tipo de geometria se especifica POLIGON pero realmente deberia ser TC.Const.Style.POLYGON\r\n            return addFeaturesInternal(this, coordsArray, 'Circle', TC.Consts.geom.POLYGON, options);\r\n        };\r\n        /**\r\n         * Añade una entidad geográfica a la capa.\r\n         * @method addFeature\r\n         * @async\r\n         * @param {TC.Feature} feature \r\n         * @return {jQuery promise} La promesa al resolverse devuelve un objeto de la clase TC.Feature\r\n         */\r\n        layerProto.addFeature = function (feature) {\r\n            const self = this;\r\n            var result;\r\n            if (TC.feature) {\r\n                if (TC.feature.Point && feature instanceof TC.feature.Point || feature.CLASSNAME === \"TC.feature.Point\") {\r\n                    result = self.addPoint(feature);\r\n                }\r\n                else if (TC.feature.Polyline && feature instanceof TC.feature.Polyline || feature.CLASSNAME === \"TC.feature.Polyline\") {\r\n                    result = self.addPolyline(feature);\r\n                }\r\n                else if (TC.feature.Polygon && feature instanceof TC.feature.Polygon || feature.CLASSNAME === \"TC.feature.Polygon\") {\r\n                    result = self.addPolygon(feature);\r\n                }\r\n                else if (TC.feature.MultiPolygon && feature instanceof TC.feature.MultiPolygon || feature.CLASSNAME === \"TC.feature.MultiPolygon\") {\r\n                    result = self.addMultiPolygon(feature);\r\n                }\r\n                else if (TC.feature.MultiPolyline && feature instanceof TC.feature.MultiPolyline || feature.CLASSNAME === \"TC.feature.MultiPolyline\") {\r\n                    result = self.addMultiPolyline(feature);\r\n                }\r\n                else if (TC.feature.Circle && feature instanceof TC.feature.Circle || feature.CLASSNAME === \"TC.feature.Circle\") {\r\n                    result = self.addCircle(feature);\r\n                }\r\n                else {\r\n                    result = addFeaturesInternal(self, [feature]);\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        layerProto.addFeatures = function (features) {\r\n            return addFeaturesInternal(this, features);\r\n        };\r\n\r\n        /**\r\n         * Elimina una entidad geográfica de la capa.\r\n         * @method removeFeature\r\n         * @param {TC.Feature} feature \r\n         */\r\n        layerProto.removeFeature = function (feature) {\r\n            const self = this;\r\n            if (feature.layer && self.features.indexOf(feature) >= 0) {\r\n                self.wrap.removeFeature(feature);\r\n                feature.layer = null;\r\n            }\r\n        };\r\n\r\n        layerProto.getFeatureById = function (id) {\r\n            const self = this;\r\n            let result = null;\r\n            var olFeat = self.wrap.getFeatureById(id);\r\n            if (olFeat) {\r\n                result = olFeat._wrap.parent;\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n         * Borra todas las entidades geográficas de la capa.\r\n         * @method clearFeatures\r\n         */\r\n        layerProto.clearFeatures = function () {\r\n            var self = this;\r\n            if (self.features && self.wrap) {\r\n                if (self.map) {\r\n                    const popups = self.map.getControlsByClass('TC.control.Popup');\r\n                    popups.forEach(function (pu) {\r\n                        if (pu.isVisible() && self.features.indexOf(pu.currentFeature) >= 0) {\r\n                            pu.hide();\r\n                        }\r\n                    });\r\n                }\r\n                self.features.length = 0;\r\n                self.wrap.clearFeatures();\r\n            }\r\n        };\r\n\r\n        //layerProto.getGetCapabilitiesUrl = function () {\r\n        //    const self = this;\r\n        //    const version = self.options.version || '1.1.0';\r\n        //    return self.url + '?service=WFS&' + 'version=' + version + '&request=GetCapabilities';\r\n        //};\r\n\r\n        layerProto.getDescribeFeatureTypeUrl = function (layerNames) {\r\n            const self = this;\r\n            const version = self.options.version || self.capabilities.version || '1.1.0';\r\n            let featureType = layerNames || self.featureType;\r\n            featureType = Array.isArray(featureType) ? featureType : [featureType];\r\n            return self.url + '?service=WFS&' + 'version=' + version + '&request=DescribeFeatureType&typename=' + featureType.join(',') + '&outputFormat=' + encodeURIComponent(self.capabilities.Operations.DescribeFeatureType.outputFormat);\r\n        };\r\n\r\n        const _getStoredFeatureTypes = function (layerName, collection) {\r\n            if (!(layerName instanceof Array))\r\n                layerName = layerName.split(\",\");\r\n            return layerName.reduce(function (vi, va) {\r\n                var temp = [];\r\n                temp[va] = collection[va]\r\n                return Object.assign(vi, temp);\r\n            }, {});\r\n        }\r\n\r\n        layerProto.describeFeatureType = function (layerName, callback, error) {\r\n            const self = this;\r\n            if (!layerName) layerName = self.options.featureType;\r\n            const result = new Promise(function (resolve, reject) {\r\n                self.getCapabilitiesPromise()\r\n                    .then(function (capabilities) {\r\n                        if (!capabilities.Operations.DescribeFeatureType) {\r\n                            reject(\"No esta disponible el método describeFeatureType\")\r\n                            return;\r\n                        }\r\n                        if (window.hasOwnProperty('Worker')) {\r\n                            var promsObj = {};\r\n                            const wwGetUrl = async function () {\r\n                                var wwLocation = TC.apiLocation + 'TC/workers/tc-dft-web-worker.js';\r\n                                if (TC.Util.isSameOrigin(TC.apiLocation)) {\r\n                                    return (wwLocation);\r\n                                }\r\n                                else {\r\n                                    try {\r\n                                        const response = await TC.ajax({\r\n                                            url: wwLocation,\r\n                                            method: 'GET',\r\n                                            responseType: 'text'\r\n                                        });\r\n                                        const data = response.data;\r\n                                        var blob = new Blob([data], { type: \"text/javascript\" });\r\n                                        var url = window.URL.createObjectURL(blob);\r\n                                        return url;\r\n                                    }\r\n                                    catch (err) {\r\n                                        throw err\r\n                                    }\r\n                                }\r\n                            }\r\n                            const wwInit = async function () {\r\n                                try {\r\n                                    if (!self.WebWorkerDFT) {\r\n                                        self.WebWorkerDFT = new Worker(await wwGetUrl());\r\n                                    }\r\n                                    self.WebWorkerDFT.onmessage = async function (e) {\r\n                                        if (!(e.data instanceof Object)) {\r\n                                            var data = await self.toolProxification.fetchXML(e.data);\r\n                                            self.WebWorkerDFT.postMessage({\r\n                                                url: e.data,\r\n                                                response: data.documentElement.outerHTML\r\n                                            });\r\n                                            return;\r\n                                        }\r\n                                        if (e.data.state === 'success') {\r\n                                            let key = Object.keys(e.data.DFTCollection).join(\",\");\r\n                                            if (TC.describeFeatureType[key]) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(typeof(TC.describeFeatureType[key]) === \"function\")\n\t\t\t\t\t\t\t\t\t\t\t\t\tTC.describeFeatureType[key].call(null, e.data.DFTCollection);\t\t\t\t\t\t\t\t\t\t\t\r\n                                                \r\n                                            }\r\n                                            else {\r\n                                                throw \"No se encuentra la clave \" + key + \" en la colección\";\r\n                                            }\n\t\t\t\t\t\t\t\t\t\t\tTC.describeFeatureType = Object.assign(TC.describeFeatureType, e.data.DFTCollection);\r\n                                        }\r\n                                        else {\r\n                                            throw \"Ha habido problemas procesando el Describe feature type\";\r\n                                            //reject(\"loquesea\");\r\n                                        }\r\n                                    };\r\n\r\n                                }\r\n                                catch (err) {\r\n                                    throw err;\r\n                                }\r\n\r\n                            }\r\n                            const wwProcess = async function (layers, callback) {\r\n                                var data = await self.toolProxification.fetchXML(self.getDescribeFeatureTypeUrl(layers || self.featureType));\r\n                                //checkear si excepciones del servidor\r\n                                if (data.querySelector(\"Exception\") || data.querySelector(\"exception\")) {\r\n                                    throw (data.querySelector(\"Exception\") || data.querySelector(\"exception\")).textContent.trim()\r\n                                }\r\n                                self.WebWorkerDFT.postMessage({\r\n                                    layerName: layers,\r\n                                    xml: data.documentElement.outerHTML,\r\n                                    url: (TC.apiLocation.indexOf(\"http\") >= 0 ? TC.apiLocation : document.location.protocol + TC.apiLocation)\r\n                                });\r\n                                TC.describeFeatureType[layers instanceof Array ? layers.join(\",\") : layers] = callback;\r\n                            }\r\n                            try {\r\n                                wwInit();\r\n                            }\r\n                            catch (err) {\r\n                                reject(err);\r\n                            }\r\n                            //si no es una array convierto en Array\r\n                            if (!(layerName instanceof Array)) layerName = layerName.split(\",\");\r\n                            //si tiene distinto Namespace separo las pediciones describeFeatureType\t\t\t\t\t\t\t\t\t\t\r\n                            var arrPromises = (Object.entries(layerName.reduce(function (vi, va) {\r\n                                let preffix = va.substring(0, va.indexOf(\":\"));\r\n                                if (!vi[preffix]) {\r\n                                    let temp = {};\r\n                                    temp[preffix] = [va]\r\n                                    return Object.assign(vi, temp);\r\n                                } else {\r\n                                    vi[preffix].push(va)\r\n                                    return vi;\r\n                                }\r\n                            }, {})).map(function (params) {\r\n                                var layers = params[1];\r\n                                return new Promise(async function (resolve, reject) {\r\n                                    if (TC.describeFeatureType[layers]) {\r\n                                        resolve(_getStoredFeatureTypes(layers, TC.describeFeatureType));\r\n                                        return;\r\n                                    }\r\n                                    try {\r\n                                        await wwProcess(layers, function (data) {\r\n                                            resolve(data);\r\n                                        });\r\n                                    }\r\n                                    catch (err) {\r\n                                        reject(err);\r\n                                    }\r\n                                })\r\n                            }));\r\n                            Promise.all(arrPromises).then(function (response) {\r\n                                let objReturned = response.reduce(function (vi, va) {\r\n                                    return Object.assign(vi, va)\r\n                                }, {});\r\n\r\n                                //si solo hay un objeto devuelvo directamente los atributos\tde este\t\t\t\t\r\n                                resolve(Object.keys(objReturned).length === 1 ? objReturned[Object.keys(objReturned)[0]] : objReturned);\r\n                            }).catch(reject);\r\n                        }\r\n                        else {\r\n                            reject(\"No esta disponible el WebWorker\")\r\n                        }\r\n                    })\r\n                    .catch(err => reject(err));\r\n            });\r\n            result.then(\r\n                function (data) {\r\n                    if (TC.Util.isFunction(callback)) {\r\n                        callback(data);\r\n                    }\r\n                },\r\n                function (errorText) {\r\n                    if (TC.Util.isFunction(error)) {\r\n                        error(errorText);\r\n                    }\r\n                }\r\n            );\r\n            return result;\r\n        };\r\n\r\n        layerProto.import = function (options) {\r\n            this.wrap.import(options);\r\n        };\r\n\r\n        layerProto.setNodeVisibility = function (id, visible) {\r\n            var self = this;\r\n\r\n            self.state = TC.Layer.state.LOADING;\r\n            self.map.trigger(TC.Consts.event.BEFOREUPDATE);\r\n            self.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: self });\r\n\r\n            if (!self.tree) {\r\n                self.tree = self.getTree();\r\n            }\r\n\r\n            var node = self.findNode(id, self.tree);\r\n            if (node === self.tree) {\r\n                self.setVisibility(visible);\r\n            }\r\n            else {\r\n                var cache = self._cache.visibilityStates;\r\n                cache[id] = visible ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;\r\n\r\n                var found = false;\r\n                var i;\r\n                var f;\r\n                for (i = 0; i < self.features.length; i++) {\r\n                    f = self.features[i];\r\n                    if (f.id == id) {\r\n                        found = true;\r\n                        f.setVisibility(visible);\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    for (i = 0; i < self.features.length; i++) {\r\n                        f = self.features[i];\r\n                        if (f._path === undefined) {\r\n                            f._path = '/' + f.getPath().join('/');\r\n                        }\r\n                        if (f._path === id) {\r\n                            f.setVisibility(visible);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            self.state = TC.Layer.state.IDLE;\r\n            self.map.trigger(TC.Consts.event.LAYERUPDATE, { layer: self });\r\n            self.map.trigger(TC.Consts.event.UPDATE);\r\n        };\r\n\r\n        layerProto.getNodeVisibility = function (id) {\r\n            var self = this;\r\n            var result = TC.Layer.prototype.getNodeVisibility.call(self, id);\r\n            if (!self.tree) {\r\n                self.tree = self.getTree();\r\n            }\r\n\r\n            var node = self.findNode(id, self.tree);\r\n            if (node === self.tree) {\r\n                result = self.getVisibility() ? TC.Consts.visibility.VISIBLE : TC.Consts.visibility.NOT_VISIBLE;\r\n            }\r\n            else {\r\n                var cache = self._cache.visibilityStates;\r\n                var r = cache[id];\r\n                if (r !== undefined) {\r\n                    result = r;\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        layerProto.setModifiable = function (modifiable) {\r\n            this.wrap.setModifiable(modifiable);\r\n        };\r\n\r\n        layerProto.applyEdits = function (inserts, updates, deletes) {\r\n            return this.wrap.sendTransaction(inserts, updates, deletes);\r\n        };\r\n\r\n        layerProto.refresh = function () {\r\n            const self = this;\r\n            self.clearFeatures();\r\n            return self.wrap.reloadSource();\r\n        };\r\n\r\n        layerProto.getFeaturesInCurrentExtent = function (tolerance) {\r\n            var self = this;\r\n\r\n            var extent = self.map.getExtent();\r\n            return this.getFeaturesInExtent(extent, tolerance);\r\n        };\r\n\r\n        layerProto.getFeaturesInExtent = function (extent, tolerance) {\r\n            return this.wrap.getFeaturesInExtent(extent, tolerance);\r\n        };\r\n\r\n        layerProto.setProjection = function (options) {\r\n            const self = this;\r\n            self.wrap.setProjection(options);\r\n            if (options.crs && options.oldCrs) {\r\n                self.map.trigger(TC.Consts.event.BEFORELAYERUPDATE, { layer: self });\r\n                self.features.forEach(function (feat) {\r\n                    feat.wrap.setGeometry(TC.Util.reproject(feat.geometry, options.oldCrs, options.crs));\r\n                    feat.geometry = feat.wrap.getGeometry();\r\n                });\r\n                self.map.trigger(TC.Consts.event.LAYERUPDATE, { layer: self });\r\n            }\r\n        };\r\n\r\n        layerProto.setStyles = function (options) {\r\n            const self = this;\r\n            self.styles = TC.Util.extend({}, options);\r\n            self.wrap.setStyles(options);\r\n        };\r\n\r\n        layerProto.exportState = function (options) {\r\n            const self = this;\r\n            options = options || {};\r\n            const lObj = {\r\n                id: self.id\r\n            };\r\n            if (self.map && self.map.crs !== self.map.options.crs) {\r\n                lObj.crs = self.map.crs;\r\n            }\r\n\r\n            // Aplicamos una precisión un dígito mayor que la del mapa, si no, al compartir algunas parcelas se deforman demasiado\r\n            var precision = Math.pow(10, (self.map.wrap.isGeo() ? TC.Consts.DEGREE_PRECISION : TC.Consts.METER_PRECISION) + 1);\r\n\r\n            const features = options.features || self.features;\r\n            lObj.features = features\r\n                .map(function (f) {\r\n                    const fObj = {};\r\n                    var layerStyle;\r\n                    switch (true) {\r\n                        case TC.feature.Marker && f instanceof TC.feature.Marker:\r\n                            fObj.type = TC.Consts.geom.POINT;\r\n                            layerStyle = self.options.styles && self.options.styles.marker;\r\n                            break;\r\n                        case TC.feature.Point && f instanceof TC.feature.Point:\r\n                            fObj.type = TC.Consts.geom.POINT;\r\n                            layerStyle = self.options.styles && self.options.styles.point;\r\n                            break;\r\n                        case TC.feature.MultiPoint && f instanceof TC.feature.MultiPoint:\r\n                            fObj.type = TC.Consts.geom.MULTIPOINT;\r\n                            break;\r\n                        case TC.feature.Polyline && f instanceof TC.feature.Polyline:\r\n                            fObj.type = TC.Consts.geom.POLYLINE;\r\n                            layerStyle = self.options.styles && self.options.styles.line;\r\n                            break;\r\n                        case TC.feature.MultiPolyline && f instanceof TC.feature.MultiPolyline:\r\n                            fObj.type = TC.Consts.geom.MULTIPOLYLINE;\r\n                            layerStyle = self.options.styles && self.options.styles.line;\r\n                            break;\r\n                        case TC.feature.Polygon && f instanceof TC.feature.Polygon:\r\n                            fObj.type = TC.Consts.geom.POLYGON;\r\n                            layerStyle = self.options.styles && self.options.styles.polygon;\r\n                            break;\r\n                        case TC.feature.MultiPolygon && f instanceof TC.feature.MultiPolygon:\r\n                            fObj.type = TC.Consts.geom.MULTIPOLYGON;\r\n                            layerStyle = self.options.styles && self.options.styles.polygon;\r\n                            break;\r\n                        case TC.feature.Circle && f instanceof TC.feature.Circle:\r\n                            fObj.type = TC.Consts.geom.CIRCLE;\r\n                            layerStyle = self.options.styles && self.options.styles.polygon;\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    fObj.id = f.id;\r\n                    fObj.geom = TC.Util.compactGeometry(f.geometry, precision);\r\n                    fObj.data = f.getData();\r\n                    fObj.showsPopup = f.showsPopup;\r\n                    if (options.exportStyles === undefined || options.exportStyles) {\r\n                        layerStyle = TC.Util.extend({}, layerStyle);\r\n                        for (var key in layerStyle) {\r\n                            var val = layerStyle[key];\r\n                            if (TC.Util.isFunction(val)) {\r\n                                layerStyle[key] = val(f);\r\n                            }\r\n                        }\r\n                        fObj.style = TC.Util.extend(layerStyle, f.getStyle());\r\n                    }\r\n                    return fObj;\r\n                });\r\n            return lObj;\r\n        };\r\n\r\n        layerProto.importState = function (obj) {\r\n            const self = this;\r\n            return new Promise(function (resolve, reject) {\r\n                const promises = new Array(obj.features.length);\r\n                obj.features.forEach(function (f, idx) {\r\n                    const featureOptions = TC.Util.extend(f.style, { data: f.data, id: f.id, showsPopup: f.showsPopup });\r\n                    var addFn;\r\n                    switch (f.type) {\r\n                        case TC.Consts.geom.POLYGON:\r\n                            addFn = self.addPolygon;\r\n                            break;\r\n                        case TC.Consts.geom.MULTIPOLYGON:\r\n                            addFn = self.addMultiPolygon;\r\n                            break;\r\n                        case TC.Consts.geom.POLYLINE:\r\n                            addFn = self.addPolyline;\r\n                            break;\r\n                        case TC.Consts.geom.MULTIPOLYLINE:\r\n                            addFn = self.addMultiPolyline;\r\n                            break;\r\n                        case TC.Consts.geom.CIRCLE:\r\n                            addFn = self.addCircle;\r\n                            break;\r\n                        case TC.Consts.geom.MULTIPOINT:\r\n                            if (f.style && (f.style.url || f.style.className)) {\r\n                                addFn = self.addMultiMarker;\r\n                            }\r\n                            else {\r\n                                addFn = self.addMultiPoint;\r\n                            }\r\n                            break;\r\n                        case TC.Consts.geom.POINT:\r\n                            if (f.style && (f.style.url || f.style.className)) {\r\n                                addFn = self.addMarker;\r\n                            }\r\n                            else {\r\n                                addFn = self.addPoint;\r\n                            }\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    if (addFn) {\r\n                        var geom = TC.Util.explodeGeometry(f.geom);\r\n                        if (obj.crs && self.map.crs !== obj.crs) {\r\n                            promises[idx] = new Promise(function (res, rej) {\r\n                                self.map.one(TC.Consts.event.PROJECTIONCHANGE, function (e) {\r\n                                    addFn.call(self, geom, featureOptions).then(\r\n                                        function () {\r\n                                            res();\r\n                                        },\r\n                                        function () {\r\n                                            rej(Error('addFn failed'));\r\n                                        }\r\n                                    );\r\n                                });\r\n                            });\r\n                        }\r\n                        else {\r\n                            promises[idx] = addFn.call(self, geom, featureOptions);\r\n                        }\r\n                    }\r\n                });\r\n                Promise.all(promises).then(\r\n                    function () {\r\n                        resolve();\r\n                    },\r\n                    function (err) {\r\n                        reject(err instanceof Error ? err : Error(err));\r\n                    });\r\n            });\r\n        };\r\n\r\n        layerProto.clone = function () {\r\n            const self = this;\r\n            const clone = TC.Layer.prototype.clone.call(self);\r\n            self.features.forEach(f => clone.addFeature(f.clone()));\r\n            return clone;\r\n        };\r\n\r\n        layerProto.getGetCapabilitiesUrl = function () {\r\n            const self = this;\r\n            if (self.type === TC.Consts.layerType.WFS) {\r\n                const getUrl = function () { return self.options.url || self.url };\r\n                const _src = !TC.Util.isSecureURL(getUrl()) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(getUrl())) ? self.getBySSL_(getUrl()) : getUrl();\r\n\r\n                var params = {\r\n                }\r\n                params.SERVICE = 'WFS';\r\n                params.VERSION = '2.0.0';\r\n                params.REQUEST = 'GetCapabilities';\r\n\r\n                return _src + '?' + TC.Util.getParamString(params);\r\n            }\r\n            else\r\n                return null;\r\n        };\r\n\r\n        layerProto.getCapabilitiesPromise = function () {\r\n            const self = this;\r\n            if (self.type === TC.Consts.layerType.WFS) {\r\n                return new Promise((resolve, reject) => {\r\n                    const processedCapabilities = function (capabilities) {\r\n                        // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.\r\n                        // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.\r\n                        self.capabilities = self.capabilities || capabilities;\r\n                        TC.capabilitiesWFS[self.options.url || self.url] = TC.capabilitiesWFS[self.options.url || self.url] || capabilities;\r\n                        TC.capabilitiesWFS[actualUrl] = TC.capabilitiesWFS[actualUrl] || capabilities;\r\n                        resolve(capabilities);\r\n                    };\r\n\r\n                    var actualUrl = (self.options.url || self.url).replace(/https ?:/gi, '');\r\n\r\n                    if (self.capabilities) {\r\n                        resolve(self.capabilities);\r\n                        self._capabilitiesPromise = Promise.resolve(self.capabilities);\r\n                    }\r\n                    if (TC.capabilitiesWFS[actualUrl]) {\r\n                        resolve(TC.capabilitiesWFS[actualUrl]);\r\n                        self._capabilitiesPromise = Promise.resolve(TC.capabilitiesWFS[actualUrl]);\r\n\r\n                    }\r\n\r\n                    self.toolProxification = new TC.tool.Proxification(TC.proxify);\r\n\r\n                    const cachePromise = capabilitiesPromises[actualUrl];\r\n                    capabilitiesPromises[actualUrl] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {\r\n                        const onlinePromise = self.getCapabilitiesOnline();\r\n                        const storagePromise = self.getCapabilitiesFromStorage();\r\n\r\n                        onlinePromise\r\n                            .then(function (capabilities) {\r\n                                res(capabilities);\r\n                            })\r\n                            .catch(function (error) {\r\n                                storagePromise.catch(function () {\r\n                                    rej(error);\r\n                                });\r\n                            });\r\n                        storagePromise\r\n                            .then(function (capabilities) {\r\n                                res(capabilities);\r\n                            })\r\n                            .catch(function () {\r\n                                onlinePromise.catch(function (error) {\r\n                                    rej(error);\r\n                                });\r\n                            });\r\n                    });\r\n\r\n                    capabilitiesPromises[actualUrl].then(function (capabilities) {\r\n                        processedCapabilities(capabilities);\r\n                    })\r\n                        .catch(function (error) {\r\n                            if (self.map) {\r\n                                self.map.trigger(TC.Consts.event.LAYERERROR, { layer: self, reason: 'couldNotGetCapabilities' });\r\n                            }\r\n                            reject(error)\r\n                        });\r\n                });\r\n            }\r\n            else {\r\n                return Promise.reject(new Error(`Layer \"${self.id}\" does not have capabilities document`));\r\n            }\r\n        };\r\n\r\n    })();\r\n})();"]}