{"version":3,"sources":["layer/Raster.js"],"names":["TC","layer","Layer","syncLoadJS","apiLocation","Consts","BLANK_IMAGE","_urlWFS","capabilitiesPromises","Map","wfsLayer","getWFSLayer","url","Promise","resolve","reject","options","loadJS","Vector","type","layerType","WFS","stealth","_createWMTSLayer","wrap","createWMTSLayer","_getLayerNodeIndex","treeNode","result","availableNames","indexOf","name","i","len","children","length","_getLayerNamePosition","counter","count","Raster","self","this","tool","Proxification","toolProxification","proxify","_capabilitiesPromise","apply","arguments","transparent","capabilities","params","layerNames","names","split","Array","isArray","push","hasOwnProperty","undefined","isVisible","sldBody","sld_body","parser","DOMParser","sldBodyToXml","parseFromString","e","error","message","namedLayerElm","Util","getElementByNodeName","textContent","ignorePrefixes","_capabilitiesNodes","_promise","endCreateLayerFn","ollyr","setLayer","Error","id","_createOLLayer","GROUP","WMTS","getCapabilitiesOnline","then","onlineCapabilities","join","format","LAYERS","FORMAT","TRANSPARENT","VERSION","version","extend","queryParams","infoFormat","getPreferredInfoFormat","INFO_FORMAT","filter","Filter","getText","querySelector","createWMSLayer","getGetMapUrl","_createWMSLayer","processedCapabilities","actualUrl","get","res","rej","onlinePromise","storagePromise","getCapabilitiesFromStorage","catch","set","getCapabilitiesPromise","map","trigger","event","LAYERERROR","reason","_disgregatedLayerNames","setWMTSUrl","inherit","layerProto","prototype","capabilitiesState_","PENDING","DONE","getByProxy_","getByUrl_","setVisibility","visible","tree","_cache","visibilityStates","call","_aggregateLayerNodeNames","layerNode","getLayerNodes","idx","firstIdx","nodeNames","elm","getName","reverse","fail","nodeName","splice","_disgregateLayerNames","ln","slice","rootNode","getRootLayerNode","concat","_disgregateLayerName","ancestorVisible","nodeVisible","compareNames","hasEmptyChildren","_extendLayerNameOptions","aggregate","lazy","_combineArray","source","add","rem","a","r","sa","_sortLayerNames","getTree","sort","b","idxa","idxb","_isNameInArray","looseComparison","getLimitedMatrixSet","layerId","matrixId","matrixSet","tset","Contents","TileMatrixSet","Identifier","ly","TileMatrixSetLink","tmsl","TileMatrixSetLimits","ret","limit","limits","matrix","TileMatrix","matrixIndex","setLayerNames","getLayer","opts","WMS","_aggregateLayerNames","newParams","_newParams","getParams","BEFOREUPDATEPARAMS","setParams","reset","UPDATEPARAMS","setFilter","oldParams","addLayerNames","ln2a","getDisgregatedLayerNames","removeLayerNames","ln2r","toggleLayerNames","ln2t","currentLayerNames","l","promises","all","arrays","a1","a2","olLayer","isNative","isValidFromNames","getLayerNodeByName","isCompatible","crs","getCompatibleMatrixSets","getCompatibleCRS","includeFallback","fallbackLayer","fbLayer","getFallbackLayer","normalized","getCRSCode","code","reduce","prev","cur","getProjection","getSource","getCode","setProjection","setMatrixSet","mustReproject","isVisibleByScale","nameOrUid","currentScale","_getOgcScale","getResolution","getMetersPerUnit","tileMatrix","getTileMatrix","scaleDenominators","getScaleDenominators","layers","getAllLayerNodes","node","parseInt","toString","parseFloat","some","nodeLayer","isVisibleByName","getWMTSLayer","getPathLayerNames","getPathLayerNamesForNode","capabilitiesNode","n","layerNodes","mustPushName","isVisibleByNode","isChildOrItself","potentialParent","potentialChild","child","ii","getLayerNodesByName","getTreeNode","forceAddition","isRootNode","uid","key","getUID","title","Title","abstract","Abstract","metadata","MetadataURL","isBase","isDefault","thumbnail","legend","src","getVisibility","inverseTree","fastUnshift","getLegend","hideTree","cache","_setNodeState","_result","visibility","NOT_VISIBLE","hasVisible","hasNotVisible","VISIBLE","HAS_VISIBLE","visibilityState","_sortTree","n1","n2","customLegend","setNodeVisibility","findNode","_getNames","getNodeVisibility","getNodePath","layerName","ignorePrefix","_getPath","getPath","getServiceType","getIdentifier","nodes","getChildrenLayers","_recursiveFn","lyr","arr","lc","idx1","idx2","substr","getResolutions","setResolutions","resolutions","getExtent","formatDescriptions","getInfo","info","forEach","md","formatDescription","getLocaleString","locale","getSimpleMimeType","searchSubLayers","text","patternFn","t","replace","lastPattern","lastMatches","re","RegExp","matches","ix","tcScore","tcPosition","normalizeLayerNode","trim","exec","titleIx","index","abstractIx","abs","res2","elto","titleA","replaceSpecialCharacters","titleB","getGetCapabilitiesUrl","serviceUrl","encoding","WMTSEncoding","RESTFUL","suffix","suffixIdx","SERVICE","REQUEST","getParamString","infoFormats","getInfoFormats","infoFormatPreference","getLegendGraphicImage","base64LegendSrc","window","btoa","xhr","XMLHttpRequest","dataEntries","chunks","env","open","setRequestHeader","responseType","onload","status","uInt8Array","Uint8Array","response","binaryString","String","fromCharCode","data","getResponseHeader","imageSrc","send","getUrl","getWebGLUrl","location","_src","isSecureURL","toAbsolutePath","getBySSL_","ignoreProxification","exportable","fetchImage","action","cacheHost","getAction","getFeatureUrl","fetch","getSiblingLoadedLayer","dynamicStatement","baseLayers","workLayers","elem","isFunction","getImageLoad","image","setSRC","img","getImage","isSameOrigin","mustBeExportable","crossOrigin","setAttribute","_get$events","TILELOAD","tile","onerror","TILELOADERROR","statusText","errorFn","z","x","y","parts","wmtsOptions","level","on3DView","MinTileRow","MaxTileRow","MinTileCol","MaxTileCol","console","log","BEFORETILELOAD","method","param","values","toLowerCase","fetchImageAsBlob","contentType","blob","imageUrl","URL","createObjectURL","evt","revokeObjectURL","$events","getWFSURL","async","document","href","search","URLSearchParams","request","service","Layers","outputFormat","startsWith","JSON","parse","responseText","layerDescriptions","owsType","_url","owsURL","endsWith","xmlDoc","layerDescription","getAttribute","err","getWFSCapabilities","getDescribeFeatureTypeUrl","newUrl","_getWFSURL","featureType","availableBaseLayers","Cfg","baseLayer","firstOption","describeFeatureType","refresh","reloadSource","esriParser","dom","documentElement","tagName","fiCollections","getElementsByTagName","fic","fInfos","j","lenj","fields","attributes","k","lenk","field","getElementText","feature","ol","Feature","setId"],"mappings":"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","sourcesContent":["\r\nTC.layer = TC.layer || {};\r\n\r\nif (!TC.Layer) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');\r\n}\r\n\r\nTC.Consts.BLANK_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7';\r\n\r\nconst _urlWFS = {};\r\n\r\n(function () {\r\n\r\n    const capabilitiesPromises = new Map();\r\n\r\n    var wfsLayer = null;//capa WFS de respaldo\r\n\r\n    const getWFSLayer = function (url) {\r\n        return new Promise(function (resolve, reject) {\r\n            if (!wfsLayer || wfsLayer.options.url !== url) {\r\n                TC.loadJS(\r\n                    !TC.layer.Vector,\r\n                    TC.apiLocation + 'TC/layer/Vector',\r\n                    function () {\r\n                        wfsLayer = new TC.layer.Vector({\r\n                            type: TC.Consts.layerType.WFS,\r\n                            url: url,\r\n                            stealth: true\r\n                        });\r\n                        resolve(wfsLayer);\r\n                    }\r\n                );\r\n            }\r\n            else {\r\n                resolve(wfsLayer);\r\n            }\r\n        });\r\n    };\r\n    \r\n    const _createWMSLayer = function (layer) {\r\n\r\n        var layerNames = Array.isArray(layer.names) ? layer.names.join(',') : layer.names;\r\n        var format = layer.options.format;\r\n        var options = layer.options;\r\n\r\n        var params = {\r\n            LAYERS: layerNames,\r\n            FORMAT: format,\r\n            TRANSPARENT: layer.transparent,\r\n            VERSION: layer.capabilities.version || '1.3.0'\r\n        };\r\n\r\n        if (layer.params) {\r\n            TC.Util.extend(params, layer.params);\r\n        }\r\n\r\n        if (layer.queryParams) {\r\n            TC.Util.extend(params, layer.queryParams);\r\n        }\r\n\r\n        var infoFormat = layer.getPreferredInfoFormat();\r\n        if (infoFormat !== null) {\r\n            params.INFO_FORMAT = infoFormat;\r\n        }\r\n        //filtro GML o CQL\r\n        if (options.filter) {\r\n            //primero miramos si es un objeto TC.filter\r\n            if (options.filter instanceof TC.filter.Filter) {\r\n                params[\"filter\"] = options.filter.getText();\r\n            }\r\n            //se puede parsear a XML, asumimos que es GML\r\n            else if (!new DOMParser().parseFromString(options.filter, 'text/xml').querySelector(\"parsererror\")) {\r\n                params[\"filter\"] = options.filter;\r\n            }\r\n            //Si no, asumimos que es CQL\r\n            else {\r\n                params[\"cql_filter\"] = options.filter;\r\n            }\r\n        }\r\n\r\n        return layer.wrap.createWMSLayer(layer.getGetMapUrl(), params, options);\r\n    };\r\n\r\n    const _createWMTSLayer = function (layer) {\r\n        return layer.wrap.createWMTSLayer(layer.options);\r\n    };\r\n\r\n    const _getLayerNodeIndex = function _getLayerNodeIndex(layer, treeNode) {\r\n\r\n        var result = layer.availableNames.indexOf(treeNode.name);\r\n        if (result === -1) {\r\n            for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n                result = _getLayerNodeIndex(layer, treeNode.children[i]);\r\n                if (result !== -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    const _sortTree = function _sortTree(layer, treeNode) {\r\n        var _sortFunction = function (n1, n2) {\r\n            return _getLayerNodeIndex(layer, n2) - _getLayerNodeIndex(layer, n1);\r\n        }\r\n        treeNode.children.sort(_sortFunction);\r\n        for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n            _sortTree(layer, treeNode.children[i]);\r\n        }\r\n    };\r\n\r\n    const _getLayerNamePosition = function _getLayerNamePosition(treeNode, name, counter) {\r\n        var result = false;\r\n        counter.count = counter.count + 1;\r\n        if (treeNode.name === name) {\r\n            result = true;\r\n        }\r\n        else {\r\n            // Las capas se ordenan de arriba a abajo en el árbol, por tanto hay que recorrer la lista del revés\r\n            for (var i = treeNode.children.length - 1; i >= 0; i--) {\r\n                if (_getLayerNamePosition(treeNode.children[i], name, counter)) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Opciones de nombre de capa.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.LayerNameOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Siempre que sea posible se reemplaza en la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} los nombres de capa por los nombres de las capas de grupo que las contienen.\r\n     * @property aggregate\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n    /**\r\n     * Determina si la capa nativa se actualiza en cuanto cambia la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} (valor <code>false</code>) \r\n     * o se espera a que la capa se actualice (valor <code>true</code>).\r\n     * @property lazy\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n    /**\r\n     * Determina si la capa la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/availableNames:property\"}}{{/crossLink}} (valor <code>false</code>) se restablece \r\n     * al actualizar la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}}.\r\n     * @property reset\r\n     * @type boolean|undefined\r\n     */\r\n\r\n    /**\r\n     * Opciones de capa raster.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.RasterOptions\r\n     * @extend TC.cfg.LayerOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Tipo de capa.\r\n     * @property type\r\n     * @type TC.consts.LayerType\r\n     * @default TC.Consts.layerType.WMS\r\n     */\r\n    /**\r\n     * URL del servicio OGC que define la capa.\r\n     * @property url\r\n     * @type string\r\n     */\r\n    /**\r\n     * Indica si la capa tiene transparencia.\r\n     * @property transparent\r\n     * @type boolean|undefined\r\n     */\r\n    /**\r\n     * Lista separada por comas de los nombres de capa del servicio OGC.\r\n     * @property layerNames\r\n     * @type string|undefined\r\n     */\r\n    /**\r\n     * Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.\r\n     * @property matrixSet\r\n     * @type string|undefined\r\n     */\r\n    /**\r\n     * Filtro GML o CQL de la capa. Funciona unicamente con capas WMS. Se intenta parsear a GML y si no sepuede se asume que es CQL\r\n     * @property filter\r\n     * @type string|undefined\r\n     */\r\n\r\n    /**\r\n     * Capa de tipo raster, como la de un WMS o un WMTS.\r\n     * @class TC.layer.Raster\r\n     * @extends TC.Layer\r\n     * @constructor\r\n     * @async\r\n     * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.\r\n     */\r\n    TC.layer.Raster = function () {\r\n        var self = this;\r\n\r\n        if (!TC.tool || !TC.tool.Proxification) {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');\r\n        }\r\n\r\n        this.toolProxification = new TC.tool.Proxification(TC.proxify);\r\n\r\n        //esta promise se resolverá cuando el capabilities esté descargado y parseado\r\n        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa\r\n        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)\r\n        this._capabilitiesPromise = null;\r\n\r\n        TC.Layer.apply(self, arguments);\r\n\r\n        self.wrap = new TC.wrap.layer.Raster(self);\r\n\r\n        /**\r\n         * Indica si la capa tiene transparencia.\r\n         * @property transparent\r\n         * @type boolean\r\n         * @default true\r\n         */\r\n        self.transparent = (self.options.transparent === false) ? false : true;\r\n\r\n        /**\r\n         * URL del servicio al que pertenenece la capa.\r\n         * @property url\r\n         * @type string\r\n         */\r\n        self.url = self.options.url;\r\n        self.capabilities = TC.capabilities[self.url];\r\n\r\n        self.params = self.options.params;\r\n        /**\r\n         * Lista de nombres de capa.\r\n         * @property names\r\n         * @type array\r\n         * @default []\r\n         */\r\n        /**\r\n         * Lista de nombres de capa disponibles inicialmente.\r\n         * @property availableNames\r\n         * @type array\r\n         * @default []\r\n         */\r\n        if (typeof self.options.layerNames === 'string') {\r\n            self.names = self.availableNames = self.options.layerNames.split(',');\r\n        }\r\n        else {\r\n            self.names = [];\r\n            self.availableNames = [];\r\n            if (Array.isArray(self.options.layerNames)) {\r\n                for (var i = 0; i < self.options.layerNames.length; i++) {\r\n                    var name = self.options.layerNames[i];\r\n                    if (typeof name === 'string') {\r\n                        self.names.push(name);\r\n                        self.availableNames.push(name);\r\n\r\n                    }\r\n                    else if (name.hasOwnProperty('name')) {\r\n                        self.availableNames.push(name.name);\r\n                        if (name.isVisible === undefined || name.isVisible) {\r\n                            self.names.push(name.name);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Si no se encuentran nombres de capas, se buscan en el parámetro sld_body. Este parámetro es utilizado\r\n                // cuando queremos instanciar una capa pasándole un SLD en la petición\r\n                var sldBody = self.options.params ? self.options.params.sld_body : null;\r\n\r\n                if (sldBody) {\r\n                    const parser = new DOMParser();\r\n                    var sldBodyToXml;\r\n                    try {\r\n                        sldBodyToXml = parser.parseFromString(sldBody, 'text/xml');\r\n                    }\r\n                    catch (e) {\r\n                        TC.error(e.message);\r\n                        sldBodyToXml = null;\r\n                    }\r\n                    if (sldBodyToXml) {\r\n                        var namedLayerElm = TC.Util.getElementByNodeName(sldBodyToXml, 'sld:NamedLayer');\r\n                        if (namedLayerElm && namedLayerElm.length > 0) {\r\n                            var names = TC.Util.getElementByNodeName(namedLayerElm[0], 'sld:Name');\r\n\r\n                            if (names && names.length > 0) {\r\n                                var name = names[0].textContent;\r\n                                self.names.push(name);\r\n                                self.availableNames.push(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        self.ignorePrefixes = self.options.ignorePrefixes === undefined ? true : self.options.ignorePrefixes;\r\n\r\n        self._capabilitiesNodes = {};\r\n\r\n        /**\r\n      * Árbol del documento de capabilities del servicio.\r\n      * @property capabilities\r\n      * @type object\r\n      */\r\n        self.wrap._promise = new Promise(function (resolve, reject) {\r\n            const endCreateLayerFn = function (ollyr) {\r\n                self.wrap.setLayer(ollyr);\r\n                if (ollyr) {\r\n                    resolve(ollyr);\r\n                }\r\n                else {\r\n                    reject(Error('Could not create native layer for \"' + self.id + '\"'));\r\n                }\r\n            };\r\n            /*\r\n             *  _createOLLayer: Crea la capa nativa correspondiente según el tipo\r\n             */\r\n            const _createOLLayer = function () {\r\n                let ollyr;\r\n                if (!self.wrap.layer) {\r\n                    switch (self.type) {\r\n                        case TC.Consts.layerType.GROUP:\r\n                            endCreateLayerFn(ollyr);\r\n                            break;\r\n                        case TC.Consts.layerType.WMTS:\r\n                            ollyr = _createWMTSLayer(self);\r\n                            // Ha fallado la creación. Puede que sea por capabilities cacheado obsoleto, así que \r\n                            // reintentamos online\r\n                            if (!ollyr) {\r\n                                self.getCapabilitiesOnline().then(function (onlineCapabilities) {\r\n                                    self.capabilities = onlineCapabilities;\r\n                                    ollyr = _createWMTSLayer(self);\r\n                                    endCreateLayerFn(ollyr);\r\n                                });\r\n                            }\r\n                            else {\r\n                                endCreateLayerFn(ollyr);\r\n                            }\r\n                            break;\r\n                        default:\r\n                            ollyr = _createWMSLayer(self);\r\n                            endCreateLayerFn(ollyr);\r\n                            break;\r\n                    }\r\n                }\r\n            };\r\n\r\n            const processedCapabilities = function (capabilities) {\r\n                // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.\r\n                // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.\r\n                self.capabilities = self.capabilities || capabilities;\r\n\r\n                var actualUrl = self.getGetMapUrl();\r\n                TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;\r\n                TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;\r\n\r\n                _createOLLayer();\r\n            };\r\n\r\n            if (self.capabilities) {\r\n                processedCapabilities(self.capabilities);\r\n                self._capabilitiesPromise = Promise.resolve(self.capabilities);\r\n                return;\r\n            }\r\n\r\n            self._capabilitiesPromise = capabilitiesPromises.get(self.url) || new Promise(function (res, rej) {\r\n                const onlinePromise = self.getCapabilitiesOnline();\r\n                const storagePromise = self.getCapabilitiesFromStorage();\r\n\r\n                onlinePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function (error) {\r\n                        storagePromise.catch(function () {\r\n                            rej(error);\r\n                        });\r\n                    });\r\n\r\n                storagePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function () {\r\n                        onlinePromise.catch(function (error) {\r\n                            rej(error);\r\n                        });\r\n                    });\r\n            });\r\n            capabilitiesPromises.set(self.url, self._capabilitiesPromise);\r\n\r\n            self.getCapabilitiesPromise()\r\n                .then(function (capabilities) {\r\n                    processedCapabilities(capabilities);\r\n                })\r\n                .catch(function (error) {\r\n                    if (self.map) {\r\n                        self.map.trigger(TC.Consts.event.LAYERERROR, { layer: self, reason: 'couldNotGetCapabilities' });\r\n                    }\r\n                    reject(error);\r\n                });\r\n        });\r\n\r\n        self._disgregatedLayerNames = null;\r\n\r\n        if (TC.Consts.layerType.WMTS == self.type) {\r\n            self.wrap.setWMTSUrl();\r\n        }\r\n    };\r\n\r\n    TC.inherit(TC.layer.Raster, TC.Layer);\r\n\r\n    var layerProto = TC.layer.Raster.prototype;\r\n        \r\n    layerProto.capabilitiesState_ = {\r\n        PENDING: 0,\r\n        DONE: 1\r\n    };\r\n\r\n    layerProto.getByProxy_ = function (url) {\r\n        return TC.proxify(url);\r\n    };\r\n    \r\n\r\n    layerProto.getByUrl_ = function (url) {\r\n        return url;\r\n    };\r\n\r\n\r\n    layerProto.setVisibility = function (visible) {\r\n        var layer = this;\r\n        layer.tree = null;\r\n        layer._cache.visibilityStates = {\r\n        };\r\n        TC.Layer.prototype.setVisibility.call(layer, visible);\r\n    };\r\n\r\n\r\n    /*\r\n     *  _aggregateLayerNames: devuelve un array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen\r\n     */\r\n    var _aggregateLayerNames = function (layer, layerNames) {\r\n        if (layer.type !== TC.Consts.layerType.WMS) {\r\n            return layerNames;\r\n        }\r\n        else {\r\n            var ln = layerNames.slice();\r\n            _aggregateLayerNodeNames(layer, ln, layer.wrap.getRootLayerNode());\r\n            return ln;\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  _aggregateLayerNodeNames: Agrega el array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen.\r\n     * Se parte de un nodo del árbol de capas del capabilities\r\n     */\r\n    var _aggregateLayerNodeNames = function _aggregateLayerNodeNames(layer, names, layerNode) {\r\n        var result = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        if (children.length) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                if (_aggregateLayerNodeNames(layer, names, children[i])) {\r\n                    result = true;\r\n                }\r\n            }\r\n\r\n            var nodeNames = children.map(function (elm) {\r\n                return layer.wrap.getName(elm);\r\n            }).reverse();\r\n            var idx, firstIdx;\r\n            var fail = false;\r\n\r\n            firstIdx = idx = names.indexOf(nodeNames[0]);\r\n            if (idx < 0) {\r\n                fail = true;\r\n            }\r\n            else {\r\n                for (var i = 1, len = nodeNames.length; i < len; i++) {\r\n                    if (nodeNames[i] != names[++idx]) {\r\n                        fail = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!fail) {\r\n                var nodeName = layer.wrap.getName(layerNode);\r\n                if (nodeName && nodeNames.length > 1) {\r\n                    names.splice(firstIdx, nodeNames.length, nodeName);\r\n                    result = true;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  _disgregateLayerNames: devuelve un array de nombres de capa WMS con solo capas hoja.\r\n     * Parámetros: objeto de capa, array of strings, nodo de la capa en el capabilities, booleano que dice si esta rama viene de un nodo visible\r\n     */\r\n    var _disgregateLayerNames = function (layer, layerNames) {\r\n        var result = [];\r\n        var ln = layerNames.slice();\r\n        var rootNode = layer.wrap.getRootLayerNode();\r\n        for (var i = 0, len = ln.length; i < len; i++) {\r\n            result = result.concat(_disgregateLayerName(layer, ln[i], rootNode));\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _disgregateLayerName = function _disgregateLayerName(layer, name, layerNode, ancestorVisible) {\r\n        var result = [];\r\n        var nodeName = layer.wrap.getName(layerNode);\r\n        var nodeVisible = layer.compareNames(name, nodeName);\r\n        var hasEmptyChildren = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        for (var i = 0; i < children.length; i++) {\r\n            var names = _disgregateLayerName(layer, name, children[i], ancestorVisible || nodeVisible);\r\n            if (!names.length) {\r\n                hasEmptyChildren = true;\r\n            }\r\n            else {\r\n                result = result.concat(names);\r\n            }\r\n        }\r\n        if (!children.length || hasEmptyChildren) {\r\n            if (ancestorVisible || nodeVisible) {\r\n                result = [nodeName];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _extendLayerNameOptions = function (options) {\r\n        return TC.Util.extend({ aggregate: true, lazy: false }, options);\r\n    };\r\n\r\n    var _combineArray = function (source, add, rem) {\r\n        var result = [];\r\n        var s, a, r;\r\n        s = source ? source : [];\r\n        a = add ? add : [];\r\n        r = rem ? rem : [];\r\n        var sa = s.concat(a);\r\n        for (var i = 0; i < sa.length; i++) {\r\n            if (sa.indexOf(sa[i]) === i && r.indexOf(sa[i]) === -1) {\r\n                result.push(sa[i]);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _sortLayerNames = function (layer, layerNames) {\r\n        var ln = (typeof layerNames === 'string') ? layerNames.split(',') : layerNames;\r\n        if (layer.capabilities) {\r\n            var tree = layer.getTree();\r\n            ln.sort(function (a, b) {\r\n                var idxa = {\r\n                    count: 0\r\n                };\r\n                var idxb = {\r\n                    count: 0\r\n                };\r\n                _getLayerNamePosition(tree, a, idxa);\r\n                _getLayerNamePosition(tree, b, idxb);\r\n                return idxa.count - idxb.count;\r\n            });\r\n        }\r\n        return ln;\r\n    };\r\n\r\n    var _isNameInArray = function (layer, name, names, looseComparison) {\r\n        return names.filter(function (elm) {\r\n            return layer.compareNames(name, elm, looseComparison);\r\n        }).length > 0;\r\n    };\r\n\r\n    /*\r\n     *  getLimitedMatrixSet: devuelve un array de tileMatrixSets limitados por su correspondiente TileMatrixSetLimits (si es que lo tiene)\r\n     */\r\n    layerProto.getLimitedMatrixSet = function () {\r\n        const self = this;\r\n        const layerId = self.layerNames;\r\n        const matrixId = self.matrixSet;\r\n        var capabilities = self.capabilities;\r\n\r\n        const tset = capabilities.Contents.TileMatrixSet.filter(function (elm) {\r\n            return elm.Identifier == matrixId;\r\n        })[0];\r\n\r\n        if (tset) {\r\n            var ly = capabilities.Contents.Layer.filter(function (elm) { return elm.Identifier == layerId; })[0];\r\n            if (ly.TileMatrixSetLink) {\r\n                const tmsl = ly.TileMatrixSetLink.filter(elm => elm.TileMatrixSet === matrixId)[0];\r\n                if (tmsl && tmsl.TileMatrixSetLimits) {\r\n                    const ret = [];\r\n                    let limit, limits = tmsl.TileMatrixSetLimits;\r\n                    for (var i = 0; i < limits.length; i++) {\r\n                        limit = limits[i];\r\n                        const matrix = tset.TileMatrix.filter(function (elm) {\r\n                            return elm.Identifier == limit.TileMatrix\r\n                        });\r\n                        if (matrix.length) {\r\n                            ret.push(TC.Util.extend({ matrixIndex: tset.TileMatrix.indexOf(matrix[0]) }, matrix[0], limit));\r\n                        }\r\n                    }\r\n\r\n                    return ret;\r\n                }\r\n                else {\r\n                    return tset.TileMatrix;\r\n                }\r\n            }\r\n            else {\r\n                return tset.TileMatrix;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Establece los nombres de capas que deben estar visibles en un WMS. Si la lista está vacía, hace invisible la capa.\r\n     * @method setLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  setLayerNames: sets the visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.setLayerNames = function (layerNames, options) {\r\n        var layer = this;\r\n        return new Promise(function (resolve, reject) {\r\n            layer.wrap.getLayer().then(function () {\r\n                var ln = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                layer.names = ln;\r\n                var opts = _extendLayerNameOptions(options);\r\n                if (opts.aggregate) {\r\n                    ln = _aggregateLayerNames(layer, ln);\r\n                }\r\n                layer._disgregatedLayerNames = null;\r\n                var newParams = {\r\n                    LAYERS: ln.join(','), TRANSPARENT: true\r\n                };\r\n                if (opts.lazy) {\r\n                    var params = layer._newParams || layer.wrap.getParams();\r\n                    layer._newParams = TC.Util.extend(params, newParams);\r\n                }\r\n                else {\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });\r\n                    }\r\n                    layer.tree = null;\r\n                    layer._cache.visibilityStates = {\r\n                    };\r\n                    layer.wrap.setParams(newParams);\r\n                    if (opts.reset || !layer.map) {\r\n                        // layerNames se fija cuando se añade al mapa o cuando reset = true.\r\n                        layer.availableNames = layer.names;\r\n                    }\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });\r\n                    }\r\n                }\r\n                resolve(layer.names);\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Establece el atributo filter o CQL_filter de una capa WMS.\r\n     * @method setFilter\r\n     * @param {TC.filter.Filter|string} filter Objeto de tipo TC.filter.Filter, un filtro GML como cadena de texto o filtro CQL como cadena de texto\r\n     */\r\n    /*\r\n     *  setFilter: sets the filter or CQL_filter attribute on WMS layer\r\n     *  Parameters: object instance of  TC.filter.Filter or a GML filter string\r\n     */\r\n    layerProto.setFilter = function (filter) {\r\n        var layer = this;\r\n        return new Promise(function (resolve, reject) {\r\n            layer.wrap.getLayer().then(function () {\r\n                var oldParams = layer.wrap.getParams();\r\n                delete oldParams[\"filter\"];\r\n                delete oldParams[\"cql_filter\"];\r\n\r\n                //if (layer.map) {\r\n                //    layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });\r\n                //}\r\n\r\n                //primero miramos si es un objeto TC.filter\r\n                if (filter instanceof TC.filter.Filter) {\r\n                    layer.filter=oldParams[\"filter\"] = filter.getText();\r\n                }\r\n                //se puede parsear a XML, asumimos que es GML\r\n                else if (!new DOMParser().parseFromString(filter, 'text/xml').querySelector(\"parsererror\")) {\r\n                    layer.filter =oldParams[\"filter\"] = filter;\r\n                }\r\n                //Si no, asumimos que es CQL\r\n                else {\r\n                    layer.filter = oldParams[\"cql_filter\"] = filter;\r\n                }\r\n                layer.wrap.setParams(oldParams);\r\n\r\n                //if (layer.map) {\r\n                //    layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });\r\n                //}\r\n                \r\n                resolve(filter);\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Añade capas por nombre a las que ya están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  addLayerNames: adds layer names to the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.addLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2a = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2a = _disgregateLayerNames(self, ln2a);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, ln2a, null)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Elimina capas por nombre de las que están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  removeLayerNames: removes layer names from the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.removeLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2r = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2r = _disgregateLayerNames(self, ln2r);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, null, ln2r)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Toma una lista de nombres de capa WMS y cambia su visibilidad: de visible a no visible y viceversa.\r\n     * @method toggleLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  toggleLayerNames: from a list, adds a layer name when it is not visible or removes a layer name when it is visible in a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.toggleLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2t = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var currentLayerNames = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2t = _disgregateLayerNames(self, ln2t);\r\n                    currentLayerNames = self.getDisgregatedLayerNames();\r\n                }\r\n                var ln2a = [];\r\n                var ln2r = [];\r\n                for (var i = 0; i < ln2t.length; i++) {\r\n                    var l = ln2t[i];\r\n                    if (currentLayerNames.indexOf(l) < 0) {\r\n                        ln2a.push(l);\r\n                    }\r\n                    else {\r\n                        ln2r.push(l);\r\n                    }\r\n                }\r\n                var promises = [];\r\n                if (ln2a.length > 0) {\r\n                    promises.push(self.addLayerNames(ln2a, opts));\r\n                }\r\n                if (ln2r.length > 0) {\r\n                    promises.push(self.removeLayerNames(ln2r, opts));\r\n                }\r\n                Promise.all(promises).then(function (arrays) {\r\n                    const a1 = arrays[0];\r\n                    const a2 = arrays[1];\r\n                    if (a1) {\r\n                        if (a2) {\r\n                            resolve(a1.concat(a2));\r\n                        }\r\n                        else {\r\n                            resolve(a1);\r\n                        }\r\n                    }\r\n                    else {\r\n                        resolve([]);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n     * @method getDisgregatedLayerNames\r\n     * @return {array}\r\n     */\r\n    /*\r\n     *  getDisgregatedLayerNames: returns an array of visible WMS leaf layer names\r\n     */\r\n    layerProto.getDisgregatedLayerNames = function () {\r\n        ///<summary>\r\n        ///Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n        ///</summary>\r\n        ///<returns type=\"array\" elementType=\"string\"></returns>\r\n        var self = this;\r\n        var olLayer = self.wrap.layer;\r\n        if (self.wrap.isNative(olLayer) && self.type === TC.Consts.layerType.WMS) {\r\n            if (!self._disgregatedLayerNames) {\r\n                var layerNames = self.wrap.getParams().LAYERS;\r\n                layerNames = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                self._disgregatedLayerNames = _disgregateLayerNames(self, layerNames);\r\n            }\r\n        }\r\n        else {\r\n            self._disgregatedLayerNames = self.names;\r\n        }\r\n        return self._disgregatedLayerNames.slice();\r\n    };\r\n\r\n    layerProto.isValidFromNames = function () {\r\n        var self = this;\r\n        var result = true;\r\n        for (var i = 0, len = self.names.length; i < len; i++) {\r\n            if (!self.getLayerNodeByName(self.names[i])) {\r\n                result = false;\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.isCompatible = function (crs) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = self.wrap.isCompatible(crs) || self.wrap.getCompatibleMatrixSets(crs).length > 0;\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = self.wrap.isCompatible(crs);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCompatibleCRS = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        var result = self.wrap.getCompatibleCRS();\r\n        if (options.includeFallback && self.fallbackLayer) {\r\n            const fbLayer = self.getFallbackLayer();\r\n            if (fbLayer instanceof TC.Layer) {\r\n                result = result.concat(fbLayer.wrap.getCompatibleCRS());\r\n            }\r\n        }\r\n        if (options.normalized) {\r\n            result = result\r\n                .map(function (crs) {\r\n                    return TC.Util.getCRSCode(crs);\r\n                }) // códigos numéricos\r\n                .filter(function (code) {\r\n                    return code !== null;\r\n                })\r\n                .reduce(function (prev, cur) {\r\n                    if (prev.indexOf(cur) < 0) {\r\n                        prev.push(cur);\r\n                    }\r\n                    return prev;\r\n                }, []) // códigos numéricos sin duplicados\r\n                .map(function (code) {\r\n                    return 'EPSG:' + code;\r\n                }); // códigos normalizados\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getProjection = function () {\r\n        var self = this;\r\n\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                return self.wrap.layer.getSource().getProjection().getCode();\r\n            case TC.Consts.layerType.WMS:\r\n                return self.map.crs;\r\n        }\r\n    };\r\n\r\n    layerProto.setProjection = function (options) {\r\n        var self = this;\r\n        options = options || {};\r\n        if (options.crs) {\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    var matrixSet = self.wrap.getCompatibleMatrixSets(options.crs)[0];\r\n                    if (matrixSet) {\r\n                        self.matrixSet = matrixSet;\r\n                        self.wrap.setMatrixSet(matrixSet);\r\n                    }\r\n                    else {\r\n                        self.wrap.setProjection(options);\r\n                    }\r\n                    self.mustReproject = !matrixSet;\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    self.wrap.setProjection(options);\r\n                    self.mustReproject = !self.isCompatible(options.crs);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByScale: return wether the WMS layer is visible at current scale\r\n     *  Parameter: WMS layer name or UID\r\n     */\r\n    layerProto.isVisibleByScale = function (nameOrUid, looseComparison) {\r\n        var self = this;\r\n        var result;\r\n        var _getOgcScale = function () {\r\n            return self.map.wrap.getResolution() * self.map.getMetersPerUnit() / 0.00028; // OGC assumes 0.28 mm / pixel\r\n        };\r\n        var currentScale;\r\n        var i;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = false;\r\n                var tileMatrix = self.wrap.getTileMatrix(self.options.matrixSet);\r\n                if (tileMatrix) {\r\n                    currentScale = _getOgcScale();\r\n                    for (i = 0; i < tileMatrix.length; i++) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(tileMatrix[i]);\r\n                        if (scaleDenominators[0] === currentScale) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = true;\r\n                var layers = self.wrap.getAllLayerNodes();\r\n                if (layers.length > 0) {\r\n                    currentScale = _getOgcScale();\r\n                    var node;\r\n                    if (parseInt(nameOrUid).toString() === nameOrUid) { // Es numérico, asumimos que es un UID\r\n                        node = self._capabilitiesNodes[nameOrUid];\r\n                    }\r\n                    else {\r\n                        for (i = 0; i < layers.length; i++) {\r\n                            var layer = layers[i];\r\n                            if (self.compareNames(self.wrap.getName(layer), nameOrUid, looseComparison)) {\r\n                                node = layer;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (node) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(node);\r\n                        result = !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale);\r\n\r\n                        // GLS: si no es visible miramos si tiene capas hijas y si tiene comprobamos si alguna de ellas es visible a la escala actual.\r\n                        if (!result) {\r\n                            if (node.Layer && node.Layer.length > 0) {\r\n                                return node.Layer.some(function (nodeLayer) {\r\n                                    var scaleDenominators = self.wrap.getScaleDenominators(nodeLayer);\r\n                                    return !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale)\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByName: return wether the WMS layer is visible because of the requested layer names\r\n     *  Parameter: WMS layer name\r\n     */\r\n    layerProto.isVisibleByName = function (name, looseComparison) {\r\n        const self = this;\r\n        let result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                if (self.wrap.getWMTSLayer()) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                const getPathLayerNames = function getPathLayerNames(name) {\r\n                    return getPathLayerNamesForNode(name, self.wrap.getRootLayerNode());\r\n                };\r\n\r\n                const getPathLayerNamesForNode = function getPathLayerNamesForNode(name, capabilitiesNode) {\r\n                    let result = [];\r\n                    const n = self.wrap.getName(capabilitiesNode);\r\n                    if (self.compareNames(n, name, looseComparison)) {\r\n                        result.push(n);\r\n                    }\r\n                    else {\r\n                        const layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                        let mustPushName = false;\r\n                        for (var i = 0; i < layerNodes.length; i++) {\r\n                            const item = layerNodes[i];\r\n                            const r = getPathLayerNamesForNode(name, item);\r\n                            if (r.length) {\r\n                                mustPushName = true;\r\n                                result = result.concat(r);\r\n                            }\r\n                        }\r\n                        if (mustPushName) {\r\n                            result.push(n);\r\n                        }\r\n                    }\r\n                    return result;\r\n                };\r\n\r\n                result = getPathLayerNames(name).some(n => _isNameInArray(self, n, self.names));\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.isVisibleByNode = function (node) {\r\n        const self = this;\r\n        let result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                if (self.wrap.getWMTSLayer()) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                const isChildOrItself = function (potentialParent, potentialChild) {\r\n                    if (potentialParent === potentialChild) {\r\n                        return true;\r\n                    }\r\n                    return potentialParent.Layer && potentialParent.Layer.some(child => isChildOrItself(child, potentialChild));\r\n                };\r\n                for (var i = 0, ii = self.names.length; i < ii; i++) {\r\n                    const nodes = self.getLayerNodesByName(self.names[i]);\r\n                    if (nodes.some(n => isChildOrItself(n, node))) {\r\n                        result = true;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getTree = function () {\r\n        var self = this;\r\n        \r\n        var result = self.tree;\r\n\r\n        var addChild = function (node, child) {\r\n            if (self.options.inverseTree) {\r\n                // Versión rápida de unshift\r\n                TC.Util.fastUnshift(node.children, child);\r\n            }\r\n            else {\r\n                node.children.push(child);\r\n            }\r\n        }\r\n\r\n        if (!result) {\r\n            var rootNode;\r\n            var getTreeNode = function getTreeNode(capabilitiesNode, forceAddition, isRootNode) {\r\n                var uid;\r\n                for (var key in self._capabilitiesNodes) {\r\n                    if (self._capabilitiesNodes[key] === capabilitiesNode) {\r\n                        uid = key;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!uid) {\r\n                    uid = TC.getUID();\r\n                    self._capabilitiesNodes[uid] = capabilitiesNode;\r\n                }\r\n                var r = {\r\n                    name: self.wrap.getName(capabilitiesNode), title: capabilitiesNode.title || capabilitiesNode.Title, uid: uid, children: [], abstract: !!capabilitiesNode.Abstract, metadata: !!capabilitiesNode.MetadataURL\r\n                };\r\n                if (isRootNode) {\r\n                    rootNode = r;\r\n                }\r\n\r\n                if (_isNameInArray(self, r.name, self.availableNames)) {\r\n                    forceAddition = true;\r\n                }\r\n\r\n                if (!self.options.isBase) {\r\n                    if (r === rootNode) {\r\n                        r.isVisible = self.getVisibility();\r\n                    }\r\n                    else {\r\n                        r.isVisible = self.isVisibleByName(r.name);\r\n                        //r.isVisible = self.isVisibleByNode(capabilitiesNode);\r\n                    }\r\n                    var i;\r\n                    var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                    for (i = 0; i < layerNodes.length; i++) {\r\n                        var treeNode = getTreeNode(layerNodes[i], forceAddition);\r\n                        if (treeNode) {\r\n                            addChild(r, treeNode);\r\n                        }\r\n                    }\r\n\r\n                    r.legend = self.wrap.getLegend(capabilitiesNode);\r\n\r\n                    // No muestra ramas irrelevantes si hideTree = true\r\n                    if (!forceAddition && !isRootNode) {\r\n                        // Eliminamos la rama hasta el nodo de interés\r\n                        rootNode.children = rootNode.children.concat(r.children);\r\n                        r = null;\r\n                    }\r\n                }\r\n                else {\r\n                    r.name = self.names.join(',');\r\n                    r.title = self.title || r.title;\r\n                    r.isBase = self.isDefault;\r\n                    if (self.options.thumbnail) {\r\n                        r.legend = {\r\n                            src: self.options.thumbnail\r\n                        };\r\n                    }\r\n                }\r\n                return r;\r\n            };\r\n\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    result = getTreeNode(self.wrap.getWMTSLayer(), !self.options.hideTree, true);\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    if (self.capabilities) {\r\n                        result = getTreeNode(self.wrap.getRootLayerNode(), !self.options.hideTree, true);\r\n\r\n                        var cache = self._cache.visibilityStates;\r\n\r\n                        var _setNodeState = function _setNodeState(node) {\r\n                            var _result = TC.Consts.visibility.NOT_VISIBLE;\r\n                            if (node) {\r\n                                if (cache[node.uid] !== undefined) {\r\n                                    _result = cache[node.uid];\r\n                                }\r\n                                else {\r\n                                    if (node.children) {\r\n                                        var hasVisible = false;\r\n                                        var hasNotVisible = false;\r\n                                        for (var i = 0, len = node.children.length; i < len; i++) {\r\n                                            var r = _setNodeState(node.children[i]);\r\n                                            switch (r) {\r\n                                                case TC.Consts.visibility.VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.NOT_VISIBLE:\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.HAS_VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                default:\r\n                                                    break;\r\n                                            }\r\n                                            if (hasVisible) {\r\n                                                if (hasNotVisible) {\r\n                                                    _result = TC.Consts.visibility.HAS_VISIBLE;\r\n                                                }\r\n                                                else {\r\n                                                    _result = TC.Consts.visibility.VISIBLE;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    if (node.isVisible) {\r\n                                        _result = TC.Consts.visibility.VISIBLE;\r\n                                    }\r\n                                    cache[node.uid] = _result;\r\n                                }\r\n                                node.visibilityState = _result;\r\n                            }\r\n                            return _result;\r\n                        };\r\n                        _setNodeState(result);\r\n\r\n                        if (self.options.hideTree) {\r\n                            _sortTree(self, result);\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (!result) {\r\n                result = {\r\n                    name: self.name, title: self.title\r\n                };\r\n            }\r\n            result.title = self.title || result.title;\r\n            result.customLegend = self.customLegend || result.customLegend;\r\n            self.tree = result;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.setNodeVisibility = function (id, visible) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n\r\n        var _getNames = function _getNames(node) {\r\n            var result = [];\r\n            if (node.name) {\r\n                result[0] = node.name;\r\n            }\r\n            else {\r\n                for (var i = 0; i < node.children.length; i++) {\r\n                    result = result.concat(_getNames(node.children[i]));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        var node = self.findNode(id, self.tree);\r\n        if (node === self.tree) {\r\n            if (visible && self.names.length === 0) {\r\n                // Prevent pink error tile\r\n                self.addLayerNames(self.availableNames).then(function () {\r\n                    self.setVisibility(true);\r\n                });\r\n            }\r\n            else {\r\n                self.setVisibility(visible);\r\n            }\r\n        }\r\n        else {\r\n            var names = _getNames(node);\r\n            if (visible) {\r\n                self.addLayerNames(names);\r\n            }\r\n            else {\r\n                self.removeLayerNames(names);\r\n            }\r\n        }\r\n    };\r\n\r\n    layerProto.getNodeVisibility = function (id) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n        return self._cache.visibilityStates[id];\r\n    };\r\n\r\n    layerProto.getNodePath = function (layerName, ignorePrefix) {\r\n        var self = this;\r\n        var result = [];\r\n        if (self.type === TC.Consts.layerType.WMS && self.capabilities) {\r\n            layerName = layerName || self.names[0];\r\n\r\n            var _getPath = function _getPath(node) {\r\n                var res = [];\r\n                var nodeName = self.wrap.getName(node);\r\n                if (self.compareNames(nodeName, layerName, ignorePrefix)) {\r\n                    res.push(node);\r\n                }\r\n                else {\r\n                    var children = self.wrap.getLayerNodes(node);\r\n                    for (var i = 0; i < children.length; i++) {\r\n                        var r = _getPath(children[i]);\r\n                        if (r.length) {\r\n                            res = r;\r\n                            TC.Util.fastUnshift(res, node);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return res;\r\n            };\r\n            result = _getPath(self.wrap.getRootLayerNode());\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getPath = function (layerName, ignorePrefix) {\r\n        return this.getNodePath(layerName, ignorePrefix).map(function (node) {\r\n            return node.title || node.Title;\r\n        });\r\n    };\r\n\r\n    layerProto.getLayerNodesByName = function (name) {\r\n        const result = [];\r\n        const self = this;\r\n        const getName = self.wrap.getServiceType() === TC.Consts.layerType.WMTS ? self.wrap.getIdentifier : self.wrap.getName\r\n        const nodes = self.wrap.getAllLayerNodes();\r\n        for (var i = 0, len = nodes.length; i < len; i++) {\r\n            if (self.compareNames(getName(nodes[i]), name)) {\r\n                result.push(nodes[i]);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getLayerNodeByName = function (name) {\r\n        const self = this;\r\n        const nodes = self.getLayerNodesByName(name);\r\n        if (nodes.length) {\r\n            return nodes[0];\r\n        }\r\n        return null;\r\n    };\r\n\r\n    layerProto.getChildrenLayers = function (layer) {\r\n        var result = [];\r\n        var _recursiveFn = function (lyr, arr) {\r\n            if (lyr && lyr.Layer && lyr.Layer.length) {\r\n                for (var i = 0; i < lyr.Layer.length; i++) {\r\n                    arr.push(lyr.Layer[i]);\r\n                    _recursiveFn(lyr.Layer[i], arr);\r\n                }\r\n            }\r\n        };\r\n        _recursiveFn(layer, result);\r\n        return result;\r\n    };\r\n\r\n    layerProto.compareNames = function (n1, n2, looseComparison) {\r\n        var result = n1 === n2;\r\n        var self = this;\r\n        var lc = looseComparison !== undefined ? looseComparison : self.ignorePrefixes\r\n        if (!result && lc && n1 && n2) {\r\n            // Revisamos si tienen prefijo. Si lo tiene solo una de las dos lo obviamos para la comparación\r\n            var idx1 = n1.indexOf(':');\r\n            var idx2 = n2.indexOf(':');\r\n            if (idx1 >= 0 && idx2 < 0) {\r\n                result = n1.substr(idx1 + 1) === n2;\r\n            }\r\n            else if (idx2 >= 0 && idx1 < 0) {\r\n                result = n1 === n2.substr(idx2 + 1);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCapabilitiesPromise = function () {\r\n        return this._capabilitiesPromise;\r\n    };\r\n\r\n    layerProto.getResolutions = function () {\r\n        return this.wrap.getResolutions();\r\n    };\r\n\r\n    layerProto.setResolutions = function (resolutions) {\r\n        this.wrap.setResolutions(resolutions);\r\n    };\r\n\r\n    layerProto.getExtent = function () {\r\n        return this.wrap.getExtent();\r\n    };\r\n\r\n    const formatDescriptions = {};\r\n    layerProto.getInfo = function (name) {\r\n        const self = this;\r\n        const info = self.wrap.getInfo(name);\r\n        if (info.metadata) {\r\n            info.metadata.forEach(function (md) {\r\n                if (self.map) {\r\n                    md.formatDescription = formatDescriptions[md.format] =\r\n                        formatDescriptions[md.format] ||\r\n                        TC.Util.getLocaleString(self.map.options.locale, TC.Util.getSimpleMimeType(md.format)) ||\r\n                        TC.Util.getLocaleString(self.map.options.locale, 'viewMetadata');\r\n                }\r\n                else {\r\n                    md.formatDescription = formatDescriptions[md.format];\r\n                }\r\n            });\r\n        }\r\n        return info;\r\n    };\r\n\r\n    //Devuelve un array de subLayers cuyo nombre o descripción contenga el texto indicado\r\n    //case insensitive\r\n    layerProto.searchSubLayers = function (text) {\r\n        if (!this.patternFn) {\r\n            this.patternFn = function (t) {\r\n                t = t.replace(/[^a-z\\dáéíóúüñ]/gi, '\\\\' + '$&');\r\n                t = t.replace(/(a|á)/gi, \"(a|á)\");\r\n                t = t.replace(/(e|é)/gi, \"(e|é)\");\r\n                t = t.replace(/(i|í)/gi, \"(i|í)\");\r\n                t = t.replace(/(o|ó)/gi, \"(o|ó)\");\r\n                t = t.replace(/(u|ú|ü)/gi, \"(u|ú|ü)\");\r\n                t = t.replace(/n/gi, \"(n|ñ)\");\r\n                return t;\r\n            }\r\n        }\r\n        if (text && text.length && text.length >= 3) {\r\n            var self = this;\r\n            var layers = null;\r\n            /*URI:Si la cadena a buscar contiene a la busqueda anterior, por ejemplo, antes he buscado \"cat\" y ahora busco \"cata\" porque esto escribiendo \"catastro\" ...\r\n            en vez de buscar en todas las capas del servicio busco en los resultados encotrados en la búsqueda anterior */\r\n            if (this.lastPattern && text.indexOf(this.lastPattern) >= 0) {\r\n                layers = this.lastMatches\r\n            }\r\n            else {\r\n                /*si se ha definido el parametro layers de esta capa en configuraci\\u00f3n filtro las capas del capability para que busque solo en las capas que est\\u00e9n en \r\n                configuraci\\u00f3n y sus hijas*/\r\n                if (self.availableNames && self.availableNames.length > 0) {\r\n                    layers = []\r\n                    for (var i = 0; i < self.availableNames.length; i++) {\r\n                        var layer = self.getLayerNodeByName(self.availableNames[i]);\r\n                        if (layer) {\r\n                            layers.push(layer);\r\n                            layers = layers.concat(self.getChildrenLayers(layer));\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    layers = self.wrap.getAllLayerNodes();\r\n                }\r\n            }\r\n\r\n            var filter = this.patternFn(text);\r\n            var re = new RegExp(filter, \"i\");\r\n\r\n            var matches = layers.map(function (ly, ix) {\r\n                delete ly.tcScore;\r\n\r\n                ly.tcPosition = ix;\r\n\r\n                self.wrap.normalizeLayerNode(ly);\r\n\r\n                var title = ly.Title.trim();\r\n                var res = re.exec(title);\r\n                var titleIx = res ? res.index : -1;\r\n                var abstractIx = -1;\r\n                if (ly.Abstract) {\r\n                    var abs = ly.Abstract.trim();\r\n                    var res2 = re.exec(abs);\r\n                    abstractIx = res2 ? res2.index : -1;\r\n                }\r\n\r\n                if (res && title == res[0])\r\n                    ly.tcScore = 20;\r\n                else if (titleIx == 0)\r\n                    ly.tcScore = 15;\r\n                else if (titleIx > -1)\r\n                    ly.tcScore = 10;\r\n                else if (abstractIx == 0)\r\n                    ly.tcScore = 5;\r\n                else if (abstractIx > -1)\r\n                    ly.tcScore = 1;\r\n\r\n                if (ly.tcScore)\r\n                    return ly;\r\n                else\r\n                    return null;\r\n            })\r\n                .filter(function (elto) {\r\n                    return elto != null;\r\n                })\r\n                .sort(function (a, b) {\r\n                    if (b.tcScore === a.tcScore) {\r\n                        //si la puntuación es la misma reordenamos por título\r\n                        var titleA = TC.Util.replaceSpecialCharacters(a.Title);\r\n                        var titleB = TC.Util.replaceSpecialCharacters(b.Title);\r\n                        if (titleA < titleB) return -1;\r\n                        if (titleA > titleB) return 1;\r\n                        return 0;\r\n                    }\r\n                    else\r\n                        return b.tcScore - a.tcScore;\r\n                });\r\n\r\n            this.lastPattern = text;\r\n            this.lastMatches = matches;\r\n\r\n            return matches;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n\r\n    };\r\n        \r\n\r\n    layerProto.getGetCapabilitiesUrl = function () {\r\n        const self = this;\r\n        var url;\r\n        const serviceUrl = self.url;\r\n        const params = {};\r\n        if (self.type === TC.Consts.layerType.WMTS) {\r\n            if (self.options.encoding === TC.Consts.WMTSEncoding.RESTFUL) {\r\n                var suffix = '/1.0.0/WMTSCapabilities.xml';\r\n                const suffixIdx = serviceUrl.indexOf(suffix);\r\n                if (suffixIdx < 0 || suffixIdx < serviceUrl.length - suffix.length) {\r\n                    if (serviceUrl[serviceUrl.length - 1] === '/') {\r\n                        suffix = suffix.substr(1);\r\n                    }\r\n                    url = serviceUrl + suffix;\r\n                }\r\n                else {\r\n                    url = serviceUrl;\r\n                }\r\n            }\r\n            else {\r\n                url = serviceUrl;\r\n                params.SERVICE = 'WMTS';\r\n                params.VERSION = '1.0.0';\r\n                params.REQUEST = 'GetCapabilities';\r\n            }\r\n        }\r\n        else {\r\n            url = serviceUrl;\r\n            params.SERVICE = 'WMS';\r\n            params.VERSION = '1.3.0';\r\n            params.REQUEST = 'GetCapabilities';\r\n        }\r\n        url = url + '?' + TC.Util.getParamString(TC.Util.extend(params, self.queryParams));\r\n        return url;\r\n    };\r\n\r\n    layerProto.getPreferredInfoFormat = function () {\r\n        const layer = this;\r\n        var result = null;\r\n\r\n        const infoFormats = layer.wrap.getInfoFormats();\r\n        if (infoFormats) {\r\n            for (var i = 0; i < TC.wrap.layer.Raster.infoFormatPreference.length; i++) {\r\n                var format = TC.wrap.layer.Raster.infoFormatPreference[i];\r\n                if (infoFormats.indexOf(format) >= 0) {\r\n                    result = format;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Carga la imagen de leyenda de una capa por POST.\r\n     */\r\n    layerProto.getLegendGraphicImage = function () {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            //Si ya hemos hecho esta consulta previamente, retornamos la respuesta\r\n            if (self.options.params.base64LegendSrc) {\r\n                return resolve(self.options.params.base64LegendSrc);\r\n            }\r\n\r\n            if (typeof window.btoa === 'function') {\r\n                var name = self.names[0];\r\n                var info = self.wrap.getInfo(name);\r\n                var xhr = new XMLHttpRequest();\r\n                var url = info.legend[0].src.split('?'); // Separamos los parámetros de la raíz de la URL\r\n                var dataEntries = url[1].split(\"&\"); // Separamos clave/valor de cada parámetro\r\n                var params = self.options.params.sld_body ? \"sld_body=\" + self.options.params.sld_body : '';\r\n\r\n                for (var i = 0; i < dataEntries.length; i++) {\r\n                    var chunks = dataEntries[i].split('=');\r\n\r\n                    if (chunks && chunks.length > 1 && chunks[1]) {\r\n                        params += \"&\" + dataEntries[i];\r\n                    }\r\n                }\r\n                if (self.options.params.env) {\r\n                    params += \"&\" + self.options.params.env;\r\n                }\r\n\r\n                xhr.open('POST', url[0], true);\r\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\r\n                xhr.responseType = 'arraybuffer';\r\n                xhr.onload = function (e) {\r\n                    if (this.status === 200) {\r\n                        var uInt8Array = new Uint8Array(this.response);\r\n                        var i = uInt8Array.length;\r\n                        var binaryString = new Array(i);\r\n                        while (i--) {\r\n                            binaryString[i] = String.fromCharCode(uInt8Array[i]);\r\n                        }\r\n                        var data = binaryString.join('');\r\n                        var type = xhr.getResponseHeader('content-type');\r\n                        if (type.indexOf('image') === 0) {\r\n                            var imageSrc;\r\n                            imageSrc = 'data:' + type + ';base64,' + window.btoa(data);\r\n                            self.options.params.base64LegendSrc = imageSrc; //Cacheamos la respuesta\r\n                            resolve(imageSrc);\r\n                        }\r\n                    }\r\n                };\r\n                xhr.send(params);\r\n            } else {\r\n                reject(Error(\"Función window.btoa no soportada por el navegador\"));\r\n            }\r\n        });\r\n    };\r\n\r\n    layerProto.getUrl = function (src) {\r\n        var self = this;\r\n\r\n        return src;\r\n    };\r\n\r\n    // GLS: Según MDN: https://developer.mozilla.org/es/docs/Web/API/WebGL_API/Tutorial/Wtilizando_texturas_en_WebGL\r\n    //    Note: Es importante señalar que la carga de texturas en WebGL sigue reglas de dominio-cruzado; \r\n    //          Es decir, sólo puede cargar texturas de sitios para los que su contenido tiene aprobación de CORS.\r\n\r\n    // Usamos el mismo método que para el capabilities ya que la carga de texturas es igual de restrictiva.\r\n    layerProto.getWebGLUrl = function (src, location) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            var _src = !TC.Util.isSecureURL(src) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(src) : src;\r\n\r\n            if (self.ignoreProxification) {\r\n                resolve(_src);\r\n            } else {\r\n                const options = {\r\n                    exportable: true,\r\n                    ignoreProxification: self.ignoreProxification\r\n                };\r\n\r\n                self.toolProxification.fetchImage(_src, options).then(function () {\r\n                    let action = self.toolProxification.cacheHost.getAction(_src, options);\r\n                    if (action) {\r\n                        action.then(function (cache) {\r\n                            if (cache && cache.action) {\r\n                                resolve(cache.action.call(self.toolProxification, _src));\r\n                            }\r\n                        });\r\n                    } else {\r\n                        reject('No action to ' + _src);\r\n                    }\r\n                }).catch(function (e) {\r\n                    reject(e);\r\n                });\r\n            }\r\n\r\n            //// IGN francés tiene cabeceras CORS menos en las excepciones que las devuelve en XML así que si da error cargamos imagen en blanco sin hacer más\r\n            //if (self.ignoreProxification) {\r\n            //    setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            //    return;\r\n            //}\r\n\r\n            //return self.capabilitiesUrl_.call(self, !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(url) : url);        \r\n        });\r\n    };\r\n\r\n    layerProto.getFeatureUrl = function (url) {\r\n        var self = this;\r\n\r\n        return self.toolProxification.fetch(url).then(function () {\r\n            return self.toolProxification.cacheHost.getAction(url)\r\n                .then(function (cache) {\r\n                    return cache.action.call(self.toolProxification, url);\r\n                })\r\n                .catch(function (error) {\r\n                    return Promise.reject(error);\r\n                })\r\n        }).catch(function (error) {\r\n            return Promise.reject(error);\r\n        });\r\n    };\r\n\r\n    // GLS:\r\n    // Busca en capas cargadas la 1º capa que tenga la misma instancia de capabilities. \r\n    // Recibe una función como parámetro opcional, la cual es invocada para añadir más condiciones en la búsqueda de una capa hermana.\r\n    layerProto.getSiblingLoadedLayer = function (dynamicStatement) {\r\n        var self = this;\r\n\r\n        if (!self.map) {\r\n            return null;\r\n        } else {\r\n            var layers = self.map.baseLayers.slice(0).concat(self.map.workLayers.slice(0));\r\n\r\n            const matchingLayer = layers.filter(function (elem) {\r\n                return (elem.type === TC.Consts.layerType.WMS ||\r\n                    elem.type === TC.Consts.layerType.WMTS) &&\r\n                    (elem.capabilities === self.capabilities || elem.url === self.url) &&\r\n                    (TC.Util.isFunction(dynamicStatement) ? dynamicStatement(elem) : true);\r\n            })[0];\r\n\r\n            return matchingLayer || null;\r\n        }\r\n    };\r\n\r\n    layerProto.getImageLoad = function (image, src, location) {\r\n        const self = this;\r\n\r\n        const setSRC = function (data) {\r\n            const img = image.getImage();\r\n\r\n            if (!TC.Util.isSameOrigin(data.src)) {\r\n                if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                    img.crossOrigin = data.crossOrigin !== null ? data.crossOrigin : \"anonymous\";\r\n                }\r\n            }\r\n\r\n            // GLS: si establecemos por atributo directamente no actualiza, mediante setAttribute funciona siempre.\r\n            img.setAttribute(\"src\", data.src);\r\n            img.onload = function () {\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n            };\r\n            img.onerror = function (error) {\r\n                img.setAttribute(\"src\", TC.Consts.BLANK_IMAGE);\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n            };\r\n        };\r\n\r\n        // Viene sin nombre desde el control TOC, si es así lo ignoramos.\r\n        if (self.names && self.names.length > 0) {\r\n\r\n            const errorFn = function (error) {\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            };\r\n\r\n            // comprobamos z/x/y contra el matrixset del capabilities para evitar peticiones 404\r\n            if (self.type === TC.Consts.layerType.WMTS) {\r\n                var z, x, y;\r\n                if (self.encoding != \"KVP\") {\r\n                    var _src = src.replace('.' + self.format.split('/')[1], '');\r\n                    var parts = _src.split('/').slice(_src.split('/').length - 3).map(function (elm) { return parseInt(elm); });\r\n                    z = parts[0];\r\n                    x = parts[1];\r\n                    y = parts[2];\r\n                } else {\r\n                    var parts = /.*TileMatrix=(\\d*)&TileCol=(\\d*)&TileRow=(\\d*)/i.exec(src);\r\n                    if (parts && parts.length == 4) {\r\n                        parts = parts.slice(1).map(function (elm) { return parseInt(elm); });\r\n                        z = parts[0];\r\n                        x = parts[2];\r\n                        y = parts[1];\r\n                    }\r\n                }\r\n\r\n                if (z && x && y) {\r\n                    var wmtsOptions = self.wrap.getWMTSLayer();\r\n                    if (wmtsOptions) {\r\n                        var matrixSet = wmtsOptions.TileMatrixSetLink.filter(function (elm) { return elm.TileMatrixSet === self.matrixSet; });\r\n                        if (matrixSet.length > 0) {\r\n\r\n                            if (matrixSet[0].TileMatrixSetLimits.length > 0) {\r\n                                var matrixSetLimits = matrixSet[0].TileMatrixSetLimits.sort(function (a, b) {\r\n                                    if (parseInt(a.TileMatrix) > parseInt(b.TileMatrix))\r\n                                        return 1;\r\n                                    else if (parseInt(a.TileMatrix) < parseInt(b.TileMatrix))\r\n                                        return -1;\r\n                                    else return 0;\r\n                                });\r\n\r\n                                var level = matrixSetLimits[z];\r\n                                if (level && self.map && self.map.on3DView) {\r\n                                    if (!(level.MinTileRow <= x && level.MaxTileRow >= x && level.MinTileCol <= y && level.MaxTileCol >= y)) {\r\n                                        console.log('Prevenimos petición fuera de matrix set, cargamos imagen en blanco');\r\n                                        setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            _get$events.call(self).trigger(TC.Consts.event.BEFORETILELOAD, { tile: image });\r\n\r\n            var params = \"\";\r\n            var isPOST = self.options.method === \"POST\";\r\n            if (isPOST) {\r\n                var url = src.split('?');\r\n                params = url[1].split(\"&\").filter(function (param) {\r\n                    const values = param.split('=');\r\n                    // eliminamos los valores en blanco y el parámetro layers\r\n                    return values.length > 1 && values[1].trim().length > 0 && values[0].trim().toLowerCase() !== \"layers\";\r\n                }).join('&');\r\n\r\n                self.toolProxification.fetchImageAsBlob(url[0], {\r\n                    type: \"POST\",\r\n                    data: params,\r\n                    contentType: \"application/x-www-form-urlencoded\"\r\n                }).then(function (blob) {\r\n                    const imageUrl = URL.createObjectURL(blob);\r\n                    const img = image.getImage();\r\n                    img.onload = function (evt) {\r\n                        URL.revokeObjectURL(imageUrl);\r\n                    };\r\n                    setSRC({ src: imageUrl });\r\n                }).catch(errorFn);\r\n\r\n            } else {\r\n                if (!self.ignoreProxification) {\r\n                    self.toolProxification.fetchImage(src, { exportable: !self.map || (self.map && self.map.mustBeExportable) }).then(function (img) {\r\n                        setSRC(img);\r\n                    }).catch(errorFn);\r\n                } else {\r\n                    setSRC({ src: src });\r\n                    var img = image.getImage();\r\n\r\n                    if (!TC.Util.isSameOrigin(src)) {\r\n                        if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                            img.crossOrigin = \"anonymous\";\r\n                        }\r\n                    }\r\n\r\n                    img.onload = function () {\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n                    };\r\n                    img.onerror = function (error) {\r\n                        img.src = TC.Consts.BLANK_IMAGE;\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                    };\r\n\r\n                    img.src = self.names.length ? src : TC.Consts.BLANK_IMAGE;\r\n                }\r\n            }\r\n        } else {\r\n            setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            // lanzamos el evento para gestionar el loading\r\n            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n        }\r\n    };\r\n\r\n    var _get$events = function () {\r\n        const self = this;\r\n        if (self.wrap && self.wrap.$events) {\r\n            return self.wrap.$events;\r\n        }\r\n        return null;\r\n    };\r\n    layerProto.getWFSURL = async function () {\r\n        const self = this;\r\n        if (_urlWFS[self.options.url]) return await _urlWFS[self.options.url];\r\n        var url = new URL(self.url, document.location.href);\r\n        url.search = new URLSearchParams({ request: 'DescribeLayer', service: \"WMS\", version: \"1.1.1\", Layers: self.layerNames instanceof Array ? self.layerNames[0] : self.layerNames, outputFormat: \"application/json\" });\r\n        return _urlWFS[self.options.url] = new Promise(async function (resolve, reject) {\r\n            try {\r\n                var response = await self.toolProxification.fetch(url.toString(), {\r\n                    method: \"GET\"\r\n\r\n                });\r\n                if (response.contentType.startsWith(\"application/json\")) {\r\n                    var data = JSON.parse(response.responseText).layerDescriptions[0];\r\n                    if (data.owsType !== \"WFS\") {\r\n                        resolve(self.options.url.replace(/wms/gi, \"wfs\"));\r\n                        return;\r\n                    }\r\n                    var _url = data.owsURL.substr(0, (data.owsURL.length + (data.owsURL.endsWith('?') ? -1 : 0)));\r\n                    self.toolProxification.fetch(_url, {\r\n                        method: \"HEAD\"\r\n\r\n                    }).then(function () {\r\n                        resolve(_url);\r\n                    }).catch(function () {\r\n                        resolve(self.options.url.replace(/wms/gi, \"wfs\"));\r\n                    });\r\n                }\r\n                else  {\r\n                    let xmlDoc = new DOMParser().parseFromString(response.responseText, \"text/xml\");\r\n                    let error = xmlDoc.querySelector(\"Exception ExceptionText\") || xmlDoc.querySelector(\"ServiceException\");\r\n                    if (error) {\r\n                        resolve(self.options.url.replace(/wms/gi, \"wfs\"));\r\n                    } else {\r\n                        const layerDescription = xmlDoc.querySelector(\"LayerDescription\");                        \r\n                        resolve(layerDescription ? (layerDescription.getAttribute(\"wfs\") || layerDescription.getAttribute(\"owsURL\") || self.options.url.replace(/wms/gi, \"wfs\")):self.options.url.replace(/wms/gi, \"wfs\"))\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                resolve(self.options.url.replace(/wms/gi, \"wfs\"));\r\n            }\r\n        });\r\n    };\r\n\r\n\r\n    layerProto.getWFSCapabilities = async function () {\r\n        const self = this;        \r\n        return getWFSLayer(await self.getWFSURL()).then(function (layer) {\r\n            return layer.getCapabilitiesPromise();\r\n        });\r\n    };\r\n\r\n    layerProto.getDescribeFeatureTypeUrl = function () {\r\n        const self = this;\r\n        const newUrl = _getWFSURL(self)\r\n\r\n        if (!TC.layer.Vector) {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/layer/Vector');\r\n        }\r\n        if (!wfsLayer || wfsLayer.options.url !== newUrl) {\r\n            wfsLayer = new TC.layer.Vector({\r\n                type: TC.Consts.layerType.WFS,\r\n                url: newUrl,\r\n                stealth: true\r\n            });\r\n        }\r\n        return wfsLayer.getDescribeFeatureTypeUrl(self.options.featureType);\r\n    };\r\n\r\n    layerProto.getFallbackLayer = function () {\r\n        const self = this;\r\n        if (self.fallbackLayer instanceof TC.Layer) {\r\n            return self.fallbackLayer;\r\n        }\r\n        if (self.options.fallbackLayer) {\r\n            var fbLayer = self.options.fallbackLayer;\r\n            if (typeof fbLayer === 'string') {\r\n                const ablCollection = self.map ? self.map.options.availableBaseLayers : TC.Cfg.availableBaseLayers;\r\n                ablCollection.forEach(function (baseLayer) {\r\n                    if (self.options.fallbackLayer === baseLayer.id) {\r\n                        self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, baseLayer, { isBase: true, stealth: true, map: self.map }));\r\n                        self.fallbackLayer.firstOption = self;\r\n                    }\r\n                });\r\n            }\r\n            else if (fbLayer instanceof TC.Layer) {\r\n                self.fallbackLayer = fbLayer;\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            else {\r\n                self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, fbLayer, {\r\n                    id: TC.getUID(),\r\n                    isBase: true,\r\n                    stealth: true,\r\n                    title: layer.title,\r\n                    map: self.map\r\n                }));\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            return self.fallbackLayer;\r\n        }\r\n        return null;\r\n    };\r\n    layerProto.describeFeatureType = async function (layerName) {\r\n        const self = this;\r\n        const newUrl = await self.getWFSURL();\r\n\r\n        return getWFSLayer(newUrl).then(function (layer) {\r\n            return layer.describeFeatureType(layerName || self.layerNames[0]);\r\n        });\r\n    };\r\n\r\n    layerProto.refresh = function () {\r\n        return this.wrap.reloadSource();\r\n    };\r\n\r\n})();\r\nvar esriParser = {\r\n    parse: function (text) {\r\n        var result = [];\r\n        var dom = (new DOMParser()).parseFromString(text, 'text/xml');\r\n        if (dom.documentElement.tagName === 'FeatureInfoResponse') {\r\n            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');\r\n            for (var i = 0, len = fiCollections.length; i < len; i++) {\r\n                var fic = fiCollections[i];\r\n                var layerName = fic.getAttribute('layername');\r\n                var fInfos = fic.getElementsByTagName('FeatureInfo');\r\n                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {\r\n                    var fields = fInfos[j].getElementsByTagName('Field');\r\n                    var attributes = {};\r\n                    for (var k = 0, lenk = fields.length; k < lenk; k++) {\r\n                        var field = fields[k];\r\n                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);\r\n                    }\r\n                    var feature = new ol.Feature(attributes);\r\n                    feature.setId(layerName + '.' + TC.getUID());\r\n                    result.push(feature);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};"]}