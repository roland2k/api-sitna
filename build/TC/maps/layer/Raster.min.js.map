{"version":3,"sources":["layer/Raster.js"],"names":["TC","layer","Layer","syncLoadJS","apiLocation","Consts","BLANK_IMAGE","_urlWFS","capabilitiesPromises","wfsLayer","getWFSLayer","url","Promise","resolve","reject","options","loadJS","Vector","type","layerType","WFS","stealth","_getLayerNodeIndex","treeNode","result","availableNames","indexOf","name","i","len","children","length","_getLayerNamePosition","counter","count","Raster","self","this","tool","Proxification","toolProxification","proxify","_capabilitiesPromise","apply","arguments","wrap","transparent","capabilities","params","layerNames","names","split","Array","isArray","push","hasOwnProperty","undefined","isVisible","sldBody","sld_body","parser","DOMParser","sldBodyToXml","parseFromString","e","error","message","namedLayerElm","Util","getElementByNodeName","textContent","ignorePrefixes","_capabilitiesNodes","_promise","_createOLLayer","ollyr","GROUP","WMTS","createWMTSLayer","join","format","LAYERS","FORMAT","TRANSPARENT","VERSION","version","extend","queryParams","infoFormat","getPreferredInfoFormat","INFO_FORMAT","filter","Filter","getText","querySelector","createWMSLayer","getGetMapUrl","_createWMSLayer","setLayer","Error","id","processedCapabilities","actualUrl","cachePromise","res","rej","onlinePromise","getCapabilitiesOnline","storagePromise","getCapabilitiesFromStorage","then","catch","getCapabilitiesPromise","map","trigger","event","LAYERERROR","reason","_disgregatedLayerNames","setWMTSUrl","inherit","layerProto","prototype","capabilitiesState_","PENDING","DONE","CAPABILITIES_STORE_KEY_PREFIX","getByProxy_","getByUrl_","setVisibility","visible","tree","_cache","visibilityStates","call","_aggregateLayerNodeNames","layerNode","getLayerNodes","idx","firstIdx","nodeNames","elm","getName","reverse","fail","nodeName","splice","_disgregateLayerNames","ln","slice","rootNode","getRootLayerNode","concat","_disgregateLayerName","ancestorVisible","nodeVisible","compareNames","hasEmptyChildren","_extendLayerNameOptions","aggregate","lazy","_combineArray","source","add","rem","a","r","sa","_sortLayerNames","getTree","sort","b","idxa","idxb","_isNameInArray","looseComparison","getLimitedMatrixSet","layerId","matrixId","matrixSet","cap","ret","tset","Contents","TileMatrixSet","elto","Identifier","ly","TileMatrixSetLink","TileMatrixSetLimits","limit","limits","matrix","TileMatrix","combi","matrixIndex","_getLimitedMatrixSet","setLayerNames","getLayer","opts","WMS","_aggregateLayerNames","newParams","_newParams","getParams","BEFOREUPDATEPARAMS","setParams","reset","UPDATEPARAMS","setFilter","oldParams","addLayerNames","ln2a","getDisgregatedLayerNames","removeLayerNames","ln2r","toggleLayerNames","ln2t","currentLayerNames","l","promises","all","arrays","a1","a2","olLayer","isNative","isValidFromNames","getLayerNodeByName","isCompatible","crs","getCompatibleMatrixSets","getCompatibleCRS","includeFallback","fallbackLayer","fbLayer","getFallbackLayer","normalized","getCRSCode","code","reduce","prev","cur","getProjection","getSource","getCode","setProjection","setMatrixSet","mustReproject","isVisibleByScale","nameOrUid","currentScale","_getOgcScale","getResolution","getMetersPerUnit","tileMatrix","getTileMatrix","scaleDenominators","getScaleDenominators","layers","getAllLayerNodes","node","parseInt","toString","parseFloat","some","nodeLayer","isVisibleByName","getWMTSLayer","__getLayerPath","capabilitiesNode","n","layerNodes","fastUnshift","path","_getLayerPath","getTreeNode","forceAddition","isRootNode","uid","key","getUID","child","title","Title","abstract","Abstract","metadata","MetadataURL","isBase","isDefault","thumbnail","legend","src","getVisibility","inverseTree","getLegend","hideTree","cache","_setNodeState","_result","visibility","NOT_VISIBLE","hasVisible","hasNotVisible","VISIBLE","HAS_VISIBLE","visibilityState","_sortTree","n1","n2","customLegend","setNodeVisibility","findNode","_getNames","getNodeVisibility","getNodePath","layerName","ignorePrefix","_getPath","getPath","getServiceType","getIdentifier","nodes","getChildrenLayers","_recursiveFn","lyr","arr","lc","idx1","idx2","substr","getResolutions","setResolutions","resolutions","getExtent","formatDescriptions","getInfo","info","forEach","md","formatDescription","getLocaleString","locale","getSimpleMimeType","searchSubLayers","text","patternFn","t","replace","lastPattern","lastMatches","re","RegExp","matches","ix","tcScore","tcPosition","normalizeLayerNode","trim","exec","titleIx","index","abstractIx","abs","res2","titleA","replaceSpecialCharacters","titleB","getGetCapabilitiesUrl","serviceUrl","encoding","WMTSEncoding","RESTFUL","suffix","suffixIdx","SERVICE","REQUEST","getParamString","infoFormats","getInfoFormats","infoFormatPreference","getLegendGraphicImage","base64LegendSrc","window","btoa","xhr","XMLHttpRequest","dataEntries","chunks","env","open","setRequestHeader","responseType","onload","status","uInt8Array","Uint8Array","response","binaryString","String","fromCharCode","data","getResponseHeader","imageSrc","send","getUrl","getWebGLUrl","location","_src","isSecureURL","toAbsolutePath","getBySSL_","ignoreProxification","exportable","fetchImage","cacheHost","getAction","action","getFeatureUrl","fetch","getSiblingLoadedLayer","dynamicStatement","baseLayers","workLayers","elem","isFunction","getImageLoad","image","setSRC","img","getImage","isSameOrigin","mustBeExportable","crossOrigin","setAttribute","_get$events","TILELOAD","tile","onerror","TILELOADERROR","statusText","z","x","y","parts","wmtsOptions","level","on3DView","MinTileRow","MaxTileRow","MinTileCol","MaxTileCol","console","log","BEFORETILELOAD","method","param","values","toLowerCase","fetchImageAsBlob","contentType","blob","imageUrl","URL","createObjectURL","evt","revokeObjectURL","$events","getWFSURL","async","document","href","search","URLSearchParams","request","service","Layers","outputFormat","startsWith","JSON","parse","responseText","layerDescriptions","_url","owsURL","endsWith","xmlDoc","err","getWFSCapabilities","getDescribeFeatureTypeUrl","newUrl","_getWFSURL","featureType","availableBaseLayers","Cfg","baseLayer","firstOption","describeFeatureType","refresh","reloadSource","esriParser","dom","documentElement","tagName","fiCollections","getElementsByTagName","fic","getAttribute","fInfos","j","lenj","fields","attributes","k","lenk","field","getElementText","feature","ol","Feature","setId"],"mappings":"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","sourcesContent":["\r\nTC.layer = TC.layer || {};\r\n\r\nif (!TC.Layer) {\r\n    TC.syncLoadJS(TC.apiLocation + 'TC/Layer');\r\n}\r\n\r\nTC.Consts.BLANK_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7';\r\n\r\nconst _urlWFS = {};\r\n\r\n(function () {\r\n\r\n    var capabilitiesPromises = {};\r\n\r\n    var wfsLayer = null;//capa WFS de respaldo\r\n\r\n    const getWFSLayer = function (url) {\r\n        return new Promise(function (resolve, reject) {\r\n            if (!wfsLayer || wfsLayer.options.url !== url) {\r\n                TC.loadJS(\r\n                    !TC.layer.Vector,\r\n                    TC.apiLocation + 'TC/layer/Vector',\r\n                    function () {\r\n                        wfsLayer = new TC.layer.Vector({\r\n                            type: TC.Consts.layerType.WFS,\r\n                            url: url,\r\n                            stealth: true\r\n                        });\r\n                        resolve(wfsLayer);\r\n                    }\r\n                );\r\n            }\r\n            else {\r\n                resolve(wfsLayer);\r\n            }\r\n        });\r\n    };\r\n    \r\n    const _createWMSLayer = function (layer) {\r\n\r\n        var layerNames = Array.isArray(layer.names) ? layer.names.join(',') : layer.names;\r\n        var format = layer.options.format;\r\n        var options = layer.options;\r\n\r\n        var params = {\r\n            LAYERS: layerNames,\r\n            FORMAT: format,\r\n            TRANSPARENT: layer.transparent,\r\n            VERSION: layer.capabilities.version || '1.3.0'\r\n        };\r\n\r\n        if (layer.params) {\r\n            TC.Util.extend(params, layer.params);\r\n        }\r\n\r\n        if (layer.queryParams) {\r\n            TC.Util.extend(params, layer.queryParams);\r\n        }\r\n\r\n        var infoFormat = layer.getPreferredInfoFormat();\r\n        if (infoFormat !== null) {\r\n            params.INFO_FORMAT = infoFormat;\r\n        }\r\n        //filtro GML o CQL\r\n        if (options.filter) {\r\n            //primero miramos si es un objeto TC.filter\r\n            if (options.filter instanceof TC.filter.Filter) {\r\n                params[\"filter\"] = options.filter.getText();\r\n            }\r\n            //se puede parsear a XML, asumimos que es GML\r\n            else if (!new DOMParser().parseFromString(options.filter, 'text/xml').querySelector(\"parsererror\")) {\r\n                params[\"filter\"] = options.filter;\r\n            }\r\n            //Si no, asumimos que es CQL\r\n            else {\r\n                params[\"cql_filter\"] = options.filter;\r\n            }\r\n        }\r\n\r\n        return layer.wrap.createWMSLayer(layer.getGetMapUrl(), params, options);\r\n    };\r\n\r\n    const _createWMTSLayer = function (layer) {\r\n        return layer.wrap.createWMTSLayer(layer.options);\r\n    };\r\n\r\n    const _getLayerNodeIndex = function _getLayerNodeIndex(layer, treeNode) {\r\n\r\n        var result = layer.availableNames.indexOf(treeNode.name);\r\n        if (result === -1) {\r\n            for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n                result = _getLayerNodeIndex(layer, treeNode.children[i]);\r\n                if (result !== -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    const _sortTree = function _sortTree(layer, treeNode) {\r\n        var _sortFunction = function (n1, n2) {\r\n            return _getLayerNodeIndex(layer, n2) - _getLayerNodeIndex(layer, n1);\r\n        }\r\n        treeNode.children.sort(_sortFunction);\r\n        for (var i = 0, len = treeNode.children.length; i < len; i++) {\r\n            _sortTree(layer, treeNode.children[i]);\r\n        }\r\n    };\r\n\r\n    const _getLayerNamePosition = function _getLayerNamePosition(treeNode, name, counter) {\r\n        var result = false;\r\n        counter.count = counter.count + 1;\r\n        if (treeNode.name === name) {\r\n            result = true;\r\n        }\r\n        else {\r\n            // Las capas se ordenan de arriba a abajo en el árbol, por tanto hay que recorrer la lista del revés\r\n            for (var i = treeNode.children.length - 1; i >= 0; i--) {\r\n                if (_getLayerNamePosition(treeNode.children[i], name, counter)) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Opciones de nombre de capa.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.LayerNameOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Siempre que sea posible se reemplaza en la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} los nombres de capa por los nombres de las capas de grupo que las contienen.\r\n     * @property aggregate\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n    /**\r\n     * Determina si la capa nativa se actualiza en cuanto cambia la lista TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}} (valor <code>false</code>) \r\n     * o se espera a que la capa se actualice (valor <code>true</code>).\r\n     * @property lazy\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n    /**\r\n     * Determina si la capa la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/availableNames:property\"}}{{/crossLink}} (valor <code>false</code>) se restablece \r\n     * al actualizar la propiedad TC.layer.Raster.{{#crossLink \"TC.layer.Raster/names:property\"}}{{/crossLink}}.\r\n     * @property reset\r\n     * @type boolean|undefined\r\n     */\r\n\r\n    /**\r\n     * Opciones de capa raster.\r\n     * Esta clase no tiene constructor.\r\n     * @class TC.cfg.RasterOptions\r\n     * @extend TC.cfg.LayerOptions\r\n     * @static\r\n     */\r\n    /**\r\n     * Tipo de capa.\r\n     * @property type\r\n     * @type TC.consts.LayerType\r\n     * @default TC.Consts.layerType.WMS\r\n     */\r\n    /**\r\n     * URL del servicio OGC que define la capa.\r\n     * @property url\r\n     * @type string\r\n     */\r\n    /**\r\n     * Indica si la capa tiene transparencia.\r\n     * @property transparent\r\n     * @type boolean|undefined\r\n     */\r\n    /**\r\n     * Lista separada por comas de los nombres de capa del servicio OGC.\r\n     * @property layerNames\r\n     * @type string|undefined\r\n     */\r\n    /**\r\n     * Nombre de grupo de matrices del servicio WMTS. Propiedad obligatoria para capas de tipo WMTS.\r\n     * @property matrixSet\r\n     * @type string|undefined\r\n     */\r\n    /**\r\n     * Filtro GML o CQL de la capa. Funciona unicamente con capas WMS. Se intenta parsear a GML y si no sepuede se asume que es CQL\r\n     * @property filter\r\n     * @type string|undefined\r\n     */\r\n\r\n    /**\r\n     * Capa de tipo raster, como la de un WMS o un WMTS.\r\n     * @class TC.layer.Raster\r\n     * @extends TC.Layer\r\n     * @constructor\r\n     * @async\r\n     * @param {TC.cfg.LayerOptions} [options] Objeto de opciones de configuración de la capa.\r\n     */\r\n    TC.layer.Raster = function () {\r\n        var self = this;\r\n\r\n        if (!TC.tool || !TC.tool.Proxification) {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/tool/Proxification');\r\n        }\r\n\r\n        this.toolProxification = new TC.tool.Proxification(TC.proxify);\r\n\r\n        //esta promise se resolverá cuando el capabilities esté descargado y parseado\r\n        //se utiliza para saber cuándo está listo el capabilities en los casos en los que se instancia el layer pero no se añade al mapa\r\n        //porque la forma habitual de detectar esto es por los eventos del mapa (que en esos casos no saltarán)\r\n        this._capabilitiesPromise = null;\r\n\r\n        TC.Layer.apply(self, arguments);\r\n\r\n        self.wrap = new TC.wrap.layer.Raster(self);\r\n\r\n        /**\r\n         * Indica si la capa tiene transparencia.\r\n         * @property transparent\r\n         * @type boolean\r\n         * @default true\r\n         */\r\n        self.transparent = (self.options.transparent === false) ? false : true;\r\n\r\n        /**\r\n         * URL del servicio al que pertenenece la capa.\r\n         * @property url\r\n         * @type string\r\n         */\r\n        self.url = self.options.url;\r\n        self.capabilities = TC.capabilities[self.url];\r\n\r\n        self.params = self.options.params;\r\n        /**\r\n         * Lista de nombres de capa.\r\n         * @property names\r\n         * @type array\r\n         * @default []\r\n         */\r\n        /**\r\n         * Lista de nombres de capa disponibles inicialmente.\r\n         * @property availableNames\r\n         * @type array\r\n         * @default []\r\n         */\r\n        if (typeof self.options.layerNames === 'string') {\r\n            self.names = self.availableNames = self.options.layerNames.split(',');\r\n        }\r\n        else {\r\n            self.names = [];\r\n            self.availableNames = [];\r\n            if (Array.isArray(self.options.layerNames)) {\r\n                for (var i = 0; i < self.options.layerNames.length; i++) {\r\n                    var name = self.options.layerNames[i];\r\n                    if (typeof name === 'string') {\r\n                        self.names.push(name);\r\n                        self.availableNames.push(name);\r\n\r\n                    }\r\n                    else if (name.hasOwnProperty('name')) {\r\n                        self.availableNames.push(name.name);\r\n                        if (name.isVisible === undefined || name.isVisible) {\r\n                            self.names.push(name.name);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Si no se encuentran nombres de capas, se buscan en el parámetro sld_body. Este parámetro es utilizado\r\n                // cuando queremos instanciar una capa pasándole un SLD en la petición\r\n                var sldBody = self.options.params ? self.options.params.sld_body : null;\r\n\r\n                if (sldBody) {\r\n                    const parser = new DOMParser();\r\n                    var sldBodyToXml;\r\n                    try {\r\n                        sldBodyToXml = parser.parseFromString(sldBody, 'text/xml');\r\n                    }\r\n                    catch (e) {\r\n                        TC.error(e.message);\r\n                        sldBodyToXml = null;\r\n                    }\r\n                    if (sldBodyToXml) {\r\n                        var namedLayerElm = TC.Util.getElementByNodeName(sldBodyToXml, 'sld:NamedLayer');\r\n                        if (namedLayerElm && namedLayerElm.length > 0) {\r\n                            var names = TC.Util.getElementByNodeName(namedLayerElm[0], 'sld:Name');\r\n\r\n                            if (names && names.length > 0) {\r\n                                var name = names[0].textContent;\r\n                                self.names.push(name);\r\n                                self.availableNames.push(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        self.ignorePrefixes = self.options.ignorePrefixes === undefined ? true : self.options.ignorePrefixes;\r\n\r\n        self._capabilitiesNodes = {};\r\n\r\n        /**\r\n      * Árbol del documento de capabilities del servicio.\r\n      * @property capabilities\r\n      * @type object\r\n      */\r\n        self.wrap._promise = new Promise(function (resolve, reject) {\r\n            /*\r\n             *  _createOLLayer: Crea la capa nativa correspondiente según el tipo\r\n             */\r\n            var _createOLLayer = function () {\r\n                var ollyr;\r\n                if (!self.wrap.layer) {\r\n                    switch (self.type) {\r\n                        case TC.Consts.layerType.GROUP:\r\n                            break;\r\n                        case TC.Consts.layerType.WMTS:\r\n                            ollyr = _createWMTSLayer(self);\r\n                            break;\r\n                        default:\r\n                            ollyr = _createWMSLayer(self);\r\n                            break;\r\n                    }\r\n                    self.wrap.setLayer(ollyr);\r\n                    if (ollyr) {\r\n                        resolve(ollyr);\r\n                    }\r\n                    else {\r\n                        reject(Error('Could not create native layer for \"' + self.id + '\"'));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const processedCapabilities = function (capabilities) {\r\n                // Si existe el capabilities no machacamos, porque provoca efectos indeseados en la gestión de capas.\r\n                // En concreto, se regeneran los UIDs de capas, como consecuencia los controles de la API interpretan como distintas capas que son la misma.\r\n                self.capabilities = self.capabilities || capabilities;\r\n\r\n                var actualUrl = self.getGetMapUrl();\r\n                TC.capabilities[self.options.url] = TC.capabilities[self.options.url] || capabilities;\r\n                TC.capabilities[actualUrl] = TC.capabilities[actualUrl] || capabilities;\r\n\r\n                _createOLLayer();\r\n            };\r\n\r\n            if (self.capabilities) {\r\n                processedCapabilities(self.capabilities);\r\n                self._capabilitiesPromise = Promise.resolve(self.capabilities);\r\n                return;\r\n            }\r\n\r\n            const cachePromise = capabilitiesPromises[self.url];\r\n            capabilitiesPromises[self.url] = self._capabilitiesPromise = cachePromise || new Promise(function (res, rej) {\r\n                const onlinePromise = self.getCapabilitiesOnline();\r\n                const storagePromise = self.getCapabilitiesFromStorage();\r\n\r\n                onlinePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function (error) {\r\n                        storagePromise.catch(function () {\r\n                            rej(error);\r\n                        });\r\n                    });\r\n                storagePromise\r\n                    .then(function (capabilities) {\r\n                        res(capabilities);\r\n                    })\r\n                    .catch(function () {\r\n                        onlinePromise.catch(function (error) {\r\n                            rej(error);\r\n                        });\r\n                    });\r\n            });\r\n\r\n            self.getCapabilitiesPromise()\r\n                .then(function (capabilities) {\r\n                    processedCapabilities(capabilities);\r\n                })\r\n                .catch(function (error) {\r\n                    if (self.map) {\r\n                        self.map.trigger(TC.Consts.event.LAYERERROR, { layer: self, reason: 'couldNotGetCapabilities' });\r\n                    }\r\n                    reject(error);\r\n                });\r\n        });\r\n\r\n        self._disgregatedLayerNames = null;\r\n\r\n        if (TC.Consts.layerType.WMTS == self.type) {\r\n            self.wrap.setWMTSUrl();\r\n        }\r\n    };\r\n\r\n    TC.inherit(TC.layer.Raster, TC.Layer);\r\n\r\n    var layerProto = TC.layer.Raster.prototype;\r\n        \r\n    layerProto.capabilitiesState_ = {\r\n        PENDING: 0,\r\n        DONE: 1\r\n    };\r\n\r\n    layerProto.CAPABILITIES_STORE_KEY_PREFIX = 'TC.capabilities.';\r\n\r\n    layerProto.getByProxy_ = function (url) {\r\n        return TC.proxify(url);\r\n    };\r\n    \r\n\r\n    layerProto.getByUrl_ = function (url) {\r\n        return url;\r\n    };\r\n\r\n\r\n    layerProto.setVisibility = function (visible) {\r\n        var layer = this;\r\n        layer.tree = null;\r\n        layer._cache.visibilityStates = {\r\n        };\r\n        TC.Layer.prototype.setVisibility.call(layer, visible);\r\n    };\r\n\r\n    /*\r\n     *  _getLimitedMatrixSet: devuelve un array de tileMatrixSets limitados por su correspondiente TileMatrixSetLimits (si es que lo tiene)\r\n     */\r\n    var _getLimitedMatrixSet = function (layer) {\r\n        var layerId = layer.layerNames;\r\n        var matrixId = layer.matrixSet;\r\n        var cap = layer.capabilities;\r\n\r\n        var ret = [];\r\n\r\n        var tset = cap.Contents.TileMatrixSet.filter(function (elto) {\r\n            return elto.Identifier == matrixId;\r\n        });\r\n        if (tset.length) {\r\n            tset = tset[0];\r\n            var ly = cap.Contents.Layer.filter(function (elto) { return elto.Identifier == layerId; })[0];\r\n            if (ly.TileMatrixSetLink && ly.TileMatrixSetLink.length && ly.TileMatrixSetLink[0].TileMatrixSetLimits) {\r\n                var limit, limits = ly.TileMatrixSetLink[0].TileMatrixSetLimits;\r\n                for (var i = 0; i < limits.length; i++) {\r\n                    limit = limits[i];\r\n                    var matrix = tset.TileMatrix.filter(function (elto) {\r\n                        return elto.Identifier == limit.TileMatrix\r\n                    });\r\n                    if (matrix.length) {\r\n                        var combi = TC.Util.extend({ matrixIndex: tset.TileMatrix.indexOf(matrix[0]) }, matrix[0], limit);\r\n                        ret.push(combi);\r\n                    }\r\n                }\r\n\r\n                return ret;\r\n            }\r\n            else {\r\n                return tset.TileMatrix;\r\n            }\r\n        }\r\n        else\r\n            return null;\r\n    };\r\n\r\n\r\n    /*\r\n     *  _aggregateLayerNames: devuelve un array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen\r\n     */\r\n    var _aggregateLayerNames = function (layer, layerNames) {\r\n        if (layer.type !== TC.Consts.layerType.WMS) {\r\n            return layerNames;\r\n        }\r\n        else {\r\n            var ln = layerNames.slice();\r\n            _aggregateLayerNodeNames(layer, ln, layer.wrap.getRootLayerNode());\r\n            return ln;\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  _aggregateLayerNodeNames: Agrega el array de nombres de capa WMS sustituyendo en la medida de lo posible capas por las capas de grupo que las contienen.\r\n     * Se parte de un nodo del árbol de capas del capabilities\r\n     */\r\n    var _aggregateLayerNodeNames = function _aggregateLayerNodeNames(layer, names, layerNode) {\r\n        var result = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        if (children.length) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                if (_aggregateLayerNodeNames(layer, names, children[i])) {\r\n                    result = true;\r\n                }\r\n            }\r\n\r\n            var nodeNames = children.map(function (elm) {\r\n                return layer.wrap.getName(elm);\r\n            }).reverse();\r\n            var idx, firstIdx;\r\n            var fail = false;\r\n\r\n            firstIdx = idx = names.indexOf(nodeNames[0]);\r\n            if (idx < 0) {\r\n                fail = true;\r\n            }\r\n            else {\r\n                for (var i = 1, len = nodeNames.length; i < len; i++) {\r\n                    if (nodeNames[i] != names[++idx]) {\r\n                        fail = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!fail) {\r\n                var nodeName = layer.wrap.getName(layerNode);\r\n                if (nodeName && nodeNames.length > 1) {\r\n                    names.splice(firstIdx, nodeNames.length, nodeName);\r\n                    result = true;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  _disgregateLayerNames: devuelve un array de nombres de capa WMS con solo capas hoja.\r\n     * Parámetros: objeto de capa, array of strings, nodo de la capa en el capabilities, booleano que dice si esta rama viene de un nodo visible\r\n     */\r\n    var _disgregateLayerNames = function (layer, layerNames) {\r\n        var result = [];\r\n        var ln = layerNames.slice();\r\n        var rootNode = layer.wrap.getRootLayerNode();\r\n        for (var i = 0, len = ln.length; i < len; i++) {\r\n            result = result.concat(_disgregateLayerName(layer, ln[i], rootNode));\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _disgregateLayerName = function _disgregateLayerName(layer, name, layerNode, ancestorVisible) {\r\n        var result = [];\r\n        var nodeName = layer.wrap.getName(layerNode);\r\n        var nodeVisible = layer.compareNames(name, nodeName);\r\n        var hasEmptyChildren = false;\r\n        var children = layer.wrap.getLayerNodes(layerNode);\r\n        for (var i = 0; i < children.length; i++) {\r\n            var names = _disgregateLayerName(layer, name, children[i], ancestorVisible || nodeVisible);\r\n            if (!names.length) {\r\n                hasEmptyChildren = true;\r\n            }\r\n            else {\r\n                result = result.concat(names);\r\n            }\r\n        }\r\n        if (!children.length || hasEmptyChildren) {\r\n            if (ancestorVisible || nodeVisible) {\r\n                result = [nodeName];\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _extendLayerNameOptions = function (options) {\r\n        return TC.Util.extend({ aggregate: true, lazy: false }, options);\r\n    };\r\n\r\n    var _combineArray = function (source, add, rem) {\r\n        var result = [];\r\n        var s, a, r;\r\n        s = source ? source : [];\r\n        a = add ? add : [];\r\n        r = rem ? rem : [];\r\n        var sa = s.concat(a);\r\n        for (var i = 0; i < sa.length; i++) {\r\n            if (sa.indexOf(sa[i]) === i && r.indexOf(sa[i]) === -1) {\r\n                result.push(sa[i]);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var _sortLayerNames = function (layer, layerNames) {\r\n        var ln = (typeof layerNames === 'string') ? layerNames.split(',') : layerNames;\r\n        if (layer.capabilities) {\r\n            var tree = layer.getTree();\r\n            ln.sort(function (a, b) {\r\n                var idxa = {\r\n                    count: 0\r\n                };\r\n                var idxb = {\r\n                    count: 0\r\n                };\r\n                _getLayerNamePosition(tree, a, idxa);\r\n                _getLayerNamePosition(tree, b, idxb);\r\n                return idxa.count - idxb.count;\r\n            });\r\n        }\r\n        return ln;\r\n    };\r\n\r\n    var _isNameInArray = function (layer, name, names, looseComparison) {\r\n        return names.filter(function (elm) {\r\n            return layer.compareNames(name, elm, looseComparison);\r\n        }).length > 0;\r\n    };\r\n\r\n\r\n    layerProto.getLimitedMatrixSet = function () {\r\n        return _getLimitedMatrixSet(this);\r\n    };\r\n\r\n    /**\r\n     * Establece los nombres de capas que deben estar visibles en un WMS. Si la lista está vacía, hace invisible la capa.\r\n     * @method setLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  setLayerNames: sets the visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.setLayerNames = function (layerNames, options) {\r\n        var layer = this;\r\n        return new Promise(function (resolve, reject) {\r\n            layer.wrap.getLayer().then(function () {\r\n                var ln = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                layer.names = ln;\r\n                var opts = _extendLayerNameOptions(options);\r\n                if (opts.aggregate) {\r\n                    ln = _aggregateLayerNames(layer, ln);\r\n                }\r\n                layer._disgregatedLayerNames = null;\r\n                var newParams = {\r\n                    LAYERS: ln.join(','), TRANSPARENT: true\r\n                };\r\n                if (opts.lazy) {\r\n                    var params = layer._newParams || layer.wrap.getParams();\r\n                    layer._newParams = TC.Util.extend(params, newParams);\r\n                }\r\n                else {\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });\r\n                    }\r\n                    layer.tree = null;\r\n                    layer._cache.visibilityStates = {\r\n                    };\r\n                    layer.wrap.setParams(newParams);\r\n                    if (opts.reset || !layer.map) {\r\n                        // layerNames se fija cuando se añade al mapa o cuando reset = true.\r\n                        layer.availableNames = layer.names;\r\n                    }\r\n                    if (layer.map) {\r\n                        layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });\r\n                    }\r\n                }\r\n                resolve(layer.names);\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Establece el atributo filter o CQL_filter de una capa WMS.\r\n     * @method setFilter\r\n     * @param {TC.filter.Filter|string} filter Objeto de tipo TC.filter.Filter, un filtro GML como cadena de texto o filtro CQL como cadena de texto\r\n     */\r\n    /*\r\n     *  setFilter: sets the filter or CQL_filter attribute on WMS layer\r\n     *  Parameters: object instance of  TC.filter.Filter or a GML filter string\r\n     */\r\n    layerProto.setFilter = function (filter) {\r\n        var layer = this;\r\n        return new Promise(function (resolve, reject) {\r\n            layer.wrap.getLayer().then(function () {\r\n                var oldParams = layer.wrap.getParams();\r\n                delete oldParams[\"filter\"];\r\n                delete oldParams[\"cql_filter\"];\r\n\r\n                //if (layer.map) {\r\n                //    layer.map.trigger(TC.Consts.event.BEFOREUPDATEPARAMS, { layer: layer });\r\n                //}\r\n\r\n                //primero miramos si es un objeto TC.filter\r\n                if (filter instanceof TC.filter.Filter) {\r\n                    layer.filter=oldParams[\"filter\"] = filter.getText();\r\n                }\r\n                //se puede parsear a XML, asumimos que es GML\r\n                else if (!new DOMParser().parseFromString(filter, 'text/xml').querySelector(\"parsererror\")) {\r\n                    layer.filter =oldParams[\"filter\"] = filter;\r\n                }\r\n                //Si no, asumimos que es CQL\r\n                else {\r\n                    layer.filter = oldParams[\"cql_filter\"] = filter;\r\n                }\r\n                layer.wrap.setParams(oldParams);\r\n\r\n                //if (layer.map) {\r\n                //    layer.map.trigger(TC.Consts.event.UPDATEPARAMS, { layer: layer });\r\n                //}\r\n                \r\n                resolve(filter);\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Añade capas por nombre a las que ya están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  addLayerNames: adds layer names to the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.addLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2a = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2a = _disgregateLayerNames(self, ln2a);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, ln2a, null)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Elimina capas por nombre de las que están visibles en el WMS\r\n     * @method addLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  removeLayerNames: removes layer names from the set of visible layer names of a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.removeLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2r = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var ln = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2r = _disgregateLayerNames(self, ln2r);\r\n                    ln = self.getDisgregatedLayerNames();\r\n                }\r\n                self.setLayerNames(_sortLayerNames(self, _combineArray(ln, null, ln2r)), options).then(function (names) {\r\n                    resolve(names);\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Toma una lista de nombres de capa WMS y cambia su visibilidad: de visible a no visible y viceversa.\r\n     * @method toggleLayerNames\r\n     * @param {array|string} layerNames Array de strings con los nombres de capa o string con los nombres de capa separados por comas.\r\n     * @param {TC.cfg.LayerNameOptions} [options]\r\n     */\r\n    /*\r\n     *  toggleLayerNames: from a list, adds a layer name when it is not visible or removes a layer name when it is visible in a WMS layer\r\n     *  Parameters: array of string, options object: { aggregate: boolean (default true), lazy: boolean (default false), reset: boolean (default false) }\r\n     *  aggregate option replaces layer name sets by layer group names when possible\r\n     *  lazy option does not update OpenLayers layer\r\n     */\r\n    layerProto.toggleLayerNames = function (layerNames, options) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            self.wrap.getLayer().then(function () {\r\n                var opts = _extendLayerNameOptions(options);\r\n                var ln2t = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                var currentLayerNames = self.wrap.getParams().LAYERS;\r\n                if (opts.aggregate) {\r\n                    ln2t = _disgregateLayerNames(self, ln2t);\r\n                    currentLayerNames = self.getDisgregatedLayerNames();\r\n                }\r\n                var ln2a = [];\r\n                var ln2r = [];\r\n                for (var i = 0; i < ln2t.length; i++) {\r\n                    var l = ln2t[i];\r\n                    if (currentLayerNames.indexOf(l) < 0) {\r\n                        ln2a.push(l);\r\n                    }\r\n                    else {\r\n                        ln2r.push(l);\r\n                    }\r\n                }\r\n                var promises = [];\r\n                if (ln2a.length > 0) {\r\n                    promises.push(self.addLayerNames(ln2a, opts));\r\n                }\r\n                if (ln2r.length > 0) {\r\n                    promises.push(self.removeLayerNames(ln2r, opts));\r\n                }\r\n                Promise.all(promises).then(function (arrays) {\r\n                    const a1 = arrays[0];\r\n                    const a2 = arrays[1];\r\n                    if (a1) {\r\n                        if (a2) {\r\n                            resolve(a1.concat(a2));\r\n                        }\r\n                        else {\r\n                            resolve(a1);\r\n                        }\r\n                    }\r\n                    else {\r\n                        resolve([]);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n     * @method getDisgregatedLayerNames\r\n     * @return {array}\r\n     */\r\n    /*\r\n     *  getDisgregatedLayerNames: returns an array of visible WMS leaf layer names\r\n     */\r\n    layerProto.getDisgregatedLayerNames = function () {\r\n        ///<summary>\r\n        ///Devuelve la lista de nombres de capa WMS hoja correspondientes a las capas visibles.\r\n        ///</summary>\r\n        ///<returns type=\"array\" elementType=\"string\"></returns>\r\n        var self = this;\r\n        var olLayer = self.wrap.layer;\r\n        if (self.wrap.isNative(olLayer) && self.type === TC.Consts.layerType.WMS) {\r\n            if (!self._disgregatedLayerNames) {\r\n                var layerNames = self.wrap.getParams().LAYERS;\r\n                layerNames = Array.isArray(layerNames) ? layerNames : layerNames.split(',');\r\n                self._disgregatedLayerNames = _disgregateLayerNames(self, layerNames);\r\n            }\r\n        }\r\n        else {\r\n            self._disgregatedLayerNames = self.names;\r\n        }\r\n        return self._disgregatedLayerNames.slice();\r\n    };\r\n\r\n    layerProto.isValidFromNames = function () {\r\n        var self = this;\r\n        var result = true;\r\n        for (var i = 0, len = self.names.length; i < len; i++) {\r\n            if (!self.getLayerNodeByName(self.names[i])) {\r\n                result = false;\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.isCompatible = function (crs) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = self.wrap.isCompatible(crs) || self.wrap.getCompatibleMatrixSets(crs).length > 0;\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = self.wrap.isCompatible(crs);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCompatibleCRS = function (options) {\r\n        const self = this;\r\n        options = options || {};\r\n        var result = self.wrap.getCompatibleCRS();\r\n        if (options.includeFallback && self.fallbackLayer) {\r\n            const fbLayer = self.getFallbackLayer();\r\n            if (fbLayer instanceof TC.Layer) {\r\n                result = result.concat(fbLayer.wrap.getCompatibleCRS());\r\n            }\r\n        }\r\n        if (options.normalized) {\r\n            result = result\r\n                .map(function (crs) {\r\n                    return TC.Util.getCRSCode(crs);\r\n                }) // códigos numéricos\r\n                .filter(function (code) {\r\n                    return code !== null;\r\n                })\r\n                .reduce(function (prev, cur) {\r\n                    if (prev.indexOf(cur) < 0) {\r\n                        prev.push(cur);\r\n                    }\r\n                    return prev;\r\n                }, []) // códigos numéricos sin duplicados\r\n                .map(function (code) {\r\n                    return 'EPSG:' + code;\r\n                }); // códigos normalizados\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getProjection = function () {\r\n        var self = this;\r\n\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                return self.wrap.layer.getSource().getProjection().getCode();\r\n            case TC.Consts.layerType.WMS:\r\n                return self.map.crs;\r\n        }\r\n    };\r\n\r\n    layerProto.setProjection = function (options) {\r\n        var self = this;\r\n        options = options || {};\r\n        if (options.crs) {\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    var matrixSet = self.wrap.getCompatibleMatrixSets(options.crs)[0];\r\n                    if (matrixSet) {\r\n                        self.matrixSet = matrixSet;\r\n                        self.wrap.setMatrixSet(matrixSet);\r\n                    }\r\n                    else {\r\n                        self.wrap.setProjection(options);\r\n                    }\r\n                    self.mustReproject = !matrixSet;\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    self.wrap.setProjection(options);\r\n                    self.mustReproject = !self.isCompatible(options.crs);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByScale: return wether the WMS layer is visible at current scale\r\n     *  Parameter: WMS layer name or UID\r\n     */\r\n    layerProto.isVisibleByScale = function (nameOrUid, looseComparison) {\r\n        var self = this;\r\n        var result;\r\n        var _getOgcScale = function () {\r\n            return self.map.wrap.getResolution() * self.map.getMetersPerUnit() / 0.00028; // OGC assumes 0.28 mm / pixel\r\n        };\r\n        var currentScale;\r\n        var i;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                result = false;\r\n                var tileMatrix = self.wrap.getTileMatrix(self.options.matrixSet);\r\n                if (tileMatrix) {\r\n                    currentScale = _getOgcScale();\r\n                    for (i = 0; i < tileMatrix.length; i++) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(tileMatrix[i]);\r\n                        if (scaleDenominators[0] === currentScale) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                result = true;\r\n                var layers = self.wrap.getAllLayerNodes();\r\n                if (layers.length > 0) {\r\n                    currentScale = _getOgcScale();\r\n                    var node;\r\n                    if (parseInt(nameOrUid).toString() === nameOrUid) { // Es numérico, asumimos que es un UID\r\n                        node = self._capabilitiesNodes[nameOrUid];\r\n                    }\r\n                    else {\r\n                        for (i = 0; i < layers.length; i++) {\r\n                            var layer = layers[i];\r\n                            if (self.compareNames(self.wrap.getName(layer), nameOrUid, looseComparison)) {\r\n                                node = layer;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (node) {\r\n                        var scaleDenominators = self.wrap.getScaleDenominators(node);\r\n                        result = !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale);\r\n\r\n                        // GLS: si no es visible miramos si tiene capas hijas y si tiene comprobamos si alguna de ellas es visible a la escala actual.\r\n                        if (!result) {\r\n                            if (node.Layer && node.Layer.length > 0) {\r\n                                return node.Layer.some(function (nodeLayer) {\r\n                                    var scaleDenominators = self.wrap.getScaleDenominators(nodeLayer);\r\n                                    return !(parseFloat(scaleDenominators[1]) > currentScale || parseFloat(scaleDenominators[0]) < currentScale)\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     *  isVisibleByName: return wether the WMS layer is visible because of the requested layer names\r\n     *  Parameter: WMS layer name\r\n     */\r\n    layerProto.isVisibleByName = function (name, looseComparison) {\r\n        var self = this;\r\n        var result = false;\r\n        switch (self.type) {\r\n            case TC.Consts.layerType.WMTS:\r\n                if (self.wrap.getWMTSLayer()) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n                break;\r\n            case TC.Consts.layerType.WMS:\r\n                var _getLayerPath = function _getLayerPath(name) {\r\n                    return __getLayerPath(name, self.wrap.getRootLayerNode());\r\n                };\r\n\r\n                var __getLayerPath = function __getLayerPath(name, capabilitiesNode) {\r\n                    var result = null;\r\n                    var n = self.wrap.getName(capabilitiesNode);\r\n                    if (self.compareNames(n, name, looseComparison)) {\r\n                        result = [n];\r\n                    }\r\n                    else {\r\n                        var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                        for (var i = 0; i < layerNodes.length; i++) {\r\n                            var item = layerNodes[i];\r\n                            var r = __getLayerPath(name, item);\r\n                            if (r) {\r\n                                TC.Util.fastUnshift(r, n);\r\n                                result = r;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    return result;\r\n                };\r\n\r\n                var path = _getLayerPath(name);\r\n                if (path) {\r\n                    for (var i = 0; i < path.length; i++) {\r\n                        if (_isNameInArray(self, path[i], self.names)) {\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getTree = function () {\r\n        var self = this;\r\n        \r\n        var result = self.tree;\r\n\r\n        var addChild = function (node, child) {\r\n            if (self.options.inverseTree) {\r\n                // Versión rápida de unshift\r\n                TC.Util.fastUnshift(node.children, child);\r\n            }\r\n            else {\r\n                node.children.push(child);\r\n            }\r\n        }\r\n\r\n        if (!result) {\r\n            var rootNode;\r\n            var getTreeNode = function getTreeNode(capabilitiesNode, forceAddition, isRootNode) {\r\n                var uid;\r\n                for (var key in self._capabilitiesNodes) {\r\n                    if (self._capabilitiesNodes[key] === capabilitiesNode) {\r\n                        uid = key;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!uid) {\r\n                    uid = TC.getUID();\r\n                    self._capabilitiesNodes[uid] = capabilitiesNode;\r\n                }\r\n                var r = {\r\n                    name: self.wrap.getName(capabilitiesNode), title: capabilitiesNode.title || capabilitiesNode.Title, uid: uid, children: [], abstract: !!capabilitiesNode.Abstract, metadata: !!capabilitiesNode.MetadataURL\r\n                };\r\n                if (isRootNode) {\r\n                    rootNode = r;\r\n                }\r\n\r\n                if (_isNameInArray(self, r.name, self.availableNames)) {\r\n                    forceAddition = true;\r\n                }\r\n\r\n                if (!self.options.isBase) {\r\n                    if (r === rootNode) {\r\n                        r.isVisible = self.getVisibility();\r\n                    }\r\n                    else {\r\n                        r.isVisible = self.isVisibleByName(r.name);\r\n                    }\r\n                    var i;\r\n                    var layerNodes = self.wrap.getLayerNodes(capabilitiesNode);\r\n                    for (i = 0; i < layerNodes.length; i++) {\r\n                        var treeNode = getTreeNode(layerNodes[i], forceAddition);\r\n                        if (treeNode) {\r\n                            addChild(r, treeNode);\r\n                        }\r\n                    }\r\n\r\n                    r.legend = self.wrap.getLegend(capabilitiesNode);\r\n\r\n                    // No muestra ramas irrelevantes si hideTree = true\r\n                    if (!forceAddition && !isRootNode) {\r\n                        // Eliminamos la rama hasta el nodo de interés\r\n                        rootNode.children = rootNode.children.concat(r.children);\r\n                        r = null;\r\n                    }\r\n                }\r\n                else {\r\n                    r.name = self.names.join(',');\r\n                    r.title = self.title || r.title;\r\n                    r.isBase = self.isDefault;\r\n                    if (self.options.thumbnail) {\r\n                        r.legend = {\r\n                            src: self.options.thumbnail\r\n                        };\r\n                    }\r\n                }\r\n                return r;\r\n            };\r\n\r\n            switch (self.type) {\r\n                case TC.Consts.layerType.WMTS:\r\n                    result = getTreeNode(self.wrap.getWMTSLayer(), !self.options.hideTree, true);\r\n                    break;\r\n                case TC.Consts.layerType.WMS:\r\n                    if (self.capabilities) {\r\n                        result = getTreeNode(self.wrap.getRootLayerNode(), !self.options.hideTree, true);\r\n\r\n                        var cache = self._cache.visibilityStates;\r\n\r\n                        var _setNodeState = function _setNodeState(node) {\r\n                            var _result = TC.Consts.visibility.NOT_VISIBLE;\r\n                            if (node) {\r\n                                if (cache[node.uid] !== undefined) {\r\n                                    _result = cache[node.uid];\r\n                                }\r\n                                else {\r\n                                    if (node.children) {\r\n                                        var hasVisible = false;\r\n                                        var hasNotVisible = false;\r\n                                        for (var i = 0, len = node.children.length; i < len; i++) {\r\n                                            var r = _setNodeState(node.children[i]);\r\n                                            switch (r) {\r\n                                                case TC.Consts.visibility.VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.NOT_VISIBLE:\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                case TC.Consts.visibility.HAS_VISIBLE:\r\n                                                    hasVisible = true;\r\n                                                    hasNotVisible = true;\r\n                                                    break;\r\n                                                default:\r\n                                                    break;\r\n                                            }\r\n                                            if (hasVisible) {\r\n                                                if (hasNotVisible) {\r\n                                                    _result = TC.Consts.visibility.HAS_VISIBLE;\r\n                                                }\r\n                                                else {\r\n                                                    _result = TC.Consts.visibility.VISIBLE;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    if (node.isVisible) {\r\n                                        _result = TC.Consts.visibility.VISIBLE;\r\n                                    }\r\n                                    cache[node.uid] = _result;\r\n                                }\r\n                                node.visibilityState = _result;\r\n                            }\r\n                            return _result;\r\n                        };\r\n                        _setNodeState(result);\r\n\r\n                        if (self.options.hideTree) {\r\n                            _sortTree(self, result);\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (!result) {\r\n                result = {\r\n                    name: self.name, title: self.title\r\n                };\r\n            }\r\n            result.title = self.title || result.title;\r\n            result.customLegend = self.customLegend || result.customLegend;\r\n            self.tree = result;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.setNodeVisibility = function (id, visible) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n\r\n        var _getNames = function _getNames(node) {\r\n            var result = [];\r\n            if (node.name) {\r\n                result[0] = node.name;\r\n            }\r\n            else {\r\n                for (var i = 0; i < node.children.length; i++) {\r\n                    result = result.concat(_getNames(node.children[i]));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        var node = self.findNode(id, self.tree);\r\n        if (node === self.tree) {\r\n            if (visible && self.names.length === 0) {\r\n                // Prevent pink error tile\r\n                self.addLayerNames(self.availableNames).then(function () {\r\n                    self.setVisibility(true);\r\n                });\r\n            }\r\n            else {\r\n                self.setVisibility(visible);\r\n            }\r\n        }\r\n        else {\r\n            var names = _getNames(node);\r\n            if (visible) {\r\n                self.addLayerNames(names);\r\n            }\r\n            else {\r\n                self.removeLayerNames(names);\r\n            }\r\n        }\r\n    };\r\n\r\n    layerProto.getNodeVisibility = function (id) {\r\n        var self = this;\r\n        if (!self.tree) {\r\n            self.tree = self.getTree();\r\n        }\r\n        return self._cache.visibilityStates[id];\r\n    };\r\n\r\n    layerProto.getNodePath = function (layerName, ignorePrefix) {\r\n        var self = this;\r\n        var result = [];\r\n        if (self.type === TC.Consts.layerType.WMS && self.capabilities) {\r\n            layerName = layerName || self.names[0];\r\n\r\n            var _getPath = function _getPath(node) {\r\n                var res = [];\r\n                var nodeName = self.wrap.getName(node);\r\n                if (self.compareNames(nodeName, layerName, ignorePrefix)) {\r\n                    res.push(node);\r\n                }\r\n                else {\r\n                    var children = self.wrap.getLayerNodes(node);\r\n                    for (var i = 0; i < children.length; i++) {\r\n                        var r = _getPath(children[i]);\r\n                        if (r.length) {\r\n                            res = r;\r\n                            TC.Util.fastUnshift(res, node);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return res;\r\n            };\r\n            result = _getPath(self.wrap.getRootLayerNode());\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getPath = function (layerName, ignorePrefix) {\r\n        return this.getNodePath(layerName, ignorePrefix).map(function (node) {\r\n            return node.title || node.Title;\r\n        });\r\n    };\r\n\r\n    layerProto.getLayerNodeByName = function (name) {\r\n        var result = null;\r\n        var self = this;\r\n        var getName = self.wrap.getServiceType() === TC.Consts.layerType.WMTS ? self.wrap.getIdentifier : self.wrap.getName\r\n        var nodes = self.wrap.getAllLayerNodes();\r\n        for (var i = 0, len = nodes.length; i < len; i++) {\r\n            if (self.compareNames(getName(nodes[i]), name)) {\r\n                result = nodes[i];\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getChildrenLayers = function (layer) {\r\n        var result = [];\r\n        var _recursiveFn = function (lyr, arr) {\r\n            if (lyr && lyr.Layer && lyr.Layer.length) {\r\n                for (var i = 0; i < lyr.Layer.length; i++) {\r\n                    arr.push(lyr.Layer[i]);\r\n                    _recursiveFn(lyr.Layer[i], arr);\r\n                }\r\n            }\r\n        };\r\n        _recursiveFn(layer, result);\r\n        return result;\r\n    };\r\n\r\n    layerProto.compareNames = function (n1, n2, looseComparison) {\r\n        var result = n1 === n2;\r\n        var self = this;\r\n        var lc = looseComparison !== undefined ? looseComparison : self.ignorePrefixes\r\n        if (!result && lc && n1 && n2) {\r\n            // Revisamos si tienen prefijo. Si lo tiene solo una de las dos lo obviamos para la comparación\r\n            var idx1 = n1.indexOf(':');\r\n            var idx2 = n2.indexOf(':');\r\n            if (idx1 >= 0 && idx2 < 0) {\r\n                result = n1.substr(idx1 + 1) === n2;\r\n            }\r\n            else if (idx2 >= 0 && idx1 < 0) {\r\n                result = n1 === n2.substr(idx2 + 1);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    layerProto.getCapabilitiesPromise = function () {\r\n        return this._capabilitiesPromise;\r\n    };\r\n\r\n    layerProto.getResolutions = function () {\r\n        return this.wrap.getResolutions();\r\n    };\r\n\r\n    layerProto.setResolutions = function (resolutions) {\r\n        this.wrap.setResolutions(resolutions);\r\n    };\r\n\r\n    layerProto.getExtent = function () {\r\n        return this.wrap.getExtent();\r\n    };\r\n\r\n    const formatDescriptions = {};\r\n    layerProto.getInfo = function (name) {\r\n        const self = this;\r\n        const info = self.wrap.getInfo(name);\r\n        if (info.metadata) {\r\n            info.metadata.forEach(function (md) {\r\n                if (self.map) {\r\n                    md.formatDescription = formatDescriptions[md.format] =\r\n                        formatDescriptions[md.format] ||\r\n                        TC.Util.getLocaleString(self.map.options.locale, TC.Util.getSimpleMimeType(md.format)) ||\r\n                        TC.Util.getLocaleString(self.map.options.locale, 'viewMetadata');\r\n                }\r\n                else {\r\n                    md.formatDescription = formatDescriptions[md.format];\r\n                }\r\n            });\r\n        }\r\n        return info;\r\n    };\r\n\r\n    //Devuelve un array de subLayers cuyo nombre o descripción contenga el texto indicado\r\n    //case insensitive\r\n    layerProto.searchSubLayers = function (text) {\r\n        if (!this.patternFn) {\r\n            this.patternFn = function (t) {\r\n                t = t.replace(/[^a-z\\dáéíóúüñ]/gi, '\\\\' + '$&');\r\n                t = t.replace(/(a|á)/gi, \"(a|á)\");\r\n                t = t.replace(/(e|é)/gi, \"(e|é)\");\r\n                t = t.replace(/(i|í)/gi, \"(i|í)\");\r\n                t = t.replace(/(o|ó)/gi, \"(o|ó)\");\r\n                t = t.replace(/(u|ú|ü)/gi, \"(u|ú|ü)\");\r\n                t = t.replace(/n/gi, \"(n|ñ)\");\r\n                return t;\r\n            }\r\n        }\r\n        if (text && text.length && text.length >= 3) {\r\n            var self = this;\r\n            var layers = null;\r\n            /*URI:Si la cadena a buscar contiene a la busqueda anterior, por ejemplo, antes he buscado \"cat\" y ahora busco \"cata\" porque esto escribiendo \"catastro\" ...\r\n            en vez de buscar en todas las capas del servicio busco en los resultados encotrados en la búsqueda anterior */\r\n            if (this.lastPattern && text.indexOf(this.lastPattern) >= 0) {\r\n                layers = this.lastMatches\r\n            }\r\n            else {\r\n                /*si se ha definido el parametro layers de esta capa en configuraci\\u00f3n filtro las capas del capability para que busque solo en las capas que est\\u00e9n en \r\n                configuraci\\u00f3n y sus hijas*/\r\n                if (self.availableNames && self.availableNames.length > 0) {\r\n                    layers = []\r\n                    for (var i = 0; i < self.availableNames.length; i++) {\r\n                        var layer = self.getLayerNodeByName(self.availableNames[i]);\r\n                        if (layer) {\r\n                            layers.push(layer);\r\n                            layers = layers.concat(self.getChildrenLayers(layer));\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    layers = self.wrap.getAllLayerNodes();\r\n                }\r\n            }\r\n\r\n            var filter = this.patternFn(text);\r\n            var re = new RegExp(filter, \"i\");\r\n\r\n            var matches = layers.map(function (ly, ix) {\r\n                delete ly.tcScore;\r\n\r\n                ly.tcPosition = ix;\r\n\r\n                self.wrap.normalizeLayerNode(ly);\r\n\r\n                var title = ly.Title.trim();\r\n                var res = re.exec(title);\r\n                var titleIx = res ? res.index : -1;\r\n                var abstractIx = -1;\r\n                if (ly.Abstract) {\r\n                    var abs = ly.Abstract.trim();\r\n                    var res2 = re.exec(abs);\r\n                    abstractIx = res2 ? res2.index : -1;\r\n                }\r\n\r\n                if (res && title == res[0])\r\n                    ly.tcScore = 20;\r\n                else if (titleIx == 0)\r\n                    ly.tcScore = 15;\r\n                else if (titleIx > -1)\r\n                    ly.tcScore = 10;\r\n                else if (abstractIx == 0)\r\n                    ly.tcScore = 5;\r\n                else if (abstractIx > -1)\r\n                    ly.tcScore = 1;\r\n\r\n                if (ly.tcScore)\r\n                    return ly;\r\n                else\r\n                    return null;\r\n            })\r\n                .filter(function (elto) {\r\n                    return elto != null;\r\n                })\r\n                .sort(function (a, b) {\r\n                    if (b.tcScore === a.tcScore) {\r\n                        //si la puntuación es la misma reordenamos por título\r\n                        var titleA = TC.Util.replaceSpecialCharacters(a.Title);\r\n                        var titleB = TC.Util.replaceSpecialCharacters(b.Title);\r\n                        if (titleA < titleB) return -1;\r\n                        if (titleA > titleB) return 1;\r\n                        return 0;\r\n                    }\r\n                    else\r\n                        return b.tcScore - a.tcScore;\r\n                });\r\n\r\n            this.lastPattern = text;\r\n            this.lastMatches = matches;\r\n\r\n            return matches;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n\r\n    };\r\n        \r\n\r\n    layerProto.getGetCapabilitiesUrl = function () {\r\n        const self = this;\r\n        var url;\r\n        const serviceUrl = self.url;\r\n        const params = {};\r\n        if (self.type === TC.Consts.layerType.WMTS) {\r\n            if (self.options.encoding === TC.Consts.WMTSEncoding.RESTFUL) {\r\n                var suffix = '/1.0.0/WMTSCapabilities.xml';\r\n                const suffixIdx = serviceUrl.indexOf(suffix);\r\n                if (suffixIdx < 0 || suffixIdx < serviceUrl.length - suffix.length) {\r\n                    if (serviceUrl[serviceUrl.length - 1] === '/') {\r\n                        suffix = suffix.substr(1);\r\n                    }\r\n                    url = serviceUrl + suffix;\r\n                }\r\n                else {\r\n                    url = serviceUrl;\r\n                }\r\n            }\r\n            else {\r\n                url = serviceUrl;\r\n                params.SERVICE = 'WMTS';\r\n                params.VERSION = '1.0.0';\r\n                params.REQUEST = 'GetCapabilities';\r\n            }\r\n        }\r\n        else {\r\n            url = serviceUrl;\r\n            params.SERVICE = 'WMS';\r\n            params.VERSION = '1.3.0';\r\n            params.REQUEST = 'GetCapabilities';\r\n        }\r\n        url = url + '?' + TC.Util.getParamString(TC.Util.extend(params, self.queryParams));\r\n        return url;\r\n    };\r\n\r\n    layerProto.getPreferredInfoFormat = function () {\r\n        const layer = this;\r\n        var result = null;\r\n\r\n        const infoFormats = layer.wrap.getInfoFormats();\r\n        if (infoFormats) {\r\n            for (var i = 0; i < TC.wrap.layer.Raster.infoFormatPreference.length; i++) {\r\n                var format = TC.wrap.layer.Raster.infoFormatPreference[i];\r\n                if (infoFormats.indexOf(format) >= 0) {\r\n                    result = format;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Carga la imagen de leyenda de una capa por POST.\r\n     */\r\n    layerProto.getLegendGraphicImage = function () {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n            //Si ya hemos hecho esta consulta previamente, retornamos la respuesta\r\n            if (self.options.params.base64LegendSrc) {\r\n                return resolve(self.options.params.base64LegendSrc);\r\n            }\r\n\r\n            if (typeof window.btoa === 'function') {\r\n                var name = self.names[0];\r\n                var info = self.wrap.getInfo(name);\r\n                var xhr = new XMLHttpRequest();\r\n                var url = info.legend[0].src.split('?'); // Separamos los parámetros de la raíz de la URL\r\n                var dataEntries = url[1].split(\"&\"); // Separamos clave/valor de cada parámetro\r\n                var params = self.options.params.sld_body ? \"sld_body=\" + self.options.params.sld_body : '';\r\n\r\n                for (var i = 0; i < dataEntries.length; i++) {\r\n                    var chunks = dataEntries[i].split('=');\r\n\r\n                    if (chunks && chunks.length > 1 && chunks[1]) {\r\n                        params += \"&\" + dataEntries[i];\r\n                    }\r\n                }\r\n                if (self.options.params.env) {\r\n                    params += \"&\" + self.options.params.env;\r\n                }\r\n\r\n                xhr.open('POST', url[0], true);\r\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n\r\n                xhr.responseType = 'arraybuffer';\r\n                xhr.onload = function (e) {\r\n                    if (this.status === 200) {\r\n                        var uInt8Array = new Uint8Array(this.response);\r\n                        var i = uInt8Array.length;\r\n                        var binaryString = new Array(i);\r\n                        while (i--) {\r\n                            binaryString[i] = String.fromCharCode(uInt8Array[i]);\r\n                        }\r\n                        var data = binaryString.join('');\r\n                        var type = xhr.getResponseHeader('content-type');\r\n                        if (type.indexOf('image') === 0) {\r\n                            var imageSrc;\r\n                            imageSrc = 'data:' + type + ';base64,' + window.btoa(data);\r\n                            self.options.params.base64LegendSrc = imageSrc; //Cacheamos la respuesta\r\n                            resolve(imageSrc);\r\n                        }\r\n                    }\r\n                };\r\n                xhr.send(params);\r\n            } else {\r\n                reject(Error(\"Función window.btoa no soportada por el navegador\"));\r\n            }\r\n        });\r\n    };\r\n\r\n    layerProto.getUrl = function (src) {\r\n        var self = this;\r\n\r\n        return src;\r\n    };\r\n\r\n    // GLS: Según MDN: https://developer.mozilla.org/es/docs/Web/API/WebGL_API/Tutorial/Wtilizando_texturas_en_WebGL\r\n    //    Note: Es importante señalar que la carga de texturas en WebGL sigue reglas de dominio-cruzado; \r\n    //          Es decir, sólo puede cargar texturas de sitios para los que su contenido tiene aprobación de CORS.\r\n\r\n    // Usamos el mismo método que para el capabilities ya que la carga de texturas es igual de restrictiva.\r\n    layerProto.getWebGLUrl = function (src, location) {\r\n        const self = this;\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            var _src = !TC.Util.isSecureURL(src) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(src) : src;\r\n\r\n            if (self.ignoreProxification) {\r\n                resolve(_src);\r\n            } else {\r\n                const options = {\r\n                    exportable: true,\r\n                    ignoreProxification: self.ignoreProxification\r\n                };\r\n\r\n                self.toolProxification.fetchImage(_src, options).then(function () {\r\n                    self.toolProxification.cacheHost.getAction(_src, options).then(function (cache) {\r\n                        if (cache && cache.action) {\r\n                            resolve(cache.action.call(self.toolProxification, _src));\r\n                        }\r\n                    });\r\n                }).catch(function (e) {\r\n                    reject(Error(e));\r\n                });\r\n            }\r\n\r\n            //// IGN francés tiene cabeceras CORS menos en las excepciones que las devuelve en XML así que si da error cargamos imagen en blanco sin hacer más\r\n            //if (self.ignoreProxification) {\r\n            //    setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            //    return;\r\n            //}\r\n\r\n            //return self.capabilitiesUrl_.call(self, !TC.Util.isSecureURL(url) && TC.Util.isSecureURL(TC.Util.toAbsolutePath(self.url)) ? self.getBySSL_(url) : url);        \r\n        });\r\n    };\r\n\r\n    layerProto.getFeatureUrl = function (url) {\r\n        var self = this;\r\n\r\n        return self.toolProxification.fetch(url).then(function () {\r\n            return self.toolProxification.cacheHost.getAction(url)\r\n                .then(function (cache) {\r\n                    return cache.action.call(self.toolProxification, url);\r\n                })\r\n                .catch(function (error) {\r\n                    return Promise.reject(error);\r\n                })\r\n        }).catch(function (error) {\r\n            return Promise.reject(error);\r\n        });\r\n    };\r\n\r\n    // GLS:\r\n    // Busca en capas cargadas la 1º capa que tenga la misma instancia de capabilities. \r\n    // Recibe una función como parámetro opcional, la cual es invocada para añadir más condiciones en la búsqueda de una capa hermana.\r\n    layerProto.getSiblingLoadedLayer = function (dynamicStatement) {\r\n        var self = this;\r\n\r\n        if (!self.map) {\r\n            return null;\r\n        } else {\r\n            var layers = self.map.baseLayers.slice(0).concat(self.map.workLayers.slice(0));\r\n\r\n            const matchingLayer = layers.filter(function (elem) {\r\n                return (elem.type === TC.Consts.layerType.WMS ||\r\n                    elem.type === TC.Consts.layerType.WMTS) &&\r\n                    (elem.capabilities === self.capabilities || elem.url === self.url) &&\r\n                    (TC.Util.isFunction(dynamicStatement) ? dynamicStatement(elem) : true);\r\n            })[0];\r\n\r\n            return matchingLayer || null;\r\n        }\r\n    };\r\n\r\n    layerProto.getImageLoad = function (image, src, location) {\r\n        const self = this;\r\n\r\n        const setSRC = function (data) {\r\n            const img = image.getImage();\r\n\r\n            if (!TC.Util.isSameOrigin(data.src)) {\r\n                if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                    img.crossOrigin = data.crossOrigin !== null ? data.crossOrigin : \"anonymous\";\r\n                }\r\n            }\r\n\r\n            // GLS: si establecemos por atributo directamente no actualiza, mediante setAttribute funciona siempre.\r\n            img.setAttribute(\"src\", data.src);\r\n            img.onload = function () {\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n            };\r\n            img.onerror = function (error) {\r\n                img.setAttribute(\"src\", TC.Consts.BLANK_IMAGE);\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n            };\r\n        };\r\n\r\n        // Viene sin nombre desde el control TOC, si es así lo ignoramos.\r\n        if (self.names && self.names.length > 0) {\r\n\r\n            const error = function (error) {\r\n                _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            };\r\n\r\n            // comprobamos z/x/y contra el matrixset del capabilities para evitar peticiones 404\r\n            if (self.type === TC.Consts.layerType.WMTS) {\r\n                var z, x, y;\r\n                if (self.encoding != \"KVP\") {\r\n                    var _src = src.replace('.' + self.format.split('/')[1], '');\r\n                    var parts = _src.split('/').slice(_src.split('/').length - 3).map(function (elm) { return parseInt(elm); });\r\n                    z = parts[0];\r\n                    x = parts[1];\r\n                    y = parts[2];\r\n                } else {\r\n                    var parts = /.*TileMatrix=(\\d*)&TileCol=(\\d*)&TileRow=(\\d*)/i.exec(src);\r\n                    if (parts && parts.length == 4) {\r\n                        parts = parts.slice(1).map(function (elm) { return parseInt(elm); });\r\n                        z = parts[0];\r\n                        x = parts[2];\r\n                        y = parts[1];\r\n                    }\r\n                }\r\n\r\n                if (z && x && y) {\r\n                    var wmtsOptions = self.wrap.getWMTSLayer();\r\n                    if (wmtsOptions) {\r\n                        var matrixSet = wmtsOptions.TileMatrixSetLink.filter(function (elm) { return elm.TileMatrixSet === self.matrixSet; });\r\n                        if (matrixSet.length > 0) {\r\n\r\n                            if (matrixSet[0].TileMatrixSetLimits.length > 0) {\r\n                                var matrixSetLimits = matrixSet[0].TileMatrixSetLimits.sort(function (a, b) {\r\n                                    if (parseInt(a.TileMatrix) > parseInt(b.TileMatrix))\r\n                                        return 1;\r\n                                    else if (parseInt(a.TileMatrix) < parseInt(b.TileMatrix))\r\n                                        return -1;\r\n                                    else return 0;\r\n                                });\r\n\r\n                                var level = matrixSetLimits[z];\r\n                                if (level && self.map && self.map.on3DView) {\r\n                                    if (!(level.MinTileRow <= x && level.MaxTileRow >= x && level.MinTileCol <= y && level.MaxTileCol >= y)) {\r\n                                        console.log('Prevenimos petición fuera de matrix set, cargamos imagen en blanco');\r\n                                        setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            _get$events.call(self).trigger(TC.Consts.event.BEFORETILELOAD, { tile: image });\r\n\r\n            var params = \"\";\r\n            var isPOST = self.options.method === \"POST\";\r\n            if (isPOST) {\r\n                var url = src.split('?');\r\n                params = url[1].split(\"&\").filter(function (param) {\r\n                    const values = param.split('=');\r\n                    // eliminamos los valores en blanco y el parámetro layers\r\n                    return values.length > 1 && values[1].trim().length > 0 && values[0].trim().toLowerCase() !== \"layers\";\r\n                }).join('&');\r\n\r\n                self.toolProxification.fetchImageAsBlob(url[0], {\r\n                    type: \"POST\",\r\n                    data: params,\r\n                    contentType: \"application/x-www-form-urlencoded\"\r\n                }).then(function (blob) {\r\n                    const imageUrl = URL.createObjectURL(blob);\r\n                    const img = image.getImage();\r\n                    img.onload = function (evt) {\r\n                        URL.revokeObjectURL(imageUrl);\r\n                    };\r\n                    setSRC({ src: imageUrl });\r\n                }).catch(error);\r\n\r\n            } else {\r\n                if (!self.ignoreProxification) {\r\n                    self.toolProxification.fetchImage(src, { exportable: !self.map || (self.map && self.map.mustBeExportable) }).then(function (img) {\r\n                        setSRC(img);\r\n                    }).catch(error);\r\n                } else {\r\n                    setSRC({ src: src });\r\n                    var img = image.getImage();\r\n\r\n                    if (!TC.Util.isSameOrigin(src)) {\r\n                        if (!self.map || (self.map && self.map.mustBeExportable)) {\r\n                            img.crossOrigin = \"anonymous\";\r\n                        }\r\n                    }\r\n\r\n                    img.onload = function () {\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n                    };\r\n                    img.onerror = function (error) {\r\n                        img.src = TC.Consts.BLANK_IMAGE;\r\n                        _get$events.call(self).trigger(TC.Consts.event.TILELOADERROR, { tile: image, error: { code: error.status, text: error.statusText } });\r\n                    };\r\n\r\n                    img.src = self.names.length ? src : TC.Consts.BLANK_IMAGE;\r\n                }\r\n            }\r\n        } else {\r\n            setSRC({ src: TC.Consts.BLANK_IMAGE });\r\n            // lanzamos el evento para gestionar el loading\r\n            _get$events.call(self).trigger(TC.Consts.event.TILELOAD, { tile: image });\r\n        }\r\n    };\r\n\r\n    var _get$events = function () {\r\n        const self = this;\r\n        if (self.wrap && self.wrap.$events) {\r\n            return self.wrap.$events;\r\n        }\r\n        return null;\r\n    };\r\n    layerProto.getWFSURL = async function () {\r\n        const self = this;\r\n        if (_urlWFS[self.options.url]) return await _urlWFS[self.options.url];\r\n        var url = new URL(self.url, document.location.href);\r\n        url.search = new URLSearchParams({ request: 'DescribeLayer', service: \"WMS\", version: \"1.1.1\", Layers: self.layerNames instanceof Array ? self.layerNames[0]:self.layerNames, outputFormat: \"application/json\" });\r\n        return _urlWFS[self.options.url] = new Promise(async function (resolve, reject) {\r\n            try {\r\n                var response = await self.toolProxification.fetch(url.toString(), {\r\n                    method: \"GET\"\r\n\r\n                });\r\n                if (response.contentType.startsWith(\"application/json\")) {\r\n                    var data = JSON.parse(response.responseText).layerDescriptions[0];\r\n                    var _url = data.owsURL.substr(0, (data.owsURL.length + (data.owsURL.endsWith('?') ? -1 : 0)));\r\n                    self.toolProxification.fetch(_url, {\r\n                        method: \"HEAD\"\r\n\r\n                    }).then(function () {\r\n                        resolve(_url);\r\n                    }).catch(function () {\r\n                        resolve(self.options.url.replace(/wms/gi, \"wfs\"));\r\n                    });\r\n                }\r\n                else  {\r\n                    let xmlDoc = new DOMParser().parseFromString(response.responseText, \"text/xml\");\r\n                    let error = xmlDoc.querySelector(\"Exception ExceptionText\") || xmlDoc.querySelector(\"ServiceException\");\r\n                    if (error) {\r\n                        resolve(self.options.url.replace(/wms/gi, \"wfs\"));\r\n                    };\r\n                }\r\n            }\r\n            catch (err) {\r\n                resolve(self.options.url.replace(/wms/gi, \"wfs\"));\r\n            }\r\n        });\r\n    };\r\n\r\n\r\n    layerProto.getWFSCapabilities = async function () {\r\n        const self = this;        \r\n        return getWFSLayer(await self.getWFSURL()).then(function (layer) {\r\n            return layer.getCapabilitiesPromise();\r\n        });\r\n    };\r\n\r\n    layerProto.getDescribeFeatureTypeUrl = function () {\r\n        const self = this;\r\n        const newUrl = _getWFSURL(self)\r\n\r\n        if (!TC.layer.Vector) {\r\n            TC.syncLoadJS(TC.apiLocation + 'TC/layer/Vector');\r\n        }\r\n        if (!wfsLayer || wfsLayer.options.url !== newUrl) {\r\n            wfsLayer = new TC.layer.Vector({\r\n                type: TC.Consts.layerType.WFS,\r\n                url: newUrl,\r\n                stealth: true\r\n            });\r\n        }\r\n        return wfsLayer.getDescribeFeatureTypeUrl(self.options.featureType);\r\n    };\r\n\r\n    layerProto.getFallbackLayer = function () {\r\n        const self = this;\r\n        if (self.fallbackLayer instanceof TC.Layer) {\r\n            return self.fallbackLayer;\r\n        }\r\n        if (self.options.fallbackLayer) {\r\n            var fbLayer = self.options.fallbackLayer;\r\n            if (typeof fbLayer === 'string') {\r\n                const ablCollection = self.map ? self.map.options.availableBaseLayers : TC.Cfg.availableBaseLayers;\r\n                ablCollection.forEach(function (baseLayer) {\r\n                    if (self.options.fallbackLayer === baseLayer.id) {\r\n                        self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, baseLayer, { isBase: true, stealth: true, map: self.map }));\r\n                        self.fallbackLayer.firstOption = self;\r\n                    }\r\n                });\r\n            }\r\n            else if (fbLayer instanceof TC.Layer) {\r\n                self.fallbackLayer = fbLayer;\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            else {\r\n                self.fallbackLayer = new TC.layer.Raster(TC.Util.extend({}, fbLayer, {\r\n                    id: TC.getUID(),\r\n                    isBase: true,\r\n                    stealth: true,\r\n                    title: layer.title,\r\n                    map: self.map\r\n                }));\r\n                self.fallbackLayer.firstOption = self;\r\n            }\r\n            return self.fallbackLayer;\r\n        }\r\n        return null;\r\n    };\r\n    layerProto.describeFeatureType = async function (layerName) {\r\n        const self = this;\r\n        const newUrl = await self.getWFSURL();\r\n\r\n        return getWFSLayer(newUrl).then(function (layer) {\r\n            return layer.describeFeatureType(layerName || self.layerNames[0]);\r\n        });\r\n    };\r\n\r\n    layerProto.refresh = function () {\r\n        return this.wrap.reloadSource();\r\n    };\r\n\r\n})();\r\nvar esriParser = {\r\n    parse: function (text) {\r\n        var result = [];\r\n        var dom = (new DOMParser()).parseFromString(text, 'text/xml');\r\n        if (dom.documentElement.tagName === 'FeatureInfoResponse') {\r\n            var fiCollections = dom.documentElement.getElementsByTagName('FeatureInfoCollection');\r\n            for (var i = 0, len = fiCollections.length; i < len; i++) {\r\n                var fic = fiCollections[i];\r\n                var layerName = fic.getAttribute('layername');\r\n                var fInfos = fic.getElementsByTagName('FeatureInfo');\r\n                for (var j = 0, lenj = fInfos.length; j < lenj; j++) {\r\n                    var fields = fInfos[j].getElementsByTagName('Field');\r\n                    var attributes = {};\r\n                    for (var k = 0, lenk = fields.length; k < lenk; k++) {\r\n                        var field = fields[k];\r\n                        attributes[getElementText(field.getElementsByTagName('FieldName')[0])] = getElementText(field.getElementsByTagName('FieldValue')[0]);\r\n                    }\r\n                    var feature = new ol.Feature(attributes);\r\n                    feature.setId(layerName + '.' + TC.getUID());\r\n                    result.push(feature);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};"]}