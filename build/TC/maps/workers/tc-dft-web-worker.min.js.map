{"version":3,"sources":["workers/tc-dft-web-worker.js"],"names":["tXml","S","options","pos","openBracket","openBracketCC","charCodeAt","closeBracket","closeBracketCC","minusCC","slashCC","exclamationCC","singleQuoteCC","doubleQuoteCC","openSquareBracketCC","closeSquareBracketCC","parseChildren","children","indexOf","char2","length","node","parseNode","push","text","parseText","trim","start","slice","nameSpacer","parseName","c","NoChildNodes","tagName","attrFound","name","code","attributes","value","parseString","startChar","startpos","r","out","undefined","attrValue","attrName","RegExp","exec","index","lastIndexOf","substr","filter","simplify","forEach","child","kids","_attributes","i","f","concat","stringify","O","writeChildren","writeNode","N","toContentString","tDom","Array","isArray","e","getElementById","id","simplified","getElementsByClassName","classname","module","exports","removePreffix","str","substring","copySchema","schema1","schema2","key","findByTagName","nodes","reduce","vi","va","proccessIncludes","async","schema","url","include","_url","schemaLocation","startsWith","IncludesUsed","proxifyUrl","err","getExternalType","type","depth","collection","endsWith","processType","processElement","preffix","find","_import","namespace","self","location","origin","ret","ref","Object","keys","urlBegin","prom","Promise","resolve","getRecursive","temp","subType","extension","subelement","base","console","log","searchHierarchyTypes","geometryTypes","requestCache","functionsCallback","postMessage","element","MAX_DEPTH","currentElement","complexType","getComplexType","item","elements","objFeature","j","aux","current","parseInt","isNaN","includes","targetElement","attrComplex","a","processDFT","json","layerName","onmessage","data","xml","arrTypes","split","result","error","state","DFTCollection","replace","toLowerCase","assign","response"],"mappings":"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","sourcesContent":["\r\n/**\r\n * @author: Tobias Nickel\r\n * @created: 06.04.2015\r\n * I needed a small xmlparser chat can be used in a worker.\r\n */\r\n\r\n/**\r\n * parseXML / html into a DOM Object. with no validation and some failur tolerance\r\n * @params S {string} your XML to parse\r\n * @param options {object} all other options:\r\n * searchId {string} the id of a single element, that should be returned. using this will increase the speed rapidly\r\n * filter {function} filter method, as you know it from Array.filter. but is goes throw the DOM.\r\n * simplify {bool} to use tXml.simplify.\r\n */\r\n\r\n//importScripts('./loquesea.js');\r\n\r\nfunction tXml(S, options) {\r\n    \"use strict\";\r\n    options = options || {};\r\n\r\n    var pos = 0;\r\n\r\n    var openBracket = \"<\";\r\n    var openBracketCC = \"<\".charCodeAt(0);\r\n    var closeBracket = \">\";\r\n    var closeBracketCC = \">\".charCodeAt(0);\r\n    var minus = \"-\";\r\n    var minusCC = \"-\".charCodeAt(0);\r\n    var slash = \"/\";\r\n    var slashCC = \"/\".charCodeAt(0);\r\n    var exclamation = '!';\r\n    var exclamationCC = '!'.charCodeAt(0);\r\n    var singleQuote = \"'\";\r\n    var singleQuoteCC = \"'\".charCodeAt(0);\r\n    var doubleQuote = '\"';\r\n    var doubleQuoteCC = '\"'.charCodeAt(0);\r\n    var openSquareBracket = \"[\";\r\n    var openSquareBracketCC = \"[\".charCodeAt(0);\r\n    var closeSquareBracket = \"]\";\r\n    var closeSquareBracketCC = \"]\".charCodeAt(0);\r\n\r\n    /**\r\n     * parsing a list of entries\r\n     */\r\n\r\n    function parseChildren() {\r\n        var children = [];\r\n        while (S[pos]) {\r\n            if (S.charCodeAt(pos) == openBracketCC) {\r\n                if (S.charCodeAt(pos + 1) === slashCC) {\r\n                    pos = S.indexOf(closeBracket, pos);\r\n                    return children;\r\n                } else if (S.charCodeAt(pos + 1) === exclamationCC) {\r\n                    var char2 = S.charCodeAt(pos + 2);\r\n                    if (char2 == openSquareBracketCC) {\r\n                        // cdata support\r\n                    }\r\n                    else {\r\n                        if (char2 == minusCC) {\r\n                            //comment support\r\n                            while (pos !== -1 && !(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) == minusCC && S.charCodeAt(pos - 2) == minusCC && pos != -1)) {\r\n                                pos = S.indexOf(closeBracket, pos + 1);\r\n                            }\r\n                            if (pos === -1)\r\n                                pos = S.length\r\n                        } else {\r\n                            // doctypesupport\r\n                            pos += 2;\r\n                            while (S.charCodeAt(pos) !== closeBracketCC) {\r\n                                pos++;\r\n                            }\r\n                        }\r\n                        pos++;\r\n                        continue;\r\n                    }\r\n                }\r\n                var node = parseNode();\r\n                children.push(node);\r\n            } else {\r\n                var text = parseText()\r\n                if (text.trim().length > 0)\r\n                    children.push(text);\r\n            }\r\n            pos++;\r\n        }\r\n        return children;\r\n    }\r\n\r\n    /**\r\n     *    returns the text outside of texts until the first '<'\r\n     */\r\n\r\n    function parseText() {\r\n        var start = pos;\r\n        pos = S.indexOf(openBracket, pos) - 1;\r\n        if (pos === -2)\r\n            pos = S.length;\r\n        return S.slice(start, pos + 1);\r\n    }\r\n    /**\r\n     *    returns text until the first nonAlphebetic letter\r\n     */\r\n    var nameSpacer = '\\n\\t>/= ';\r\n\r\n    function parseName() {\r\n        var start = pos;\r\n        var c = S[pos];\r\n        while (nameSpacer.indexOf(c) === -1) {\r\n            c = S[++pos];\r\n            // flacunza: Ignoramos los prefijos\r\n            if (c === ':') {\r\n                pos++;\r\n                start = pos;\r\n            }\r\n        }\r\n        return S.slice(start, pos);\r\n    }\r\n    /**\r\n     *    is parsing a node, including tagName, Attributes and its children,\r\n     * to parse children it uses the parseChildren again, that makes the parsing recursive\r\n     */\r\n    var NoChildNodes = ['img', 'br', 'input', 'meta', 'link'];\r\n\r\n    function parseNode() {\r\n        var node = {};\r\n        pos++;\r\n        if (S.charCodeAt(pos) === exclamationCC && S.charCodeAt(pos + 1) === openSquareBracketCC) {\r\n            // parse cdata\r\n            var start = pos + 8;\r\n            while (!(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) === closeSquareBracketCC && S.charCodeAt(pos - 2) === closeSquareBracketCC)) {\r\n                pos++;\r\n            }\r\n            return S.slice(start, pos - 2);\r\n        }\r\n\r\n        node.tagName = parseName();\r\n\r\n        // parsing attributes\r\n        var attrFound = false;\r\n        while (S.charCodeAt(pos) !== closeBracketCC) {\r\n            var c = S.charCodeAt(pos);\r\n            if ((c > 64 && c < 91) || (c > 96 && c < 123)) {\r\n                //if('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(S[pos])!==-1 ){\r\n                var name = parseName();\r\n                // search beginning of the string\r\n                var code = S.charCodeAt(pos);\r\n                while (code !== singleQuoteCC && code !== doubleQuoteCC && !((code > 64 && code < 91) || (code > 96 && code < 123)) && code !== closeBracketCC) {\r\n                    pos++;\r\n                    code = S.charCodeAt(pos);\r\n                }\r\n                if (!attrFound) {\r\n                    node.attributes = {};\r\n                    attrFound = true;\r\n                }\r\n                if (code === singleQuoteCC || code === doubleQuoteCC) {\r\n                    var value = parseString();\r\n                } else {\r\n                    value = null;\r\n                    pos--;\r\n                }\r\n                node.attributes[name] = value;\r\n            }\r\n            pos++;\r\n\r\n        }\r\n        // optional parsing of children\r\n        if (S.charCodeAt(pos - 1) !== slashCC) {\r\n            if (node.tagName == \"script\") {\r\n                var start = pos + 1;\r\n                pos = S.indexOf('</script>', pos);\r\n                node.children = [S.slice(start, pos - 1)];\r\n                pos += 8;\r\n            } else if (node.tagName == \"style\") {\r\n                var start = pos + 1;\r\n                pos = S.indexOf('</style>', pos);\r\n                node.children = [S.slice(start, pos - 1)];\r\n                pos += 7;\r\n            } else if (NoChildNodes.indexOf(node.tagName) == -1) {\r\n                pos++;\r\n                node.children = parseChildren(name);\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     *    is parsing a string, that starts with a char and with the same usually  ' or \"\r\n     */\r\n\r\n    function parseString() {\r\n        var startChar = S[pos];\r\n        var startpos = ++pos;\r\n        pos = S.indexOf(startChar, startpos)\r\n        return S.slice(startpos, pos);\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n\r\n    function findElements() {\r\n        var r = new RegExp('\\\\s' + options.attrName + '\\\\s*=[\\'\"]' + options.attrValue + '[\\'\"]').exec(S)\r\n        if (r) {\r\n            return r.index;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    var out = null;\r\n    if (options.attrValue !== undefined) {\r\n        options.attrName = options.attrName || 'id';\r\n        var out = [];\r\n\r\n        while ((pos = findElements()) !== -1) {\r\n            pos = S.lastIndexOf('<', pos);\r\n            if (pos !== -1) {\r\n                out.push(parseNode());\r\n            }\r\n            S = S.substr(pos);\r\n            pos = 0;\r\n        }\r\n    } else {\r\n        out = parseChildren();\r\n    }\r\n\r\n    if (options.filter) {\r\n        out = tXml.filter(out, options.filter);\r\n    }\r\n\r\n    if (options.simplify) {\r\n        out = tXml.simplify(out);\r\n    }\r\n    return out;\r\n}\r\n/**\r\n * transform the DomObject to an object that is like the object of PHPs simplexmp_load_*() methods.\r\n * this format helps you to write that is more likely to keep your programm working, even if there a small changes in the XML schema.\r\n * be aware, that it is not possible to reproduce the original xml from a simplified version, because the order of elements is not saved.\r\n * therefore your programm will be more flexible and easyer to read.\r\n *\r\n * @param {array} the childrenList\r\n */\r\ntXml.simplify = function simplify(children) {\r\n    var out = {};\r\n    if (!children || !children.length) {\r\n        return '';\r\n    }\r\n\r\n    if (children.length === 1 && typeof children[0] == 'string') {\r\n        return children[0];\r\n    }\r\n    // map each object\r\n    children.forEach(function (child) {\r\n        if (typeof child !== 'object') {\r\n            return;\r\n        }\r\n        if (!out[child.tagName])\r\n            out[child.tagName] = [];\r\n        var kids = tXml.simplify(child.children);\r\n        out[child.tagName].push(kids);\r\n        if (child.attributes) {\r\n            kids._attributes = child.attributes;\r\n        }\r\n    });\r\n\r\n    for (var i in out) {\r\n        if (out[i].length == 1) {\r\n            out[i] = out[i][0];\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\n/**\r\n * behaves the same way as Array.filter, if the filter method return true, the element is in the resultList\r\n * @params children{Array} the children of a node\r\n * @param f{function} the filter method\r\n */\r\ntXml.filter = function (children, f) {\r\n    var out = [];\r\n    children.forEach(function (child) {\r\n        if (typeof (child) === 'object' && f(child)) out.push(child);\r\n        if (child.children) {\r\n            var kids = tXml.filter(child.children, f);\r\n            out = out.concat(kids);\r\n        }\r\n    });\r\n    return out;\r\n};\r\n\r\n/**\r\n * stringify a previously parsed string object.\r\n * this is useful,\r\n *  1. to remove whitespaces\r\n * 2. to recreate xml data, with some changed data.\r\n * @param O{tXMLDomObject} the object to Stringify\r\n */\r\ntXml.stringify = function TOMObjToXML(O) {\r\n    var out = '';\r\n\r\n    function writeChildren(O) {\r\n        if (O)\r\n            for (var i = 0; i < O.length; i++) {\r\n                if (typeof O[i] == 'string') {\r\n                    out += O[i].trim();\r\n                } else {\r\n                    writeNode(O[i]);\r\n                }\r\n            }\r\n    }\r\n\r\n    function writeNode(N) {\r\n        out += \"<\" + N.tagName;\r\n        for (var i in N.attributes) {\r\n            if (N.attributes[i] === null) {\r\n                out += ' ' + i;\r\n            } else if (N.attributes[i].indexOf('\"') === -1) {\r\n                out += ' ' + i + '=\"' + N.attributes[i].trim() + '\"';\r\n            } else {\r\n                out += ' ' + i + \"='\" + N.attributes[i].trim() + \"'\";\r\n            }\r\n        }\r\n        out += '>';\r\n        writeChildren(N.children);\r\n        out += '</' + N.tagName + '>';\r\n    }\r\n    writeChildren(O);\r\n\r\n    return out;\r\n};\r\n\r\n\r\n/**\r\n * use this method to read the textcontent, of some node.\r\n * It is great if you have mixed content like:\r\n * this text has some <b>big</b> text and a <a href=''>link</a>\r\n */\r\ntXml.toContentString = function (tDom) {\r\n    if (Array.isArray(tDom)) {\r\n        var out = '';\r\n        tDom.forEach(function (e) {\r\n            out += ' ' + tXml.toContentString(e);\r\n            out = out.trim();\r\n        });\r\n        return out;\r\n    } else if (typeof tDom === 'object') {\r\n        return tXml.toContentString(tDom.children)\r\n    } else {\r\n        return ' ' + tDom;\r\n    }\r\n};\r\n\r\ntXml.getElementById = function (S, id, simplified) {\r\n    var out = tXml(S, {\r\n        attrValue: id,\r\n        simplify: simplified\r\n    });\r\n    return simplified ? out : out[0];\r\n};\r\n/**\r\n * A fast parsing method, that not realy finds by classname,\r\n * more: the class attribute contains XXX\r\n * @param\r\n */\r\ntXml.getElementsByClassName = function (S, classname, simplified) {\r\n    return tXml(S, {\r\n        attrName: 'class',\r\n        attrValue: '[a-zA-Z0-9\\-\\s ]*' + classname + '[a-zA-Z0-9\\-\\s ]*',\r\n        simplify: simplified\r\n    });\r\n};\r\n\r\nif ('object' === typeof module) {\r\n    module.exports = tXml;\r\n}\r\n\r\n//console.clear();\r\n//console.log('here:',tXml.getElementById('<some><xml id=\"test\">dada</xml><that id=\"test\">value</that></some>','test'));\r\n//console.log('here:',tXml.getElementsByClassName('<some><xml id=\"test\" class=\"sdf test jsalf\">dada</xml><that id=\"test\">value</that></some>','test'));\r\n\r\n/*\r\nconsole.clear();\r\ntXml(d,'content');\r\n //some testCode\r\nvar s = document.body.innerHTML.toLowerCase();\r\nvar start = new Date().getTime();\r\nvar o = tXml(s,'content');\r\nvar end = new Date().getTime();\r\n//console.log(JSON.stringify(o,undefined,'\\t'));\r\nconsole.log(\"MILLISECONDS\",end-start);\r\nvar nodeCount=document.querySelectorAll('*').length;\r\nconsole.log('node count',nodeCount);\r\nconsole.log(\"speed:\",(1000/(end-start))*nodeCount,'Nodes / second')\r\n//console.log(JSON.stringify(tXml('<html><head><title>testPage</title></head><body><h1>TestPage</h1><p>this is a <b>test</b>page</p></body></html>'),undefined,'\\t'));\r\nvar p = new DOMParser();\r\nvar s2='<body>'+s+'</body>'\r\nvar start2= new Date().getTime();\r\nvar o2 = p.parseFromString(s2,'text/html').querySelector('#content')\r\nvar end2=new Date().getTime();\r\nconsole.log(\"MILLISECONDS\",end2-start2);\r\n// */\r\n\r\n\r\n(function () {\r\n\r\n    var simplify = function simplify(children, attributes) {\r\n        var out = {};\r\n        if ((!children || !children.length) && !attributes) {\r\n            return '';\r\n        }\r\n        children = children || [];\r\n\r\n        if (children.length === 1 && typeof children[0] == 'string') {\r\n            return children[0];\r\n        }\r\n        // map each object\r\n        children.forEach(function (child) {\r\n            if (typeof child !== 'object') {\r\n                return;\r\n            }\r\n            var prefixIdx = child.tagName.indexOf('ows:');\r\n            var tagName = prefixIdx < 0 ? child.tagName : child.tagName.substr(prefixIdx + 4);\r\n            if (!out[tagName])\r\n                out[tagName] = [];\r\n            var kids = simplify(child.children, child.attributes);\r\n            out[tagName].push(kids);\r\n            if (child.attributes) {\r\n                for (var key in child.attributes) {\r\n                    kids[key] = child.attributes[key];\r\n                }\r\n            }\r\n        });\r\n\r\n        for (var i in out) {\r\n            if (out[i].length == 1) {\r\n                out[i] = out[i][0];\r\n            }\r\n        }\r\n\r\n        return out;\r\n    };\r\n    const removePreffix = function (str) {\r\n        return str.substring(str.indexOf(\":\") + 1);\r\n    }\r\n    const copySchema = function (schema1, schema2) {\r\n        for (var key in schema2.attributes) {\r\n            schema1.attributes[key] = schema2.attributes[key];\r\n        }\r\n        schema1.children = schema1.children.concat(schema2.children.filter(function (e) { return e.tagName === \"element\" || e.tagName === \"complexType\" || e.tagName === \"import\" }));\r\n    }\r\n    const findByTagName = function (node, tagName) {\r\n        if (node.tagName === tagName)\r\n            return [node];\r\n        else if (node.children) {\r\n            const nodes = node.children.filter(function (node) { return node.tagName === tagName })\r\n            if (nodes.length > 0) return nodes;\r\n            else\r\n                return node.children.reduce(function (vi, va) {\r\n                    return vi.concat(findByTagName(va, tagName));\r\n                }, [])\r\n        }\r\n        return [];\r\n    }\r\n    const proccessIncludes = async function (schema, url) {\r\n        var include = schema.children.filter(function (node) { return node.tagName === \"include\" })\r\n        if (include.length > 0) {\r\n            for (var i = 0; i < include.length; i++) {\r\n                var _url = include[i].attributes.schemaLocation;\r\n                _url = _url.startsWith(\"http\") ? _url : url.substring(0, url.lastIndexOf(\"/\") + 1) + _url;\r\n                if (IncludesUsed.indexOf(_url) >= 0) continue;\r\n                var schema2;\r\n                try {\r\n                    schema2 = await proxifyUrl(_url);\r\n                } catch (err) {\r\n                    return schema\r\n                }\r\n                copySchema(schema, schema2);\r\n                IncludesUsed.push(_url);\r\n                proccessIncludes(schema, _url);\r\n                return schema;\r\n            }\r\n        }\r\n        return schema;\r\n    }\r\n    const searchHierarchyTypes = async function (schema, type, urlBegin) {\r\n        let IncludesUsed = [];\r\n        const prom = new Promise(async function (resolve) {\r\n            const getRecursive = async function (schema, type, url) {\r\n                var temp = schema.children.find(function (node) { return node.tagName === \"complexType\" && node.attributes.name === removePreffix(type) });\r\n                if (!temp) {\r\n                    IncludesUsed.push(url);\r\n                    var include = schema.children.filter(function (node) { return node.tagName === \"include\" });\r\n                    if (include.length > 0) {\r\n                        for (var i = 0; i < include.length; i++) {\r\n                            var _url = include[i].attributes.schemaLocation;\r\n                            _url = _url.startsWith(\"http\") ? _url : url.substring(0, url.lastIndexOf(\"/\") + 1) + _url;\r\n                            if (IncludesUsed.indexOf(_url) >= 0) continue;\r\n                            var schema;\r\n                            try {\r\n                                schema = await proxifyUrl(_url);\r\n                            } catch (err) {\r\n                                console.log(err)\r\n                                throw err;\r\n                            }\r\n                            await getRecursive({ ...schema }, type, _url);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    var subType = null;\r\n                    var extension = findByTagName(temp, \"extension\")[0];\r\n                    var subelement = findByTagName(temp, \"element\")[0]\r\n                    if (extension && extension.attributes.base)\r\n                        subType = extension.attributes.base;\r\n                    if (subelement && subelement.attributes.ref)\r\n                        subType = subelement.attributes.ref;\r\n                    if (subType) {\r\n                        if (subType.indexOf(\":\") > 0) {\r\n                            IncludesUsed = [];\r\n                            temp = await getRecursive({ ...schema }, subType, urlBegin);\r\n                        }\r\n                        else\r\n                            resolve(subType);\r\n                    }\r\n                    else {\r\n                        resolve(temp)\r\n                    }\r\n\r\n                }\r\n            }\r\n            await getRecursive({ ...schema }, type, urlBegin);\r\n            resolve(null);\r\n        });\r\n\r\n        return await prom;\r\n    }\r\n\r\n    const getExternalType = async function (schema, type, depth) {\r\n        //miro si ya está en la colección\r\n        if (collection[type])\r\n            return collection[type];\r\n        //miro si está en el schema actual\r\n        else if (schema.children && schema.children.filter(function (node) { return node.tagName === \"element\" && node.attributes.name === removePreffix(type) }).length > 0) {\r\n            if (type.endsWith(\"Type\"))\r\n                collection[type] = await processType(schema, type, ++depth);\r\n            else\r\n                collection[type] = await processElement(schema, type, ++depth);\r\n            return collection[type];\r\n        }\r\n        else {\r\n            //miro si tiene prefijo y busco un import para ese prefijo\r\n            if (type.indexOf(\":\") > 0) {\r\n                const preffix = type.substring(0, type.indexOf(\":\"));\r\n                const schemaLocation = schema.children.find(function (_import) { return _import.tagName === \"import\" && _import.attributes.namespace === schema.attributes[preffix]; }).attributes.schemaLocation;\r\n                var schema2 = await proxifyUrl(schemaLocation.startsWith(\"http\") ? schemaLocation : self.location.origin + \"/\" + schemaLocation);\r\n                IncludesUsed.push(schemaLocation);\r\n                copySchema(schema, schema2);\r\n                if (type.endsWith(\"Type\")) {\r\n                    let ret = null;\r\n                    if (findByTagName(type, \"element\").length === 1 && findByTagName(type, \"element\")[0].attributes.ref)\r\n                        ret = await processElement(schema, findByTagName(type, \"element\")[0].attributes.ref, ++depth);\r\n                    else\r\n                        ret = await processType(schema, type, ++depth);\r\n                    if (!ret || Object.keys(ret).length === 0)\r\n                        ret = await searchHierarchyTypes(schema2, type, schemaLocation);\r\n                    collection[type] = ret;\r\n                    return ret;\r\n                }\r\n                else {\r\n                    collection[type] = await processElement(schema, type, ++depth);\r\n                    return collection[type];\r\n                }\r\n            }\r\n            return type;\r\n        }\r\n\r\n    }\r\n\r\n    const geometryTypes = [\r\n        \"gml:PointPropertyType\",\r\n        \"gml:MultiPointPropertyType\",\r\n        \"gml:LineStringPropertyType\",\r\n        \"gml:MultiLineStringPropertyType\",\r\n        \"gml:LinearRingPropertyType\",\r\n        \"gml:PolygonPropertyType\",\r\n        \"gml:MultiPolygonPropertyType\",\r\n        \"gml:MultiSurfacePropertyType\",\r\n        \"gml:GeometryPropertyType\",\r\n        \"gml:GeometryCollectionPropertyType\",\r\n        \"gml:GeometryAssociationType\",\r\n        \"gml:MultiCurvePropertyType\",\r\n        \"gml:CurvePropertyType\",\r\n        \"gml:BoxPropertyType\"\r\n    ]\r\n\r\n    const requestCache = {};\r\n    const functionsCallback = {};\r\n\r\n    const proxifyUrl = async function (url) {\r\n        if (requestCache[url]) {\r\n            if (!(requestCache[url] instanceof Promise))\r\n                return requestCache[url];\r\n            else {\r\n                return await requestCache[url];\r\n            }\r\n        }\r\n        requestCache[url] = new Promise(function (resolve) {\r\n            functionsCallback[url] = resolve;\r\n        });\r\n        self.postMessage(url);\r\n        return await requestCache[url];\r\n    }\r\n    const getComplexType = function (schema, element) {\r\n        var complexType;\r\n        if (!element.children && element.attributes.type) {\r\n            var type = element.attributes.type;\r\n            complexType = schema.children.filter(function (node) { return node.tagName === \"complexType\" && node.attributes.name === removePreffix(type) });\r\n        }\r\n        else if (element.children && element.attributes.type) {\r\n            var type = element.attributes.type;\r\n            complexType = schema.children.filter(function (node) { return node.tagName === \"complexType\" && node.attributes.name === removePreffix(type) });\r\n        }\r\n        if (complexType.length > 0) {\r\n            return complexType = complexType[0];\r\n        }\r\n        return null;\r\n    }\r\n    const processElement = async function (schema, element, depth, preffix) {\r\n        if (depth === MAX_DEPTH) return null;\r\n        //busco los includes\r\n        schema = await proccessIncludes(schema);\r\n        //busco los elements con el nombre de la capa en cuestión\r\n        var currentElement = schema.children.filter(function (node) { return node.tagName === \"element\" && node.attributes.name === removePreffix(element) });\r\n\r\n        if (currentElement.length > 0) {\r\n            //si tiene un tipo compuesto lo busco\t\t\t\t\r\n            var complexType = getComplexType(schema, currentElement[0])\r\n            collection[element] = await processType(schema, complexType, depth, preffix);\r\n            return collection[element];\r\n        }\r\n        else {\r\n            collection[element] = null;\r\n            return null;\r\n        }\r\n    }\r\n    const processType = async function (schema, complexType, depth, preffix) {\r\n\r\n        if (!(complexType instanceof Object))\r\n            complexType = schema.children.find(function (item) { return item.tagName === \"complexType\" && item.attributes.name === removePreffix(complexType) })\r\n        if (!complexType) return null;\r\n        //Recorro recursivamente buscando nodos element debajo del nodo complexType\r\n        const elements = findByTagName(complexType, \"element\");\r\n        var objFeature = {};\r\n        //recorro los nodos element que son los atributos de la feature\r\n        for (var j = 0; j < elements.length; j++) {\r\n            let element = elements[j];\r\n            let type = element.attributes.type;\r\n            if (!element.attributes.name && element.attributes.ref) {\r\n                let aux = {}, preffix = element.attributes.ref.substring(0, element.attributes.ref.indexOf(\":\"));\r\n                aux[removePreffix(element.attributes.ref)] = { \"type\": await processElement(schema, element.attributes.ref, ++depth, preffix), \"name\": element.attributes.ref };\r\n                return aux;\r\n            }\r\n            const nodeName = removePreffix(element.attributes.name);\r\n            //declaro un objeto cuyo key es el nombre de la entidad y sus hijos los atributos\r\n            let current = objFeature[nodeName] = {};\r\n\r\n            //cada atributo será un objeto cuyo key será el nombre del atributo y dentro un objeto infromación de cada atribut como tipo si es nullable etc \r\n            for (var i in element.attributes) {\r\n                switch (i) {\r\n                    case \"minOccurs\":\r\n                    case \"maxOccurs\":\r\n                        current[i] = parseInt(element.attributes[i], 10);\r\n                        if (isNaN(current[element.attributes[i]]))\r\n                            current[i] = element.attributes[i];\r\n                        break;\r\n                    case \"nillable\":\r\n                        current[i] = element.attributes[i] === \"true\" ? true : false;\r\n                        break;\r\n                    default:\r\n                        current[i] = (preffix ? preffix + \":\" : \"\") + element.attributes[i];\r\n                        break;\r\n                }\r\n            }\r\n            if (geometryTypes.includes(type)) { continue; }//no procesamos las geometrías\r\n            if (type) {\r\n                current[\"type\"] = type;\r\n                if (type.startsWith(\"xsd\"))\r\n                    type = removePreffix(type);\r\n                if (type === \"gml:ReferenceType\") {\r\n                    var targetElement = findByTagName(element, \"targetElement\");\r\n                    if (targetElement.length > 0 && targetElement[0].children.length > 0) {\r\n                        current[\"type\"] = await getExternalType(schema, targetElement[0].children[0], depth);\r\n                    }\r\n                }\r\n                else if (type.indexOf(\":\") > 0) {\r\n                    complexType = schema.children.find(function (node) { return (node.tagName === \"complexType\" || node.tagName === \"element\") && node.attributes.name === removePreffix(type) })\r\n                    if (!complexType)\r\n                        current[\"type\"] = await getExternalType(schema, type, depth);\r\n                    else\r\n                        if (complexType.tagName === \"complexType\")\r\n                            current[\"type\"] = await processType(schema, complexType, depth);\r\n                        else\r\n                            current[\"type\"] = null;//Esto no se había dado hasta ahora;\r\n\r\n                }\r\n            }\r\n            else {\r\n                //si el atributo es un dato complejo\r\n                var attrComplex = element.children.find((a) => a.tagName === \"complexType\");\r\n                var extension = findByTagName(attrComplex, \"extension\")[0];\r\n                var subelement = findByTagName(attrComplex, \"element\")[0]\r\n                if (extension && extension.attributes.base) {\r\n                    if (extension.attributes.base.indexOf(\":\") < 0)\r\n                        current[\"type\"] = extension.attributes.base;\r\n                    else\r\n                        current[\"type\"] = await getExternalType(schema, extension.attributes.base);\r\n                }\r\n                if (subelement && subelement.attributes.ref) {\r\n                    current[\"type\"] = await getExternalType(schema, subelement.attributes.ref);\r\n                }\r\n            }\r\n        }\r\n        return objFeature;\r\n    }\r\n\r\n    const processDFT = async function (json, layerName, preffix) {\r\n        //coger nodo esquema\r\n        var schema = json.find(function (node) { return node.tagName === \"schema\" });\r\n        return new Promise(async function (resolve) {\r\n            await processElement(schema, layerName, 0);\r\n            resolve();\r\n        });\r\n    }\r\n    var collection = {};\r\n    var proxifyPromises = null;\r\n    var IncludesUsed = [];\r\n    var MAX_DEPTH = 5;\r\n\r\n    onmessage = async function (e) {\r\n        if (e.data.xml) {\r\n            var json = tXml(e.data.xml);\r\n\r\n            const arrTypes = (e.data.layerName instanceof Array ? e.data.layerName : e.data.layerName.split(\",\"));\r\n            let result;\r\n            try {\r\n                for (var i = 0; i < arrTypes.length; i++) {\r\n                    await processDFT(json, arrTypes[i]);\r\n                }\r\n                result = true;\r\n            }\r\n            catch (error) {\r\n                result = false;\r\n            }\r\n            postMessage({\r\n                state: result ? 'success' : 'error',\r\n                DFTCollection: (e.data.layerName instanceof Array ? e.data.layerName : e.data.layerName.split(\",\")).reduce(function (vi, va) {\r\n                    let temp = {};\r\n                    temp[va] = (collection[va] || collection[va.replace(/^\\w{1,}:/, function (a) { return (a.toLowerCase()) })]);\r\n                    return Object.assign(vi, temp);\r\n                }, {})\r\n            });\r\n        }\r\n        else {\r\n            functionsCallback[e.data.url](tXml(e.data.response)[0]);\r\n            delete functionsCallback[e.data.url];\r\n        }\r\n\r\n    };\r\n\r\n})();\r\n"]}