{"version":3,"sources":["cesium/mergeTerrainProvider/MergeTerrainProvider.js"],"names":["n","this","r","e","length","t","o","f","slice","polygonArea","polygonCentroid","u","l","i","polygonHull","Array","sort","g","a","c","push","polygonContains","polygonLength","Math","sqrt","Object","defineProperty","value","exports","module","define","amd","d3","MergeTerrainProvider","options","view","fallbackOptions","noDataValue","commutingProvidersReady","commutingProvidersPromises","cesium","when","defer","surfaceHasTilesToRender","surfaceTilesToRender","fallback","fallbackProvider","map","WCSTerrainProvider","defaultFallbackProvider","EllipsoidTerrainProvider","attributions","trigger","TC","Consts","event","TERRAINPROVIDERADD","terrainProvider","url","Resource","trim","CesiumTerrainProvider","call","boundaries","all","_readyPromise","readyPromise","resolve","bind","prototype","create","enumerable","configurable","writable","allReady","get","allReadyPromise","constructor","isPointInDefaultBoundaries","cartographic","loadPolygonContains","toDegrees","longitude","latitude","isInDefaultBoundaries","x","y","level","toCheck","rectangle","tilingScheme","tileXYToRectangle","Cartographic","west","south","north","east","getTileDataAvailable","_availability","_maximumLevel","getAttribution","requestTileGeometry","self","promise","manageAttributions","provider","otherwise","ready","apply","then","terrainData","args","_minimumHeight","arguments","sampleTerrainMostDetailed","positions","Rectangle","fromCartographicArray","center","northeast","northwest","southeast","southwest","filter","position","description","deferred","_ready","layerName","defined","DeveloperError","errorEvent","Event","_eventHelper","EventHelper","credit","Credit","tileCacheService","TileCacheService","createDB","lastTile","undefined","DefaultProvider","defineProperties","hasVertexNormals","_heightmapWidth","urlofServer","index","lastIndexOf","substring","urlGetCapabilities","fetchXML","xml","querySelector","labelNode","name","textContent","linkNode","site","getAttribute","defaultValue","EMPTY_OBJECT","TerrainParser","OGCHelper","WCSParser","generate","TiledError","console","log","GeotiffToHeightmapTerrainData","arrayBuffer","size","tilingSc","width","height","parser","GeotiffParser","parseHeader","imageWidth","imageLength","heightBuffer","Float32Array","rect","tileXYToNativeRectangle","xSpacing","ySpacing","j","lon","lat","res","PCSToImage","pixelValue","getPixelValueOnDemand","HeightmapTerrainData","childrenMask","optionsHeihtmapTerrainData","buffer","childTileMask","resultat","urlGetCoverage","getHeightmapTerrainDataFromWCS","retour","isNaN","urlParam","heightMapWidth","heightMapHeight","replace","templateToURL","hasChildren","maxLevel","getTileData","tileData","myHeightmapTerrainData","data","evt","fetchArrayBuffer","image","myHeightmapBuffer","addTile","getLevelMaximumGeometricError","levelZeroMaximumGeometricError","adviced","toast","Util","getLocaleString","locale","type","msgType","INFO","minLevel","isTileInside","reject","pixelSize","hasWaterMask","waterMask","bbox","toRadians","coord","ulidx","scalingX","scalingY","abs","createInterpolateFunction","tileRequest","tilePositions","interpolateHeight","createMarkFailedFunction","doSamplingWhenReady","tileRequests","tileRequestSet","xy","positionToTileXY","key","toString","hasOwnProperty","tilePromises","requestPromise","tilePromise","doSampling","updatedPositions","setTimeout","objectStoreName","database","window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","webkitIDBTransaction","msIDBTransaction","IDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","alert","request","open","that","onsuccess","target","result","onerror","onupgradeneeded","thisDB","objectStoreNames","contains","createObjectStore","keyPath","createIndex","unique","info","webkitStorageInfo","queryUsageAndQuota","TEMPORARY","used","remaining","isReady","column","row","requestGet","transaction","objectStore","tile","guid","random","add","id","ex","tiffDataView","littleEndian","bitsPerPixel","samplesPerPixel","photometricInterpretation","compression","fileDirectories","sampleProperties","geoKeys","blocks","colorMapValues","colorMapSampleSize","isPixelArea","planarConfiguration","extraSamplesValues","numExtraSamples","isLittleEndian","BOM","getBytes","TypeError","hasTowel","RangeError","getLinearUnitsName","linearUnitsCode","LinearUnitsName","getAngularUnitsName","angularUnitsCode","AngularUnitsName","getModelTypeName","modelTypeCode","modelTypeName","getRasterTypeName","rasterTypeCode","rasterTypeName","getGeoKeyName","geoKey","geoKeyName","geoKeyTagNames","1024","1025","1026","2048","2049","2050","2051","2052","2053","2054","2055","2056","2057","2058","2059","2060","2061","2062","3072","3073","3074","3075","3076","3077","3078","3079","3080","3081","3082","3083","3084","3085","3086","3087","3088","3089","3090","3091","3092","3093","3094","3095","3096","4096","4097","4098","4099","getFieldTagName","fieldTag","fieldTagName","fieldTagNames","315","258","265","264","320","259","33432","306","338","266","289","288","291","290","316","270","257","256","271","281","280","272","254","274","262","284","296","278","277","305","279","273","255","263","282","283","326","327","343","328","433","434","269","336","321","346","347","285","297","317","319","532","339","340","341","559","330","292","293","325","323","324","322","301","318","344","286","529","531","530","345","287","37378","40961","36868","36867","34665","36864","33434","41728","37385","40960","33437","42016","37384","37500","37377","37510","33723","34675","700","42112","42113","34377","33550","33922","34264","34735","34736","34737","getPhotometricName","photometricNames","0","1","2","3","4","5","6","8","9","10","32844","32845","getCompressionTypeName","compressionNames","7","32766","32771","32773","32809","32895","32896","32897","32898","32908","32909","32946","32947","34661","34676","34677","34712","getFieldTypeName","fieldType","fieldTypeName","fieldTypeNames","11","12","getFieldTypeLength","fieldTypeLength","indexOf","getBits","numBits","byteOffset","bitOffset","newByteOffset","floor","totalBits","shiftRight","shiftLeft","rawBits","getUint8","getUint16","getUint32","bits","numBytes","offset","getFloat64","getSampleBytes","sampleFormat","getFloat32","Error","getFieldValues","typeCount","valueOffset","fieldValues","fieldValueSize","indexOffset","forEach","String","fromCharCode","clampColorSample","colorSample","bitsPerSample","multiplier","pow","clampAffineColorSample","vmin","vmax","makeRGBAFillValue","b","parseFileDirectory","numDirEntries","tiffFields","entryCount","values","nextIFDByteOffset","isGeotiff","fileDirectory","GeoKeyDirectory","getPlanarConfiguration","PlanarConfiguration","getSampleFormat","SampleFormat","getSampleMinMax","SMaxSampleValue","SMinSampleValue","isBlockLoaded","blockOffset","getBlock","addBlock","stripToLoad","block","hasStripOffset","StripOffsets","hasTileOffset","TileOffsets","parseGeoKeyDirectory","hdr_num_keys","geoKeyFields","iKey","ent_key","ent_location","ent_count","ent_val_offset","GeoDoubleParams","str","GeoAsciiParams","GTRasterTypeGeoKey","consoleTiffProperty","numoffsetValues","consoleGeotiffProperty","hdr_version","hdr_rev_major","hdr_rev_minor","consoleCRSProperty","getPixelSize","consoleTestGeorefImage","ImageToPCS","res2","tiffArrayBuffer","DataView","firstIFDByteOffset","ImageWidth","ImageLength","PhotometricInterpretation","SamplesPerPixel","BitsPerSample","bitsPerSampleValues","hasBytesPerSample","bytesPerSample","Compression","ColorMap","ExtraSamples","decodeBlock","stripOffset","stripByteCount","moduleDecompression","decodedBlock","jIncrement","pixel","sampleformat","hasBytesPerPixel","bytesPerPixel","m","sampleInfo","sampleOffset","LZString","decompressFromUint8Array","inflator","Inflate","isLast","err","msg","currentSample","sample","getHeader","blockLength","iterations","header","getInt8","currentByte","getDecompressionModule","require","loadPixels","FullPixelValues","k","getRGBAPixelValue","pixelSamples","red","green","blue","opacity","invertValue","samples","maxValue","colorMapIndex","getMinMaxPixelValue","getClosestPixelValue","blockToLoad","offsetValues","blockByteCountValues","rowsPerStrip","decompressionModule","xInBlock","yInBlock","blockWidth","blockInfo","RowsPerStrip","idBlocks","StripByteCounts","tileLength","TileLength","tileWidth","TileWidth","iTile","ceil","TileByteCounts","indice","ix","iy","getCRSCode","CRSCode","GTModelTypeGeoKey","search","test_consoleGeoKeys","Label","GeoKeyTab","getPixelValue","getLowResPixelValue","indice1","offsetX","indice2","indice3","indice4","averageValue","round","toCanvas","canvas","xmin","ymin","xmax","ymax","mycanvas","document","createElement","getContext","ctx","pixrgba","fillStyle","pixSample","fillRect","ModelPixelScale","p0","p1","p2","GTIFTiepointTranslate","gcp_count","directTransfo","ModelTiepoint","GetBBox","pCRS","ul","ur","ll","lr","lcoordinates","splice","projstring","WKID","EPSG","llidx","lridx","uridx","tiepoint_count","count","transform_count","ModelTransformation","transform","x_in","y_in","pixel_scale","tiepoints","inv_geotransform","gt_in","det","inv_det","gt_out","CRS","ellipsoid","Ellipsoid","WGS84","firstAxeIsLatitude","GeographicTilingScheme","supportedCRS","SupportedCRS","WebMercatorTilingScheme","FormatImage","format","extension","urlDescribeCoverage","proxy","getURL","getDescribeCoverage","convertToFloat","tab","parseFloat","coverage","corner","split","elm","lowerCorner","upperCorner","getCRS","elt","TerrainProvider","getEstimatedLevelZeroGeometricErrorForAHeightmap","_ellipsoid","min","getNumberOfXTilesAtLevel","isInTile","inside"],"mappings":"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","sourcesContent":["/* MergeTerrainProvider */\r\n(function () {    \r\n    /* d3-polygon: para validar si un punto está dentro de la cobertura de Navarra */\r\n    // https://d3js.org/d3-polygon/ Version 1.0.3. Copyright 2017 Mike Bostock.\r\n    !function (n, r) { \"object\" == typeof exports && \"undefined\" != typeof module ? r(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], r) : r(n.d3 = n.d3 || {}) }(this, function (n) { \"use strict\"; function r(n, r) { return n[0] - r[0] || n[1] - r[1] } function e(n) { for (var r = n.length, e = [0, 1], t = 2, o = 2; o < r; ++o) { for (; t > 1 && f(n[e[t - 2]], n[e[t - 1]], n[o]) <= 0;)--t; e[t++] = o } return e.slice(0, t) } var t = function (n) { for (var r, e = -1, t = n.length, o = n[t - 1], f = 0; ++e < t;) r = o, o = n[e], f += r[1] * o[0] - r[0] * o[1]; return f / 2 }, o = function (n) { for (var r, e, t = -1, o = n.length, f = 0, u = 0, l = n[o - 1], i = 0; ++t < o;) r = l, l = n[t], i += e = r[0] * l[1] - l[0] * r[1], f += (r[0] + l[0]) * e, u += (r[1] + l[1]) * e; return i *= 3, [f / i, u / i] }, f = function (n, r, e) { return (r[0] - n[0]) * (e[1] - n[1]) - (r[1] - n[1]) * (e[0] - n[0]) }, u = function (n) { if ((o = n.length) < 3) return null; var t, o, f = new Array(o), u = new Array(o); for (t = 0; t < o; ++t) f[t] = [+n[t][0], +n[t][1], t]; for (f.sort(r), t = 0; t < o; ++t) u[t] = [f[t][0], -f[t][1]]; var l = e(f), i = e(u), g = i[0] === l[0], a = i[i.length - 1] === l[l.length - 1], c = []; for (t = l.length - 1; t >= 0; --t) c.push(n[f[l[t]][2]]); for (t = +g; t < i.length - a; ++t) c.push(n[f[i[t]][2]]); return c }, l = function (n, r) { for (var e, t, o = n.length, f = n[o - 1], u = r[0], l = r[1], i = f[0], g = f[1], a = !1, c = 0; c < o; ++c) f = n[c], e = f[0], t = f[1], t > l != g > l && u < (i - e) * (l - t) / (g - t) + e && (a = !a), i = e, g = t; return a }, i = function (n) { for (var r, e, t = -1, o = n.length, f = n[o - 1], u = f[0], l = f[1], i = 0; ++t < o;) r = u, e = l, f = n[t], u = f[0], l = f[1], r -= u, e -= l, i += Math.sqrt(r * r + e * e); return i }; n.polygonArea = t, n.polygonCentroid = o, n.polygonHull = u, n.polygonContains = l, n.polygonLength = i, Object.defineProperty(n, \"__esModule\", { value: !0 }) });\r\n\r\n    function MergeTerrainProvider(options, view, fallbackOptions) {\r\n\r\n        this.noDataValue = options.noDataValue;\r\n        this.view = view;\r\n\r\n        this.commutingProvidersReady = false;\r\n        this.commutingProvidersPromises = cesium.when.defer();\r\n\r\n        this.surfaceHasTilesToRender = cesium.when.defer();\r\n        this.surfaceTilesToRender = 0;\r\n\r\n        this.fallback = fallbackOptions.fallback || [];\r\n        this.fallbackProvider = [];\r\n\r\n        this.fallbackProvider = this.fallback.map(function (options) {\r\n            return new cesium.WCSTerrainProvider(options, view);\r\n        });\r\n\r\n        this.defaultFallbackProvider = new cesium.EllipsoidTerrainProvider();\r\n        \r\n        this.attributions = {};\r\n        \r\n        if (options.attributions) {\r\n            this.attributions = options.attributions;\r\n            this.view.map.trigger(TC.Consts.event.TERRAINPROVIDERADD, { terrainProvider: this });\r\n        }\r\n\r\n        if (!(options.url instanceof cesium.Resource)) {\r\n            options.url = new cesium.Resource({\r\n                url: options.url.trim()\r\n            });\r\n        }\r\n\r\n        cesium.CesiumTerrainProvider.call(this, options);\r\n\r\n        this.boundaries = fallbackOptions.boundaries;\r\n\r\n        cesium.when.all([this._readyPromise, this.fallbackProvider[0].readyPromise, this.surfaceHasTilesToRender], function () {\r\n            this.commutingProvidersReady = true;\r\n            this.commutingProvidersPromises.resolve();            \r\n        }.bind(this))\r\n    }\r\n\r\n    MergeTerrainProvider.prototype = Object.create(cesium.CesiumTerrainProvider.prototype, {\r\n        fallback: { /* array con las opciones de los servicios WCS */\r\n            value: null,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        },\r\n        fallbackProvider: { /* array con los proveedores WCS */\r\n            value: null,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        },\r\n        defaultFallbackProvider: { /* proveedor de último recurso */\r\n            value: null,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        },\r\n        allReady: {\r\n            get: function () {\r\n                return this.commutingProvidersReady;\r\n            }\r\n        },\r\n        allReadyPromise: {\r\n            get: function () {\r\n                return this.commutingProvidersPromises;\r\n            }\r\n        }\r\n    });\r\n    MergeTerrainProvider.prototype.constructor = MergeTerrainProvider;\r\n\r\n    var loadPolygonContains = function () {\r\n        // https://d3js.org/d3-polygon/ Version 1.0.3. Copyright 2017 Mike Bostock.\r\n        !function (n, r) { \"object\" == typeof exports && \"undefined\" != typeof module ? r(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], r) : r(n.d3 = n.d3 || {}) }(this, function (n) { \"use strict\"; function r(n, r) { return n[0] - r[0] || n[1] - r[1] } function e(n) { for (var r = n.length, e = [0, 1], t = 2, o = 2; o < r; ++o) { for (; t > 1 && f(n[e[t - 2]], n[e[t - 1]], n[o]) <= 0;)--t; e[t++] = o } return e.slice(0, t) } var t = function (n) { for (var r, e = -1, t = n.length, o = n[t - 1], f = 0; ++e < t;) r = o, o = n[e], f += r[1] * o[0] - r[0] * o[1]; return f / 2 }, o = function (n) { for (var r, e, t = -1, o = n.length, f = 0, u = 0, l = n[o - 1], i = 0; ++t < o;) r = l, l = n[t], i += e = r[0] * l[1] - l[0] * r[1], f += (r[0] + l[0]) * e, u += (r[1] + l[1]) * e; return i *= 3, [f / i, u / i] }, f = function (n, r, e) { return (r[0] - n[0]) * (e[1] - n[1]) - (r[1] - n[1]) * (e[0] - n[0]) }, u = function (n) { if ((o = n.length) < 3) return null; var t, o, f = new Array(o), u = new Array(o); for (t = 0; t < o; ++t) f[t] = [+n[t][0], +n[t][1], t]; for (f.sort(r), t = 0; t < o; ++t) u[t] = [f[t][0], -f[t][1]]; var l = e(f), i = e(u), g = i[0] === l[0], a = i[i.length - 1] === l[l.length - 1], c = []; for (t = l.length - 1; t >= 0; --t) c.push(n[f[l[t]][2]]); for (t = +g; t < i.length - a; ++t) c.push(n[f[i[t]][2]]); return c }, l = function (n, r) { for (var e, t, o = n.length, f = n[o - 1], u = r[0], l = r[1], i = f[0], g = f[1], a = !1, c = 0; c < o; ++c) f = n[c], e = f[0], t = f[1], t > l != g > l && u < (i - e) * (l - t) / (g - t) + e && (a = !a), i = e, g = t; return a }, i = function (n) { for (var r, e, t = -1, o = n.length, f = n[o - 1], u = f[0], l = f[1], i = 0; ++t < o;) r = u, e = l, f = n[t], u = f[0], l = f[1], r -= u, e -= l, i += Math.sqrt(r * r + e * e); return i }; n.polygonArea = t, n.polygonCentroid = o, n.polygonHull = u, n.polygonContains = l, n.polygonLength = i, Object.defineProperty(n, \"__esModule\", { value: !0 }) });\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.isPointInDefaultBoundaries = function (cartographic) {\r\n        if (!d3.polygonContains) {\r\n            loadPolygonContains();\r\n        }\r\n\r\n        if (!d3.polygonContains(this.boundaries, [cesium.Math.toDegrees(cartographic.longitude), cesium.Math.toDegrees(cartographic.latitude)])) {            \r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.isInDefaultBoundaries = function (x, y, level) {\r\n        var self = this;\r\n\r\n        var toCheck = [];\r\n        var rectangle = this.tilingScheme.tileXYToRectangle(x, y, level);\r\n\r\n        toCheck.push(new cesium.Cartographic(rectangle.west, rectangle.south));\r\n        toCheck.push(new cesium.Cartographic(rectangle.west, rectangle.north));\r\n        toCheck.push(new cesium.Cartographic(rectangle.east, rectangle.south));\r\n        toCheck.push(new cesium.Cartographic(rectangle.east, rectangle.north));\r\n\r\n        for (var i = 0; i < toCheck.length; i++) {\r\n            if (!self.isPointInDefaultBoundaries(toCheck[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\r\n\r\n        ///* la disponibilidad del globo depende de que haya tiles renderizados/pendientes de rederizar. Si resuelvo la promesa al instanciar, \r\n        //   no al pedir tiles, llega a usar el globo antes de estar disponible.  */\r\n        if (this.surfaceTilesToRender > 5) {\r\n            this.surfaceHasTilesToRender.resolve();\r\n        }\r\n        this.surfaceTilesToRender++;\r\n\r\n        /* Si estamos en Navarra y el nivel que se va a pedir es mayor que el disponible en nuestro terreno nos ahorramos la petición */\r\n        if (level > this._availability._maximumLevel && this.isInDefaultBoundaries(x, y, level)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.getAttribution = function () {\r\n        var self = this;\r\n        \r\n        return self.attributions;\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.requestTileGeometry = function (x, y, level) {\r\n        const self = this;\r\n        let promise = cesium.when.defer();\r\n\r\n        const manageAttributions = function (provider) {\r\n            self.view.map.trigger(TC.Consts.event.TERRAINPROVIDERADD, { terrainProvider: provider });\r\n        };\r\n\r\n        const otherwise = function () {\r\n            if (self.fallbackProvider && self.fallbackProvider[0].ready) {\r\n                self.fallbackProvider[0].requestTileGeometry.apply(self, [x, y, level])\r\n                    .then(function (terrainData) {\r\n                        manageAttributions(self.fallbackProvider[0]);\r\n                        promise.resolve(terrainData);\r\n                    }).otherwise(function () {\r\n                        promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n                    });\r\n            } else {\r\n                promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n            }\r\n        };\r\n\r\n        // así controlamos que las peticiones fuera de Navarra y mayor nivel que el soportado no se pidan y\r\n        // vamos directamente al proveedor de respaldo.\r\n        if (level > this._availability._maximumLevel) {\r\n            otherwise();\r\n        } else if (!this.isInDefaultBoundaries(x, y, level)) {\r\n            otherwise();\r\n        } else {\r\n            cesium.CesiumTerrainProvider.prototype.requestTileGeometry.apply(self, [x, y, level])\r\n                .then(function (args, terrainData) {\r\n                    if (terrainData._minimumHeight === self.noDataValue) {\r\n                        if (self.fallbackProvider && self.fallbackProvider[0].ready) {\r\n                            self.fallbackProvider[0].requestTileGeometry.apply(self, args)\r\n                                .then(function (terrainData) {\r\n                                    manageAttributions(self.fallbackProvider[0]);\r\n                                    promise.resolve(terrainData);\r\n                                }).otherwise(function () {\r\n                                    promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n                                });\r\n                        } else {\r\n                            promise.resolve(self.defaultFallbackProvider.requestTileGeometry([x, y, level]));\r\n                        }\r\n                    } else {\r\n                        manageAttributions(self);\r\n                        promise.resolve(terrainData);\r\n                    }\r\n                }.bind(this, arguments))\r\n                .otherwise(otherwise);\r\n        }\r\n\r\n        return promise.then(function (terrainData) {\r\n            return terrainData;\r\n        });\r\n    };\r\n\r\n    MergeTerrainProvider.prototype.sampleTerrainMostDetailed = function (positions) {\r\n        var rectangle = cesium.Rectangle.fromCartographicArray(positions);\r\n        var toCheck = [cesium.Rectangle.center(rectangle),\r\n\t\t\t\t\t   cesium.Rectangle.northeast(rectangle),\r\n\t\t\t\t\t   cesium.Rectangle.northwest(rectangle),\r\n\t\t\t\t\t   cesium.Rectangle.southeast(rectangle),\r\n\t\t\t\t\t   cesium.Rectangle.southwest(rectangle)];\r\n\r\n        if (toCheck.filter(function (position) { return !this.isPointInDefaultBoundaries(position); }.bind(this)).length === 0) {\r\n            return cesium.sampleTerrainMostDetailed(this, positions);\r\n        } else {\r\n            return this.fallbackProvider[0].sampleTerrainMostDetailed(positions);\r\n        }\r\n\r\n    }\r\n\r\n    cesium.MergeTerrainProvider = MergeTerrainProvider;\r\n})();\r\n/*\r\nhttps://github.com/xlhomme/WCSTerrainProvider/tree/master/\r\nModificado por GLS\r\nWCSTerrainProvider  */\r\n(function () {\r\n    var WCSTerrainProvider = function WCSTerrainProvider(description, view) {\r\n\r\n        this.view = view;\r\n\r\n        var deferred = cesium.when.defer();\r\n        this._ready = false;\r\n        this._readyPromise = deferred;\r\n\r\n        this.url = description.url;\r\n        this.layerName = description.layerName;\r\n\r\n        if (!cesium.defined(description)) {\r\n            throw new cesium.DeveloperError('description is required.');\r\n        }\r\n        var errorEvent = new cesium.Event();\r\n\r\n        this._eventHelper = new cesium.EventHelper();\r\n\r\n        var credit = description.credit;\r\n        if (typeof credit === 'string') {\r\n            credit = new cesium.Credit(credit);\r\n        }\r\n\r\n        this.tileCacheService = new TileCacheService('WCSTiles');\r\n        this.tileCacheService.createDB();\r\n\r\n        this.lastTile = undefined;\r\n        this.ready = false;\r\n\r\n        this.DefaultProvider = new cesium.EllipsoidTerrainProvider();\r\n\r\n        Object.defineProperties(this, {\r\n            errorEvent: {\r\n                get: function () {\r\n                    return errorEvent;\r\n                }\r\n            },\r\n            credit: {\r\n                get: function () {\r\n                    return credit;\r\n                }\r\n            },\r\n            hasVertexNormals: {\r\n                get: function () {\r\n                    return false;\r\n                }\r\n            },\r\n            readyPromise: {\r\n                get: function () {\r\n                    return this._readyPromise.promise;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._heightmapWidth = 65;\r\n\r\n        this.noDataValue = description.noDataValue;\r\n\r\n        // atribuciones\r\n        if (cesium.defined(this.url)) {\r\n            var urlofServer = this.url;\r\n            var index = urlofServer.lastIndexOf(\"?\");\r\n            if (index > -1) {\r\n                urlofServer = urlofServer.substring(0, index);\r\n            }\r\n        }\r\n\r\n        var urlGetCapabilities = urlofServer + '?SERVICE=WCS&VERSION=1.0.0&request=GetCapabilities';\r\n        cesium.when(cesium.Resource.fetchXML({\r\n            url: urlGetCapabilities\r\n        }), function (xml) {\r\n            if (xml.querySelector('Service')) {\r\n                this.attributions = {};\r\n                var labelNode = xml.querySelector('Service').querySelector('label');\r\n                if (labelNode) {\r\n                    this.attributions.name = labelNode.textContent.trim();\r\n                }\r\n                var linkNode = xml.querySelector('Service').querySelector('metadataLink');\r\n                if (linkNode) {\r\n                    this.attributions.site = linkNode.getAttribute('about');\r\n                }                \r\n            }\r\n        }.bind(this));\r\n\r\n        description = cesium.defaultValue(description, cesium.defaultValue.EMPTY_OBJECT);\r\n        var promise = OGCHelper.WCSParser.generate(description);\r\n        TerrainParser(promise, this);\r\n    };\r\n\r\n    WCSTerrainProvider.TiledError = function () {\r\n        console.log(\"TiledError\");\r\n    };\r\n\r\n    WCSTerrainProvider.GeotiffToHeightmapTerrainData = function (noDataValue, arrayBuffer, size, x, y, level, tilingSc) {\r\n\r\n        if (typeof (size) == \"number\") {\r\n            size = { width: size, height: size };\r\n        }\r\n\r\n        var parser = new GeotiffParser();\r\n        parser.parseHeader(arrayBuffer);\r\n        var width = parser.imageWidth;\r\n        var height = parser.imageLength;\r\n\r\n        //console.log(\"Level \" , level , \"w\" ,size.width, \"h\" , size.height);\r\n\r\n        var index = 0;\r\n        var heightBuffer = new Float32Array(size.height * size.width);\r\n\r\n        // Convert pixelValue to heightBuffer \r\n        //--------------------------------------\r\n        // We need to return a Heighmap of size 65x65\r\n        // The requested Tile from WCS should be cloth but not 65x65 \r\n        // We need to work in Native coordinate then get the pixel from the Parser.\r\n\r\n        // Here we need to check if the tilingScheme.CRS is the same of the Image \r\n        // If no we need to convert \r\n        // But It will to slow the processus then we should assume tilingScheme has been set \r\n        // with the CRS of the image \r\n\r\n        if (size.height != height || size.width != width) {\r\n            var rect = tilingSc.tileXYToNativeRectangle(x, y, level);\r\n            var xSpacing = (rect.east - rect.west) / size.width;\r\n            var ySpacing = (rect.north - rect.south) / size.height;\r\n\r\n            for (var j = 0; j < size.height; j++)\r\n                for (var i = 0; i < size.width; i++) {\r\n                    // Transform i,j of the Heighmap into res[1], res[2] of the downloaded image\r\n                    // if downloaded image is the same zize of heightBuffer this convertion wouldn't be done\r\n\r\n                    var lon = rect.west + xSpacing * i;\r\n                    var lat = rect.north - ySpacing * j;\r\n                    var res = parser.PCSToImage(lon, lat);\r\n                    if (res[0] == 1) {\r\n                        var pixelValue = parser.getPixelValueOnDemand(res[1], res[2]);\r\n                        if (!pixelValue || (pixelValue && pixelValue[0] <= noDataValue)) {\r\n                            heightBuffer[index] = 0.0;\r\n                        } else {\r\n                            heightBuffer[index] = pixelValue[0];\r\n                        }\r\n                    }\r\n                    else {\r\n                        heightBuffer[index] = 0.0;\r\n                    }\r\n                    index++;\r\n                }\r\n        }\r\n        else {\r\n            for (var j = 0; j < size.height; j++)\r\n                for (var i = 0; i < size.width; i++) {\r\n                    var pixelValue = parser.getPixelValueOnDemand(i, j);\r\n                    if (!pixelValue || (pixelValue && pixelValue[0] <= noDataValue)) {\r\n                        heightBuffer[index] = 0.0;\r\n                    } else {\r\n                        heightBuffer[index] = pixelValue[0];\r\n                    }\r\n                    index++;\r\n                }\r\n        }\r\n\r\n        return heightBuffer;\r\n    };\r\n\r\n    WCSTerrainProvider.HeightmapTerrainData = function (heightBuffer, size, childrenMask) {\r\n        if (typeof (size) == \"number\") {\r\n            size = { width: size, height: size };\r\n        }\r\n\r\n        if (!cesium.defined(heightBuffer)) {\r\n            throw new cesium.DeveloperError(\"no good size\");\r\n        }\r\n        var optionsHeihtmapTerrainData = {\r\n            buffer: heightBuffer,\r\n            width: size.width,\r\n            height: size.height,\r\n            childTileMask: childrenMask\r\n        };\r\n\r\n        return new cesium.HeightmapTerrainData(optionsHeihtmapTerrainData);\r\n    };\r\n\r\n    WCSTerrainProvider.prototype.getAttribution = function () {\r\n        var self = this;\r\n        \r\n        return self.attributions;\r\n    };\r\n\r\n    function TerrainParser(promise, provider) {\r\n        cesium.when(promise, function (resultat) {\r\n\r\n            if (cesium.defined(resultat) && (resultat.ready)) {\r\n                provider._ready = true;\r\n                provider._readyPromise.resolve(true);\r\n\r\n                if (cesium.defined(resultat.urlGetCoverage)) {\r\n\r\n                    resultat.getHeightmapTerrainDataFromWCS = function (x, y, level) {\r\n                        var retour;\r\n                        if (!isNaN(x + y + level)) {\r\n                            var urlGetCoverage = templateToURL(resultat.urlGetCoverage, x, y, level, provider);\r\n\r\n                            var hasChildren = 0;\r\n                            if (level < resultat.maxLevel) {\r\n                                // no need to test for all child --> we are in the case of isTileInside\r\n                                hasChildren |= 1;\r\n                                hasChildren |= 2;\r\n                                hasChildren |= 4;\r\n                                hasChildren |= 8;\r\n                            }\r\n\r\n                            // If the requested tile is the same as the last then return it\r\n                            if (provider.lastTile != undefined &&\r\n                                provider.lastTile.x == x &&\r\n                                provider.lastTile.y == y &&\r\n                                provider.lastTile.level == level) {\r\n                                //console.log(\"get  Last Tile \",x, y, level);\r\n                                return provider.lastTile.value;\r\n                            }\r\n\r\n                            // If the requested tile is in the TileCacheService then return it\r\n                            // Otherwise use WCS Get Coverage to request the tile                              \r\n                            retour = cesium.when(provider.tileCacheService.getTileData(x, y, level), function (tileData) {\r\n\r\n                                var myHeightmapTerrainData = WCSTerrainProvider.HeightmapTerrainData(tileData.data, {\r\n                                    width: provider._heightmapWidth,\r\n                                    height: provider._heightmapWidth\r\n                                }, hasChildren);\r\n\r\n                                provider.lastTile = { 'x': x, 'y': y, 'level': level, 'value': myHeightmapTerrainData };\r\n\r\n                                return myHeightmapTerrainData;\r\n\r\n                            }).otherwise(function (evt) {\r\n\r\n                                return cesium.when(cesium.Resource.fetchArrayBuffer({ url: urlGetCoverage }), function (image) {\r\n\r\n                                    var myHeightmapBuffer = WCSTerrainProvider.GeotiffToHeightmapTerrainData(provider.noDataValue, image, {\r\n                                        width: provider._heightmapWidth,\r\n                                        height: provider._heightmapWidth\r\n                                    }, x, y, level, provider.tilingScheme);\r\n\r\n                                    provider.tileCacheService.addTile(x, y, level, myHeightmapBuffer);\r\n\r\n                                    var myHeightmapTerrainData = WCSTerrainProvider.HeightmapTerrainData(myHeightmapBuffer, {\r\n                                        width: provider._heightmapWidth,\r\n                                        height: provider._heightmapWidth\r\n                                    }, hasChildren);\r\n\r\n                                    provider.lastTile = { 'x': x, 'y': y, 'level': level, 'value': myHeightmapTerrainData };\r\n\r\n                                    return myHeightmapTerrainData;\r\n\r\n                                }).otherwise(function () {\r\n\r\n                                    return provider.DefaultProvider.requestTileGeometry(x, y, level);\r\n                                });\r\n                            });\r\n                        }\r\n                        return retour;\r\n                    };\r\n                }\r\n\r\n                provider.getLevelMaximumGeometricError = function (level) {\r\n                    return resultat.levelZeroMaximumGeometricError / (1 << level);\r\n                };\r\n\r\n                provider.requestTileGeometry = function (x, y, level) {\r\n                    var retour;\r\n\r\n                    if (cesium.defined(resultat.getHeightmapTerrainDataFromWCS)) {\r\n\r\n                        if (!provider.adviced && level > 14) {                            \r\n                            provider.view.map.toast(TC.Util.getLocaleString(provider.view.map.options.locale, \"threed.terrainAdvice\"), { type: TC.Consts.msgType.INFO });\r\n                            provider.adviced = true;\r\n                        }\r\n\r\n                        if (level <= resultat.minLevel &&\r\n                            level >= resultat.maxLevel) {\r\n\r\n                            if (resultat.isTileInside(x, y, level, provider) == true) {                                \r\n                                retour = resultat.getHeightmapTerrainDataFromWCS(x, y, level);\r\n                            } else {                                \r\n                                retour = cesium.when.defer().reject();\r\n                            }\r\n                        } else {\r\n                            retour = cesium.when.defer().reject();\r\n                        }\r\n                    } else {\r\n                        retour = cesium.when.defer().reject();\r\n                    }\r\n\r\n                    return retour;\r\n                }\r\n\r\n                Object.defineProperties(provider, {\r\n                    tilingScheme: {\r\n                        get: function () {\r\n                            return resultat.tilingScheme;\r\n                        }\r\n                    },\r\n                    ready: {\r\n                        get: function () {\r\n                            return resultat.ready;\r\n                        }\r\n                    },\r\n                    pixelSize: {\r\n                        get: function () {\r\n                            return resultat.pixelSize;\r\n                        }\r\n                    },\r\n                    hasWaterMask: {\r\n                        get: function () {\r\n                            return resultat.waterMask;\r\n                        }\r\n                    },\r\n                    heightMapHeight: {\r\n\r\n                        get: function () {\r\n                            return resultat.heightMapHeight;\r\n                        }\r\n                    },\r\n                    heightMapWidth: {\r\n                        get: function () {\r\n                            return resultat.heightMapWidth;\r\n                        }\r\n                    },\r\n                    getTileDataAvailable: {\r\n                        get: function () {\r\n                            return resultat.getTileDataAvailable;\r\n                        }\r\n                    },\r\n                    minLevel: {\r\n                        get: function () {\r\n                            return resultat.minLevel;\r\n                        }\r\n                    },\r\n                    maxLevel: {\r\n                        get: function () {\r\n                            return resultat.maxLevel;\r\n                        }\r\n                    }\r\n\r\n                });\r\n\r\n                if (resultat.minLevel == undefined || resultat.maxLevel == undefined) {\r\n                    // Test pour savoir dans quelle tuile se trouve mon WCS\r\n                    var bbox = resultat.bbox;\r\n                    var pgeo = new cesium.Cartographic(\r\n                        cesium.Math.toRadians(bbox.coord[bbox.ulidx][0]),\r\n                        cesium.Math.toRadians(bbox.coord[bbox.ulidx][1]),\r\n                        0);\r\n                    resultat.minLevel = 30;\r\n                    resultat.maxLevel = 0;\r\n\r\n                    for (var j = 0; j < 30; j++) {\r\n                        // var tile = provider.tilingScheme.positionToTileXY(pgeo,j);\r\n                        //var rect = provider.tilingScheme.tileXYToNativeRectangle(tile.x, tile.y, j);\r\n                        var rect = provider.tilingScheme.tileXYToNativeRectangle(0, 0, j);\r\n                        var xSpacing = (rect.east - rect.west) / (provider.heightMapWidth - 1);\r\n                        var ySpacing = (rect.north - rect.south) / (provider.heightMapHeight - 1);\r\n                        var scalingX = provider.pixelSize[0] / xSpacing\r\n                        var scalingY = provider.pixelSize[1] / ySpacing;                        \r\n\r\n                        if (scalingX < 10 && scalingX > 1 / 10 && Math.abs(scalingY) < 10 && Math.abs(scalingY) > 1 / 10) {\r\n                            if (j < resultat.minLevel) resultat.minLevel = j;\r\n                            if (j > resultat.maxLevel) resultat.maxLevel = j;\r\n\r\n                        }\r\n                    }                    \r\n                }\r\n            } else {\r\n                console.log(\"Error al obtener terreno fuera de Navarra\");\r\n            }\r\n        });\r\n    }\r\n\r\n    function templateToURL(urlParam, x, y, level, provider) {\r\n        var rect = provider.tilingScheme.tileXYToNativeRectangle(x, y, level);\r\n        var xSpacing = (rect.east - rect.west) / (provider.heightMapWidth - 1);\r\n        var ySpacing = (rect.north - rect.south) / (provider.heightMapHeight - 1);\r\n\r\n        rect.west -= xSpacing * 0.5;\r\n        rect.east += xSpacing * 0.5;\r\n        rect.south -= ySpacing * 0.5;\r\n        rect.north += ySpacing * 0.5;\r\n\r\n        return urlParam.replace(\"{south}\", rect.south).replace(\"{north}\", rect.north).replace(\"{west}\", rect.west).replace(\"{east}\", rect.east);\r\n    }\r\n\r\n    function doSampling(terrainProvider, level, positions) {\r\n        var tilingScheme = terrainProvider.tilingScheme;\r\n\r\n        var i;\r\n\r\n        // Sort points into a set of tiles\r\n        var tileRequests = []; // Result will be an Array as it's easier to work with\r\n        var tileRequestSet = {}; // A unique set\r\n        for (i = 0; i < positions.length; ++i) {\r\n            var xy = tilingScheme.positionToTileXY(positions[i], level);\r\n            var key = xy.toString();\r\n\r\n            if (!tileRequestSet.hasOwnProperty(key)) {\r\n                // When tile is requested for the first time\r\n                var value = {\r\n                    x: xy.x,\r\n                    y: xy.y,\r\n                    level: level,\r\n                    tilingScheme: tilingScheme,\r\n                    terrainProvider: terrainProvider,\r\n                    positions: []\r\n                };\r\n                tileRequestSet[key] = value;\r\n                tileRequests.push(value);\r\n            }\r\n\r\n            // Now append to array of points for the tile\r\n            tileRequestSet[key].positions.push(positions[i]);\r\n        }\r\n\r\n        // Send request for each required tile\r\n        var tilePromises = [];\r\n        for (i = 0; i < tileRequests.length; ++i) {\r\n            var tileRequest = tileRequests[i];\r\n            var requestPromise = tileRequest.terrainProvider.requestTileGeometry(tileRequest.x, tileRequest.y, tileRequest.level, false);\r\n            var tilePromise = cesium.when(requestPromise, createInterpolateFunction(tileRequest), createMarkFailedFunction(tileRequest));\r\n            tilePromises.push(tilePromise);\r\n        }\r\n\r\n        return cesium.when.all(tilePromises, function () {\r\n            return positions;\r\n        });\r\n    }\r\n\r\n    function createInterpolateFunction(tileRequest) {\r\n        var tilePositions = tileRequest.positions;\r\n        var rectangle = tileRequest.tilingScheme.tileXYToRectangle(tileRequest.x, tileRequest.y, tileRequest.level);\r\n        return function (terrainData) {\r\n            for (var i = 0; i < tilePositions.length; ++i) {\r\n                var position = tilePositions[i];\r\n                position.height = terrainData.interpolateHeight(rectangle, position.longitude, position.latitude);\r\n            }\r\n        };\r\n    }\r\n\r\n    function createMarkFailedFunction(tileRequest) {\r\n        var tilePositions = tileRequest.positions;\r\n        return function () {\r\n            for (var i = 0; i < tilePositions.length; ++i) {\r\n                var position = tilePositions[i];\r\n                position.height = undefined;\r\n            }\r\n        };\r\n    }\r\n\r\n    WCSTerrainProvider.prototype.sampleTerrainMostDetailed = function (positions) {\r\n        var self = this;\r\n\r\n        var deferred = cesium.when.defer();\r\n\r\n        function doSamplingWhenReady() {\r\n            if (self.ready) {/* provisional: el nivel se puede extraer ¿? */\r\n                cesium.when(doSampling(self, 16, positions), function (updatedPositions) {\r\n                    deferred.resolve(updatedPositions);\r\n                });\r\n            } else {\r\n                setTimeout(doSamplingWhenReady, 10);\r\n            }\r\n        }\r\n\r\n        doSamplingWhenReady();\r\n\r\n        return deferred;\r\n    }\r\n\r\n    cesium.WCSTerrainProvider = WCSTerrainProvider;\r\n\r\n    function TileCacheService(objectStoreName) {\r\n        this.database = null;\r\n        this.objectStoreName = objectStoreName;\r\n    }\r\n\r\n    TileCacheService.prototype = {\r\n        /* createDB : create the scheme of the database  */\r\n        createDB: function () {\r\n\r\n            // In the following line, you should include the prefixes of implementations you want to test.\r\n            window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n            // DON'T use \"var indexedDB = ...\" if you're not in a function.\r\n            // Moreover, you may need references to some window.IDB* objects:\r\n            window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\r\n            window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\r\n            if (!window.indexedDB) {\r\n                window.alert(\"Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.\");\r\n            }\r\n\r\n            var request = window.indexedDB.open('TileCacheService', 1);\r\n            var that = this;\r\n            request.onsuccess = function (evt) {\r\n                that.database = evt.target.result;\r\n            };\r\n            request.onerror = function (evt) {\r\n                console.log(\"IndexedDB--> onerror \");\r\n            };\r\n            request.onupgradeneeded = function (evt) {\r\n                var thisDB = evt.target.result;\r\n                if (!thisDB.objectStoreNames.contains('WCSTiles')) {\r\n                    var store = thisDB.createObjectStore('WCSTiles', { keyPath: 'id' });\r\n                    store.createIndex(\"tile\", [\"level\", \"row\", \"column\"], { unique: true });\r\n                }\r\n\r\n                if (!thisDB.objectStoreNames.contains('ImageTiles')) {\r\n                    var store = thisDB.createObjectStore('ImageTiles', { keyPath: 'id' });\r\n                    store.createIndex(\"tile\", [\"level\", \"row\", \"column\"], { unique: true });\r\n                }\r\n\r\n            };\r\n        },\r\n        /* info on available storage */\r\n        info: function () {\r\n            // Request storage usage and capacity left\r\n            window.webkitStorageInfo.queryUsageAndQuota(window.TEMPORARY, //the type can be either TEMPORARY or PERSISTENT\r\n                function (used, remaining) {\r\n                    console.log(\"Used quota: \" + used + \", remaining quota: \" + remaining);\r\n                }, function (e) {\r\n                    console.log('Error', e);\r\n                });\r\n        },\r\n        /* isReady when objectStore has been created  */\r\n        isReady: function () {\r\n            if (!this.database)\r\n                return false;\r\n\r\n            return this.database.objectStoreNames.contains(this.objectStoreName);\r\n        },\r\n        /* get the requested tile */\r\n        getTileData: function (column, row, level) {\r\n\r\n            var deferred = cesium.when.defer();\r\n\r\n            if (!this.database) {\r\n                console.log(\"getTileData no database\", this.database);\r\n                deferred.reject(\"no IndexedDB\");\r\n            }\r\n            else {\r\n\r\n                var transaction = this.database.transaction(this.objectStoreName);\r\n                var tileIndex = transaction.objectStore(this.objectStoreName).index(\"tile\");\r\n\r\n                var requestGet = tileIndex.get([level, row, column]);\r\n                requestGet.onsuccess = function (evt) {\r\n                    var tile = null;\r\n                    if (evt.target.result) {\r\n                        tile = { data: evt.target.result.tileData };\r\n                        deferred.resolve(tile);\r\n                    }\r\n                    else {\r\n                        deferred.reject(\"no tile\");\r\n                    }\r\n\r\n                }\r\n\r\n                requestGet.onerror = function (evt) {\r\n                    deferred.reject(\"no tile get failed\");\r\n                }\r\n            }\r\n\r\n            return deferred.promise;\r\n        },\r\n        addTile: function (x, y, level, data) {\r\n\r\n            if (this.database) {\r\n                var transaction = this.database.transaction(this.objectStoreName, \"readwrite\");\r\n                try {\r\n                    // the transaction could abort because of a QuotaExceededError error\r\n                    var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8; return v.toString(16); });\r\n                    transaction.objectStore(this.objectStoreName).add({ id: guid, level: level, row: y, column: x, tileData: data });\r\n                    //\tconsole.log(\"addTile \");\r\n                }\r\n                catch (ex) {\r\n                    console.log(ex);\r\n                }\r\n\r\n            }\r\n            else\r\n                console.log(\"addTile no database\");\r\n\r\n        }\r\n    };\r\n\r\n    function GeotiffParser() {\r\n        this.tiffDataView = undefined;\r\n        this.littleEndian = undefined;\r\n        this.imageWidth = undefined;\r\n        this.imageLength = undefined;\r\n        this.bitsPerPixel = undefined;\r\n        this.samplesPerPixel = undefined;\r\n        this.photometricInterpretation = undefined;\r\n        this.compression = undefined;\r\n        this.fileDirectories = [];\r\n        this.sampleProperties = [];\r\n        this.geoKeys = [];\r\n        this.blocks = [];\r\n        this.colorMapValues = [];\r\n        this.colorMapSampleSize = undefined;\r\n        this.isPixelArea = 0;\r\n        this.planarConfiguration = 1;\r\n        this.extraSamplesValues = [];\r\n        this.numExtraSamples = 0;\r\n\r\n    }\r\n\r\n    /* GeotiffParser */\r\n    GeotiffParser.prototype = {\r\n\r\n        /* isLittleEndian from Tiff-js  */\r\n        isLittleEndian: function () {\r\n            // Get byte order mark.\r\n            var BOM = this.getBytes(2, 0);\r\n\r\n            // Find out the endianness.\r\n            if (BOM === 0x4949) {\r\n                this.littleEndian = true;\r\n            } else if (BOM === 0x4D4D) {\r\n                this.littleEndian = false;\r\n            } else {\r\n                console.log(BOM);\r\n                throw TypeError(\"Invalid byte order value.\");\r\n            }\r\n\r\n            return this.littleEndian;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        hasTowel: function () {\r\n            // Check for towel.\r\n            if (this.getBytes(2, 2) !== 42) {\r\n                throw RangeError(\"You forgot your towel!\");\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        /* Translate LinearCode to string  */\r\n        getLinearUnitsName: function (linearUnitsCode) {\r\n            var LinearUnitsName;\r\n            switch (linearUnitsCode) {\r\n                case 0:\r\n                    LinearUnitsName = 'undefined';\r\n                    break;\r\n                case 9001:\r\n                    LinearUnitsName = 'Linear_Meter';\r\n                    break;\r\n                case 9002:\r\n                    LinearUnitsName = 'Linear_Foot';\r\n                    break;\r\n                case 9003:\r\n                    LinearUnitsName = 'Linear_Foot_US_Survey';\r\n                    break;\r\n                case 9004:\r\n                    LinearUnitsName = 'Linear_Foot_Modified_American';\r\n                    break;\r\n                case 9005:\r\n                    LinearUnitsName = 'Linear_Foot_Clarke ';\r\n                    break;\r\n                case 9006:\r\n                    LinearUnitsName = 'Linear_Foot_Indian ';\r\n                    break;\r\n                case 9007:\r\n                    LinearUnitsName = 'Linear_Link ';\r\n                    break;\r\n                case 9008:\r\n                    LinearUnitsName = 'Linear_Link_Benoit ';\r\n                    break;\r\n                case 9009:\r\n                    LinearUnitsName = 'Linear_Link_Sears';\r\n                    break;\r\n                case 9010:\r\n                    LinearUnitsName = 'Linear_Chain_Benoit';\r\n                    break;\r\n                case 9011:\r\n                    LinearUnitsName = 'Linear_Chain_Sears';\r\n                    break;\r\n                case 9012:\r\n                    LinearUnitsName = 'Linear_Yard_Sears';\r\n                    break;\r\n                case 9013:\r\n                    LinearUnitsName = 'Linear_Yard_Indian';\r\n                    break;\r\n                case 9014:\r\n                    LinearUnitsName = 'Linear_Fathom';\r\n                    break;\r\n                case 9015:\r\n                    LinearUnitsName = 'user-Linear_Mile_International_Nautical';\r\n                    break;\r\n                default:\r\n                    if (linearUnitsCode >= 9000 && linearUnitsCode <= 9099) LinearUnitsName = 'EPSG Linear Units';\r\n                    else if (linearUnitsCode >= 9100 && linearUnitsCode <= 9199) LinearUnitsName = 'EPSG Angular Units';\r\n                    else if (linearUnitsCode = 32767) LinearUnitsName = 'user-defined unit';\r\n                    else if (linearUnitsCode > 32767) LinearUnitsName = 'Private User Implementations';\r\n                    break;\r\n            }\r\n            return LinearUnitsName;\r\n        },\r\n\r\n        /* Translate LinearCode to string  */\r\n        getAngularUnitsName: function (angularUnitsCode) {\r\n            var AngularUnitsName;\r\n            switch (angularUnitsCode) {\r\n                case 0:\r\n                    AngularUnitsName = 'undefined';\r\n                    break;\r\n                case 9001:\r\n                    AngularUnitsName = 'Angular_Radian';\r\n                    break;\r\n                case 9002:\r\n                    AngularUnitsName = 'Angular_Degree';\r\n                    break;\r\n                case 9003:\r\n                    AngularUnitsName = 'Angular_Arc_Minute';\r\n                    break;\r\n                case 9004:\r\n                    AngularUnitsName = 'Angular_Arc_Second';\r\n                    break;\r\n                case 9005:\r\n                    AngularUnitsName = 'Angular_Grad';\r\n                    break;\r\n                case 9006:\r\n                    AngularUnitsName = 'Angular_Gon';\r\n                    break;\r\n                case 9007:\r\n                    AngularUnitsName = 'Angular_DMS';\r\n                    break;\r\n                case 9008:\r\n                    AngularUnitsName = 'Angular_DMS_Hemisphere';\r\n                    break;\r\n                default:\r\n                    if (angularUnitsCode >= 9000 && angularUnitsCode <= 9099) AngularUnitsName = 'EPSG Linear Units';\r\n                    else if (angularUnitsCode >= 9100 && angularUnitsCode <= 9199) AngularUnitsName = 'EPSG Angular Units';\r\n                    else if (angularUnitsCode = 32767) AngularUnitsName = 'user-defined unit';\r\n                    else if (angularUnitsCode > 32767) AngularUnitsName = 'Private User Implementations';\r\n                    break;\r\n            }\r\n            return AngularUnitsName;\r\n        },\r\n\r\n        /* Translate modelTypeCode to string  */\r\n        getModelTypeName: function (modelTypeCode) {\r\n            var modelTypeName;\r\n            switch (modelTypeCode) {\r\n                case 0:\r\n                    modelTypeName = 'undefined';\r\n                    break;\r\n                case 1:\r\n                    modelTypeName = 'ModelTypeProjected';\r\n                    break;\r\n                case 2:\r\n                    modelTypeName = 'ModelTypeGeographic';\r\n                    break;\r\n                case 3:\r\n                    modelTypeName = 'ModelTypeGeocentric';\r\n                    break;\r\n                case 32767:\r\n                    modelTypeName = 'user-defined';\r\n                    break;\r\n                default:\r\n                    if (modelTypeCode < 32767) modelTypeName = 'GeoTIFF Reserved Codes';\r\n                    else if (modelTypeCode > 32767) modelTypeName = 'Private User Implementations';\r\n                    break;\r\n            }\r\n            return modelTypeName;\r\n        },\r\n\r\n        /* Translate rasterTypeCode to string  */\r\n        getRasterTypeName: function (rasterTypeCode) {\r\n            var rasterTypeName;\r\n            switch (rasterTypeCode) {\r\n                case 0:\r\n                    rasterTypeName = 'undefined';\r\n                    break;\r\n                case 1:\r\n                    rasterTypeName = 'RasterPixelIsArea';\r\n                    break;\r\n                case 2:\r\n                    rasterTypeName = 'RasterPixelIsPoint';\r\n                    break;\r\n                case 32767:\r\n                    rasterTypeName = 'user-defined';\r\n                    break;\r\n                default:\r\n                    if (rasterTypeCode < 32767) rasterTypeName = 'GeoTIFF Reserved Codes';\r\n                    else if (rasterTypeCode > 32767) rasterTypeName = 'Private User Implementations';\r\n                    break;\r\n            }\r\n            return rasterTypeName;\r\n        },\r\n\r\n        /* Translate GeoKey to string  */\r\n        getGeoKeyName: function (geoKey) {\r\n            var geoKeyTagNames = {\r\n                1024: 'GTModelTypeGeoKey',\r\n                1025: 'GTRasterTypeGeoKey',\r\n                1026: 'GTCitationGeoKey',\r\n                2048: 'GeographicTypeGeoKey',\r\n                2049: 'GeogCitationGeoKey',\r\n                2050: 'GeogGeodeticDatumGeoKey',\r\n                2051: 'GeogPrimeMeridianGeoKey',\r\n                2052: 'GeogLinearUnitsGeoKey',\r\n                2053: 'GeogLinearUnitSizeGeoKey',\r\n                2054: 'GeogAngularUnitsGeoKey',\r\n                2055: 'GeogAngularUnitSizeGeoKey',\r\n                2056: 'GeogEllipsoidGeoKey',\r\n                2057: 'GeogSemiMajorAxisGeoKey',\r\n                2058: 'GeogSemiMinorAxisGeoKey',\r\n                2059: 'GeogInvFlatteningGeoKey',\r\n                2060: 'GeogAzimuthUnitsGeoKey',\r\n                2061: 'GeogPrimeMeridianLongGeoKey',\r\n                2062: 'GeogTOWGS84GeoKey',\r\n                3072: 'ProjectedCSTypeGeoKey',\r\n                3073: 'PCSCitationGeoKey',\r\n                3074: 'ProjectionGeoKey',\r\n                3075: 'ProjCoordTransGeoKey',\r\n                3076: 'ProjLinearUnitsGeoKey',\r\n                3077: 'ProjLinearUnitSizeGeoKey',\r\n                3078: 'ProjStdParallel1GeoKey',\r\n                3079: 'ProjStdParallel2GeoKey',\r\n                3080: 'ProjNatOriginLongGeoKey',\r\n                3081: 'ProjNatOriginLatGeoKey',\r\n                3082: 'ProjFalseEastingGeoKey',\r\n                3083: 'ProjFalseNorthingGeoKey',\r\n                3084: 'ProjFalseOriginLongGeoKey',\r\n                3085: 'ProjFalseOriginLatGeoKey',\r\n                3086: 'ProjFalseOriginEastingGeoKey',\r\n                3087: 'ProjFalseOriginNorthingGeoKey',\r\n                3088: 'ProjCenterLongGeoKey',\r\n                3089: 'ProjCenterLatGeoKey',\r\n                3090: 'ProjCenterEastingGeoKey',\r\n                3091: 'ProjCenterNorthingGeoKey',\r\n                3092: 'ProjScaleAtNatOriginGeoKey',\r\n                3093: 'ProjScaleAtCenterGeoKey',\r\n                3094: 'ProjAzimuthAngleGeoKey',\r\n                3095: 'ProjStraightVertPoleLongGeoKey',\r\n                3096: 'ProjRectifiedGridAngleGeoKey',\r\n                4096: 'VerticalCSTypeGeoKey',\r\n                4097: 'VerticalCitationGeoKey',\r\n                4098: 'VerticalDatumGeoKey',\r\n                4099: 'VerticalUnitsGeoKey'\r\n            };\r\n            var geoKeyName;\r\n\r\n            if (geoKey in geoKeyTagNames) {\r\n                geoKeyName = geoKeyTagNames[geoKey];\r\n            } else {\r\n                console.log(\"Unknown geoKey :\", geoKey);\r\n                geoKeyName = geoKey + \"GeoKey\";\r\n            }\r\n            return geoKeyName;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getFieldTagName: function (fieldTag) {\r\n            // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\r\n            // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\r\n            var fieldTagNames = {\r\n                // TIFF Baseline\r\n                0x013B: 'Artist',\r\n                0x0102: 'BitsPerSample',\r\n                0x0109: 'CellLength',\r\n                0x0108: 'CellWidth',\r\n                0x0140: 'ColorMap',\r\n                0x0103: 'Compression',\r\n                0x8298: 'Copyright',\r\n                0x0132: 'DateTime',\r\n                0x0152: 'ExtraSamples',\r\n                0x010A: 'FillOrder',\r\n                0x0121: 'FreeByteCounts',\r\n                0x0120: 'FreeOffsets',\r\n                0x0123: 'GrayResponseCurve',\r\n                0x0122: 'GrayResponseUnit',\r\n                0x013C: 'HostComputer',\r\n                0x010E: 'ImageDescription',\r\n                0x0101: 'ImageLength',\r\n                0x0100: 'ImageWidth',\r\n                0x010F: 'Make',\r\n                0x0119: 'MaxSampleValue',\r\n                0x0118: 'MinSampleValue',\r\n                0x0110: 'Model',\r\n                0x00FE: 'NewSubfileType',\r\n                0x0112: 'Orientation',\r\n                0x0106: 'PhotometricInterpretation',\r\n                0x011C: 'PlanarConfiguration',\r\n                0x0128: 'ResolutionUnit',\r\n                0x0116: 'RowsPerStrip',\r\n                0x0115: 'SamplesPerPixel',\r\n                0x0131: 'Software',\r\n                0x0117: 'StripByteCounts',\r\n                0x0111: 'StripOffsets',\r\n                0x00FF: 'SubfileType',\r\n                0x0107: 'Threshholding',\r\n                0x011A: 'XResolution',\r\n                0x011B: 'YResolution',\r\n\r\n                // TIFF Extended\r\n                0x0146: 'BadFaxLines',\r\n                0x0147: 'CleanFaxData',\r\n                0x0157: 'ClipPath',\r\n                0x0148: 'ConsecutiveBadFaxLines',\r\n                0x01B1: 'Decode',\r\n                0x01B2: 'DefaultImageColor',\r\n                0x010D: 'DocumentName',\r\n                0x0150: 'DotRange',\r\n                0x0141: 'HalftoneHints',\r\n                0x015A: 'Indexed',\r\n                0x015B: 'JPEGTables',\r\n                0x011D: 'PageName',\r\n                0x0129: 'PageNumber',\r\n                0x013D: 'Predictor',\r\n                0x013F: 'PrimaryChromaticities',\r\n                0x0214: 'ReferenceBlackWhite',\r\n                0x0153: 'SampleFormat',\r\n                0x0154: 'SMinSampleValue',\r\n                0x0155: 'SMaxSampleValue',\r\n                0x022F: 'StripRowCounts',\r\n                0x014A: 'SubIFDs',\r\n                0x0124: 'T4Options',\r\n                0x0125: 'T6Options',\r\n                0x0145: 'TileByteCounts',\r\n                0x0143: 'TileLength',\r\n                0x0144: 'TileOffsets',\r\n                0x0142: 'TileWidth',\r\n                0x012D: 'TransferFunction',\r\n                0x013E: 'WhitePoint',\r\n                0x0158: 'XClipPathUnits',\r\n                0x011E: 'XPosition',\r\n                0x0211: 'YCbCrCoefficients',\r\n                0x0213: 'YCbCrPositioning',\r\n                0x0212: 'YCbCrSubSampling',\r\n                0x0159: 'YClipPathUnits',\r\n                0x011F: 'YPosition',\r\n\r\n                // EXIF\r\n                0x9202: 'ApertureValue',\r\n                0xA001: 'ColorSpace',\r\n                0x9004: 'DateTimeDigitized',\r\n                0x9003: 'DateTimeOriginal',\r\n                0x8769: 'Exif IFD',\r\n                0x9000: 'ExifVersion',\r\n                0x829A: 'ExposureTime',\r\n                0xA300: 'FileSource',\r\n                0x9209: 'Flash',\r\n                0xA000: 'FlashpixVersion',\r\n                0x829D: 'FNumber',\r\n                0xA420: 'ImageUniqueID',\r\n                0x9208: 'LightSource',\r\n                0x927C: 'MakerNote',\r\n                0x9201: 'ShutterSpeedValue',\r\n                0x9286: 'UserComment',\r\n\r\n                // IPTC\r\n                0x83BB: 'IPTC',\r\n\r\n                // ICC\r\n                0x8773: 'ICC Profile',\r\n\r\n                // XMP\r\n                0x02BC: 'XMP',\r\n\r\n                // GDAL\r\n                0xA480: 'GDAL_METADATA',\r\n                0xA481: 'GDAL_NODATA',\r\n\r\n                // Photoshop\r\n                0x8649: 'Photoshop',\r\n\r\n                // GeoTiff\r\n                0x830E: 'ModelPixelScale',\r\n                0x8482: 'ModelTiepoint',\r\n                0x85D8: 'ModelTransformation',\r\n                0x87AF: 'GeoKeyDirectory',\r\n                0x87B0: 'GeoDoubleParams',\r\n                0x87B1: 'GeoAsciiParams'\r\n\r\n            };\r\n\r\n            var fieldTagName;\r\n\r\n            if (fieldTag in fieldTagNames) {\r\n                fieldTagName = fieldTagNames[fieldTag];\r\n            } else {\r\n                console.log(\"Unknown Field Tag:\", fieldTag);\r\n                fieldTagName = \"Tag\" + fieldTag;\r\n            }\r\n            return fieldTagName;\r\n        },\r\n\r\n        /* Translate the photometric code to a name  */\r\n        getPhotometricName: function (key) {\r\n            var photometricNames = {\r\n                0: 'PHOTOMETRIC_MINISWHITE',\r\n                1: 'PHOTOMETRIC_MINISBLACK',\r\n                2: 'PHOTOMETRIC_RGB',\r\n                3: 'PHOTOMETRIC_PALETTE',\r\n                4: 'PHOTOMETRIC_MASK',\r\n                5: 'PHOTOMETRIC_SEPARATED',\r\n                6: 'PHOTOMETRIC_YCBCR',\r\n                8: 'PHOTOMETRIC_CIELAB',\r\n                9: 'PHOTOMETRIC_ICCLAB',\r\n                10: 'PHOTOMETRIC_ITULAB',\r\n                32844: 'PHOTOMETRIC_LOGL',\r\n                32845: 'PHOTOMETRIC_LOGLUV'\r\n            };\r\n            var photometricName;\r\n\r\n            if (key in photometricNames) {\r\n                photometricName = photometricNames[key];\r\n            } else {\r\n                photometricName = \"UNKNOWN\";\r\n            }\r\n            return photometricName;\r\n        },\r\n\r\n        /* Translate GeoKey to string  */\r\n        getCompressionTypeName: function (key) {\r\n            var compressionNames = {\r\n\r\n                1: 'COMPRESSION_NONE',\r\n                2: 'COMPRESSION_CCITTRLE',\r\n                3: 'COMPRESSION_CCITTFAX3',\r\n                4: 'COMPRESSION_CCITTFAX4',\r\n                5: 'COMPRESSION_LZW',\r\n                6: 'COMPRESSION_OJPEG',\r\n                7: 'COMPRESSION_JPEG',\r\n                32766: 'COMPRESSION_NEXT',\r\n                32771: 'COMPRESSION_CCITTRLEW',\r\n                32773: 'COMPRESSION_PACKBITS',\r\n                32809: 'COMPRESSION_THUNDERSCAN',\r\n                32895: 'COMPRESSION_IT8CTPAD',\r\n                32896: 'COMPRESSION_IT8LW',\r\n                32897: 'COMPRESSION_IT8MP',\r\n                32898: 'COMPRESSION_IT8BL',\r\n                32908: 'COMPRESSION_PIXARFILM',\r\n                32909: 'COMPRESSION_PIXARLOG',\r\n                32946: 'COMPRESSION_DEFLATE',\r\n                8: 'COMPRESSION_ADOBE_DEFLATE',\r\n                32947: 'COMPRESSION_DCS',\r\n                34661: 'COMPRESSION_JBIG',\r\n                34676: 'COMPRESSION_SGILOG',\r\n                34677: 'COMPRESSION_SGILOG24',\r\n                34712: 'COMPRESSION_JP2000'\r\n            };\r\n            var compressionName;\r\n\r\n            if (key in compressionNames) {\r\n                compressionName = compressionNames[key];\r\n            } else {\r\n                compressionName = \"UNKNOWN\";\r\n            }\r\n            return compressionName;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getFieldTypeName: function (fieldType) {\r\n            var fieldTypeNames = {\r\n                0x0001: 'BYTE',\r\n                0x0002: 'ASCII',\r\n                0x0003: 'SHORT',\r\n                0x0004: 'LONG',\r\n                0x0005: 'RATIONAL',\r\n                0x0006: 'SBYTE',\r\n                0x0007: 'UNDEFINED',\r\n                0x0008: 'SSHORT',\r\n                0x0009: 'SLONG',\r\n                0x000A: 'SRATIONAL',\r\n                0x000B: 'FLOAT',\r\n                0x000C: 'DOUBLE'\r\n            };\r\n\r\n            var fieldTypeName;\r\n\r\n            if (fieldType in fieldTypeNames) {\r\n                fieldTypeName = fieldTypeNames[fieldType];\r\n            }\r\n            return fieldTypeName;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getFieldTypeLength: function (fieldTypeName) {\r\n            var fieldTypeLength;\r\n\r\n            if (['BYTE', 'ASCII', 'SBYTE', 'UNDEFINED'].indexOf(fieldTypeName) !== -1) {\r\n                fieldTypeLength = 1;\r\n            } else if (['SHORT', 'SSHORT'].indexOf(fieldTypeName) !== -1) {\r\n                fieldTypeLength = 2;\r\n            } else if (['LONG', 'SLONG', 'FLOAT'].indexOf(fieldTypeName) !== -1) {\r\n                fieldTypeLength = 4;\r\n            } else if (['RATIONAL', 'SRATIONAL', 'DOUBLE'].indexOf(fieldTypeName) !== -1) {\r\n                fieldTypeLength = 8;\r\n            }\r\n\r\n            return fieldTypeLength;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getBits: function (numBits, byteOffset, bitOffset) {\r\n            bitOffset = bitOffset || 0;\r\n            var extraBytes = Math.floor(bitOffset / 8);\r\n            var newByteOffset = byteOffset + extraBytes;\r\n            var totalBits = bitOffset + numBits;\r\n            var shiftRight = 32 - numBits;\r\n\r\n            if (totalBits <= 0) {\r\n                console.log(numBits, byteOffset, bitOffset);\r\n                throw RangeError(\"No bits requested\");\r\n            } else if (totalBits <= 8) {\r\n                var shiftLeft = 24 + bitOffset;\r\n                var rawBits = this.tiffDataView.getUint8(newByteOffset, this.littleEndian);\r\n            } else if (totalBits <= 16) {\r\n                var shiftLeft = 16 + bitOffset;\r\n                var rawBits = this.tiffDataView.getUint16(newByteOffset, this.littleEndian);\r\n            } else if (totalBits <= 32) {\r\n                var shiftLeft = bitOffset;\r\n                var rawBits = this.tiffDataView.getUint32(newByteOffset, this.littleEndian);\r\n            } else {\r\n                console.log(numBits, byteOffset, bitOffset);\r\n                throw RangeError(\"Too many bits requested\");\r\n            }\r\n\r\n            var chunkInfo = {\r\n                'bits': ((rawBits << shiftLeft) >>> shiftRight),\r\n                'byteOffset': newByteOffset + Math.floor(totalBits / 8),\r\n                'bitOffset': totalBits % 8\r\n            };\r\n            return chunkInfo;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getBytes: function (numBytes, offset) {\r\n            if (numBytes <= 0) {\r\n                console.log(numBytes, offset);\r\n                throw RangeError(\"No bytes requested\");\r\n            } else if (numBytes <= 1) {\r\n                return this.tiffDataView.getUint8(offset, this.littleEndian);\r\n            } else if (numBytes <= 2) {\r\n                return this.tiffDataView.getUint16(offset, this.littleEndian);\r\n            } else if (numBytes <= 3) {\r\n                return this.tiffDataView.getUint32(offset, this.littleEndian) >>> 8;\r\n            } else if (numBytes <= 4) {\r\n                return this.tiffDataView.getUint32(offset, this.littleEndian);\r\n            } else if (numBytes <= 8) {\r\n                return this.tiffDataView.getFloat64(offset, this.littleEndian);\r\n            } else {\r\n                throw RangeError(\"Too many bytes requested\");\r\n            }\r\n        },\r\n\r\n        /* getSampleBytes : use Sampleformat  */\r\n        getSampleBytes: function (sampleFormat, numBytes, offset) {\r\n\r\n            // Decompress strip.\r\n            switch (sampleFormat) {\r\n                // Uncompressed\r\n                case 1:\r\n                case 2: // two’s complement signed integer data\r\n                    return this.getBytes(numBytes, offset);\r\n                case 3: // floating point data\r\n                    {\r\n                        if (numBytes == 3) {\r\n                            return this.tiffDataView.getFloat32(offset, this.littleEndian) >>> 8;\r\n                        } else if (numBytes == 4) {\r\n                            return this.tiffDataView.getFloat32(offset, this.littleEndian);\r\n                        }\r\n                        // No break : if numBytes != 3 && 4 --> throw error\r\n                    }\r\n                case 5: // Complex Int\r\n                case 6: // Complex IEEE floating point \r\n                case 4: // void or undefined  \r\n                default:\r\n                    throw Error(\"Do not attempt to parse the data  not handled  : \" + sampleFormat);\r\n                    break;\r\n            }\r\n\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        getFieldValues: function (fieldTagName, fieldTypeName, typeCount, valueOffset) {\r\n            var fieldValues = [];\r\n            var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);\r\n            var fieldValueSize = fieldTypeLength * typeCount;\r\n\r\n            if (fieldValueSize <= 4) {\r\n                // The value is stored at the big end of the valueOffset.\r\n                if (this.littleEndian === false) {\r\n                    var value = valueOffset >>> ((4 - fieldTypeLength) * 8);\r\n                } else {\r\n                    var value = valueOffset;\r\n                }\r\n\r\n                fieldValues.push(value);\r\n            } else {\r\n                for (var i = 0; i < typeCount; i++) {\r\n                    var indexOffset = fieldTypeLength * i;\r\n\r\n                    if (fieldTypeLength >= 8) {\r\n                        if (['RATIONAL', 'SRATIONAL'].indexOf(fieldTypeName) !== -1) {\r\n                            // Numerator\r\n                            fieldValues.push(this.getBytes(4, valueOffset + indexOffset));\r\n                            // Denominator\r\n                            fieldValues.push(this.getBytes(4, valueOffset + indexOffset + 4));\r\n                        } else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\r\n                            fieldValues.push(this.getBytes(8, valueOffset + indexOffset));\r\n                            //console.log(this.getBytes(8, valueOffset + indexOffset) );\r\n                        } else {\r\n                            console.log(\" fff\" + fieldTypeName, typeCount, fieldValueSize);\r\n                            //throw TypeError(\"Can't handle this field type or size\");\r\n                        }\r\n                    } else {\r\n                        fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (fieldTypeName === 'ASCII') {\r\n                fieldValues.forEach(function (e, i, a) {\r\n                    a[i] = String.fromCharCode(e);\r\n                });\r\n            }\r\n            return fieldValues;\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        clampColorSample: function (colorSample, bitsPerSample) {\r\n            var multiplier = Math.pow(2, 8 - bitsPerSample);\r\n            return Math.floor((colorSample * multiplier) + (1 - multiplier));\r\n        },\r\n\r\n        clampAffineColorSample: function (colorSample, bitsPerSample, vmin, vmax) {\r\n            var multiplier = Math.pow(2, 8) / vmax;\r\n            return Math.floor((colorSample - vmin) * multiplier);\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        makeRGBAFillValue: function (r, g, b, a) {\r\n            if (typeof a === 'undefined') {\r\n                a = 1.0;\r\n            }\r\n            return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\r\n        },\r\n\r\n        /* from Tiff-js  */\r\n        parseFileDirectory: function (byteOffset) {\r\n            var numDirEntries = this.getBytes(2, byteOffset);\r\n            var tiffFields = [];\r\n\r\n            for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\r\n                var fieldTag = this.getBytes(2, i);\r\n                var fieldType = this.getBytes(2, i + 2);\r\n                var typeCount = this.getBytes(4, i + 4);\r\n                var valueOffset = this.getBytes(4, i + 8);\r\n\r\n                var fieldTagName = this.getFieldTagName(fieldTag);\r\n                var fieldTypeName = this.getFieldTypeName(fieldType);\r\n                var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\r\n\r\n                tiffFields[fieldTagName] = { 'type': fieldTypeName, 'values': fieldValues };\r\n            }\r\n\r\n            this.fileDirectories.push(tiffFields);\r\n\r\n            var nextIFDByteOffset = this.getBytes(4, i);\r\n\r\n            if (nextIFDByteOffset === 0x00000000) {\r\n                return this.fileDirectories;\r\n            }\r\n            else {\r\n                return this.parseFileDirectory(nextIFDByteOffset);\r\n            }\r\n        },\r\n\r\n        /* check if the Tif is a GeoTiff  */\r\n        isGeotiff: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.GeoKeyDirectory) == 'undefined' || fileDirectory.GeoKeyDirectory == null ||\r\n                typeof (fileDirectory.GeoKeyDirectory.values) == 'undefined' || fileDirectory.GeoKeyDirectory.values == null)\r\n                return false;\r\n            var geoKeysDir = fileDirectory.GeoKeyDirectory.values;\r\n            if (geoKeysDir.length < 4)\r\n                return false;\r\n            return true;\r\n        },\r\n\r\n\r\n        /* check  getPlanarConfiguration */\r\n        getPlanarConfiguration: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (fileDirectory.hasOwnProperty('PlanarConfiguration') == false ||\r\n                fileDirectory.PlanarConfiguration.hasOwnProperty('values') == false ||\r\n                fileDirectory.PlanarConfiguration.values == null)\r\n                return 1;\r\n\r\n            return fileDirectory.PlanarConfiguration.values[0];\r\n        },\r\n\r\n\r\n        /* return the type  of the pixel or -1 */\r\n        getSampleFormat: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (fileDirectory.hasOwnProperty('SampleFormat') == false ||\r\n                fileDirectory.SampleFormat.hasOwnProperty('values') == false ||\r\n                fileDirectory.SampleFormat.values == null)\r\n                return 1;\r\n\r\n            return fileDirectory.SampleFormat.values[0];\r\n        },\r\n\r\n        /* return min and max values if resent or -1 */\r\n        getSampleMinMax: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (fileDirectory.hasOwnProperty('SMaxSampleValue') == false ||\r\n                fileDirectory.SMaxSampleValue.hasOwnProperty('values') == false ||\r\n                fileDirectory.SMaxSampleValue.values == null)\r\n                return -1;\r\n\r\n            if (fileDirectory.hasOwnProperty('SMinSampleValue') == false ||\r\n                fileDirectory.SMinSampleValue.hasOwnProperty('values') == false ||\r\n                fileDirectory.SMinSampleValue.values == null)\r\n                return -1;\r\n\r\n            return [fileDirectory.SMinSampleValue.values, fileDirectory.SMaxSampleValue.values];\r\n\r\n        },\r\n\r\n        /* isBlockLoaded : this function check if the block with blockOffset value has been loaded  */\r\n        isBlockLoaded: function (blockOffset) {\r\n            var blocks = this.blocks;\r\n            for (var i = 0; i < blocks.length; i++)\r\n                if (this.blocks[i] != null && this.blocks[i].offset == blockOffset)\r\n                    return i;\r\n            return -1;\r\n        },\r\n\r\n        /* getBlock : this function get the block with blockOffset value has been loaded  */\r\n        getBlock: function (blockOffset) {\r\n            var blocks = this.blocks;\r\n            for (var i = 0; i < blocks.length; i++)\r\n                if (this.blocks[i] != null && this.blocks[i].offset == blockOffset)\r\n                    return this.blocks[i];\r\n            return null;\r\n        },\r\n\r\n        /* add the new block to the list of the block \r\n         * ToDo : limit the number of block loaded in order to control the memory isage\r\n         * remove older block \r\n         */\r\n        addBlock: function (stripToLoad, block) {\r\n            this.blocks[stripToLoad] = block\r\n        },\r\n\r\n        /* check if StripOffset is set */\r\n        hasStripOffset: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.StripOffsets) == 'undefined' || fileDirectory.StripOffsets == null ||\r\n                typeof (fileDirectory.StripOffsets.values) == 'undefined' || fileDirectory.StripOffsets.values == null)\r\n                return false;\r\n            return true;\r\n        },\r\n\r\n        /* check if TileOffsets is set */\r\n        hasTileOffset: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (fileDirectory.hasOwnProperty('TileOffsets') == false ||\r\n                fileDirectory.TileOffsets.hasOwnProperty('values') == false || fileDirectory.TileOffsets.values == null)\r\n                return false;\r\n            return true;\r\n        },\r\n\r\n        /*  parse de GeoKeyDirectory and fill geoKeys */\r\n        parseGeoKeyDirectory: function () {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (this.isGeotiff() == false)\r\n                return;\r\n\r\n            var hdr_num_keys = fileDirectory.GeoKeyDirectory.values[3];\r\n\r\n            var geoKeyFields = [];\r\n            for (var iKey = 0; iKey < hdr_num_keys; iKey++) {\r\n                /* GeoKey ID            */\r\n                var ent_key = fileDirectory.GeoKeyDirectory.values[4 + iKey * 4];\r\n                /* TIFF Tag ID or 0     */\r\n                var ent_location = fileDirectory.GeoKeyDirectory.values[5 + iKey * 4];\r\n                /* GeoKey value count   */\r\n                var ent_count = fileDirectory.GeoKeyDirectory.values[6 + iKey * 4];\r\n                /* value or tag offset  */\r\n                var ent_val_offset = fileDirectory.GeoKeyDirectory.values[7 + iKey * 4];\r\n\r\n                var value = 'undefined';\r\n                if (ent_location == 0) {\r\n                    /* store value into data value */\r\n                    value = ent_val_offset;\r\n                    //console.log(\"ent_val_offset =\" + value );\t\r\n                }\r\n                else if (this.getFieldTagName(ent_location) == \"GeoKeyDirectory\") {\r\n                    console.log(\"ent_key =\" + this.getGeoKeyName(ent_key));\r\n                    console.log(\"ent_count =\" + ent_count);\r\n                    console.log(\"ent_val_offset =\" + ent_val_offset);\r\n                    console.log(\"GeoKeyDirectory =\");\r\n\r\n                }\r\n                else if (this.getFieldTagName(ent_location) == \"GeoDoubleParams\") {\r\n                    /*\r\n                        console.log(\"ent_key =\" + this.getGeoKeyName(ent_key));\r\n                        console.log(\"ent_count =\" + ent_count );\t\t\r\n                        console.log(\"ent_val_offset =\" + ent_val_offset );\r\n                        console.log(\"GeoDoubleParams =\"  +GeoDoubleParams[ent_val_offset]);\r\n                        */\r\n                    var GeoDoubleParams = fileDirectory.GeoDoubleParams.values;\r\n                    value = GeoDoubleParams[ent_val_offset];\r\n\r\n                }\r\n                else if (this.getFieldTagName(ent_location) == \"GeoAsciiParams\") {\r\n                    var str = \"\";\r\n                    /*console.log(\"ent_key =\" + this.getGeoKeyName(ent_key));\r\n                    console.log(\"ent_count =\" + ent_count );\r\n                    console.log(\"ent_val_offset =\" + ent_val_offset );*/\r\n                    var GeoAsciiParams = fileDirectory.GeoAsciiParams.values;\r\n                    if (ent_val_offset != 'undefined' &&\r\n                        ent_count != 'undefined' &&\r\n                        ent_count > 0 &&\r\n                        ent_val_offset <= ent_count - 1) {\r\n                        for (var j = ent_val_offset; j < ent_count - 1; j++)\r\n                            str += GeoAsciiParams[j];\r\n                        if (GeoAsciiParams[ent_count - 1] != '|')\r\n                            str += GeoAsciiParams[ent_count - 1];\r\n\r\n                    }\r\n                    value = str;\r\n                }\r\n                geoKeyFields[this.getGeoKeyName(ent_key)] = { 'value': value };\r\n            }\r\n            this.geoKeys = geoKeyFields;\r\n\r\n            if (this.geoKeys.hasOwnProperty('GTRasterTypeGeoKey') == false)\r\n                this.isPixelArea = 0;\r\n            if (this.getRasterTypeName(this.geoKeys.GTRasterTypeGeoKey.value) == 'RasterPixelIsArea')\r\n                this.isPixelArea = 1;\r\n\r\n        },\r\n\r\n        /* Test */\r\n        consoleTiffProperty: function () {\r\n            console.log(\"--------------- Tiff property -------------------\");\r\n            // Show Image parameter\r\n            console.log(\"Image : w=\" + this.imageWidth + \" h=\" + this.imageLength);\r\n\r\n            // DataType  UChar8 or Int16\r\n            console.log(\"BitsPerPixel=\" + this.bitsPerPixel);\r\n\r\n            // Band count : 1 or 3 bands RGB\r\n            console.log(\"SamplesPerPixel=\" + this.samplesPerPixel);\r\n            console.log(\"PlanarConfiruration=\" + this.planarConfiguration);\r\n            console.log(\"Photometric =\" + this.getPhotometricName(this.photometricInterpretation));\r\n            console.log(\"Compression =\" + this.getCompressionTypeName(this.compression));\r\n            console.log(\"SampleFormat : \", this.getSampleFormat());\r\n            console.log(\"getSampleMinMax : \", this.getSampleMinMax());\r\n\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (this.hasStripOffset()) {\r\n                var numoffsetValues = fileDirectory.StripOffsets.values.length;\r\n                console.log(\"Has Strips nb offsetvalues count:\" + numoffsetValues);\r\n            }\r\n\r\n            if (this.hasTileOffset()) {\r\n                var numoffsetValues = fileDirectory.TileOffsets.values.length;\r\n                console.log(\"Has Tiles  offsetvalues count:\" + numoffsetValues);\r\n            }\r\n\r\n        },\r\n\r\n        /* Test */\r\n        consoleGeotiffProperty: function () {\r\n            console.log(\"--------------- GeoTiff property -------------------\");\r\n            var fileDirectory = this.fileDirectories[0];\r\n            var hdr_version = fileDirectory.GeoKeyDirectory.values[0];\r\n            var hdr_rev_major = fileDirectory.GeoKeyDirectory.values[1];\r\n            var hdr_rev_minor = fileDirectory.GeoKeyDirectory.values[2];\r\n            var hdr_num_keys = fileDirectory.GeoKeyDirectory.values[3];\r\n\r\n            console.log(\"hdr_version =\" + fileDirectory.GeoKeyDirectory + \" \" + hdr_version);\r\n            console.log(\"hdr_rev_major =\" + fileDirectory.GeoKeyDirectory + \" \" + hdr_rev_major);\r\n            console.log(\"hdr_rev_minor =\" + fileDirectory.GeoKeyDirectory + \" \" + hdr_rev_minor);\r\n            console.log(\"hdr_num_keys =\" + fileDirectory.GeoKeyDirectory + \" \" + hdr_num_keys);\r\n\r\n            this.consoleCRSProperty();\r\n            console.log(\"pixelSize =\" + this.getPixelSize());\r\n        },\r\n\r\n        /* Test */\r\n        consoleTestGeorefImage: function () {\r\n\r\n            var x = 2;\r\n            var y = 2;\r\n            var res = this.ImageToPCS(x, y);\r\n            if (res[0] == 1)\r\n                console.log(\" ImageToPCS \" + res[1] + \" \" + res[2]);\r\n            else\r\n                console.log(\" ImageToPCS failure\");\r\n\r\n            var res2 = this.PCSToImage(res[1], res[2]);\r\n            if (res2[0] == 1)\r\n                console.log(\" PCSToImage \" + res2[1] + \" \" + res2[2]);\r\n            else\r\n                console.log(\" PCSToImage failure\");\r\n        },\r\n\r\n        /*\r\n         * parse Header\r\n         * \r\n         */\r\n        parseHeader: function (tiffArrayBuffer) {\r\n\r\n            this.tiffDataView = new DataView(tiffArrayBuffer);\r\n            this.littleEndian = this.isLittleEndian(this.tiffDataView);\r\n\r\n            if (!this.hasTowel(this.tiffDataView, this.littleEndian)) {\r\n                return;\r\n            }\r\n\r\n            var firstIFDByteOffset = this.getBytes(4, 4);\r\n\r\n            this.fileDirectories = this.parseFileDirectory(firstIFDByteOffset);\r\n            var fileDirectory = this.fileDirectories[0];\r\n\r\n            this.imageWidth = fileDirectory.ImageWidth.values[0];\r\n            this.imageLength = fileDirectory.ImageLength.values[0];\r\n            this.photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\r\n            this.samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\r\n\r\n            this.bitsPerPixel = 0;\r\n            fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\r\n                this.sampleProperties[i] = {\r\n                    'bitsPerSample': bitsPerSample,\r\n                    'hasBytesPerSample': false,\r\n                    'bytesPerSample': undefined\r\n                };\r\n\r\n                if ((bitsPerSample % 8) === 0) {\r\n                    this.sampleProperties[i].hasBytesPerSample = true;\r\n                    this.sampleProperties[i].bytesPerSample = bitsPerSample / 8;\r\n                }\r\n\r\n                this.bitsPerPixel += bitsPerSample;\r\n            }, this);\r\n\r\n            this.compression = (fileDirectory.Compression) ? fileDirectory.Compression.values[0] : 1;\r\n\r\n            if (fileDirectory.ColorMap) {\r\n                this.colorMapValues = fileDirectory.ColorMap.values;\r\n                this.colorMapSampleSize = Math.pow(2, this.sampleProperties[0].bitsPerSample);\r\n            }\r\n\r\n            if (fileDirectory.ExtraSamples) {\r\n                this.extraSamplesValues = fileDirectory.ExtraSamples.values;\r\n                this.numExtraSamples = this.extraSamplesValues.length;\r\n            }\r\n\r\n\r\n            if (fileDirectory.hasOwnProperty('PlanarConfiguration') && true &&\r\n                fileDirectory.PlanarConfiguration.hasOwnProperty('values') == true)\r\n                this.planarConfiguration = fileDirectory.PlanarConfiguration.values[0];\r\n\r\n\r\n            this.parseGeoKeyDirectory();\r\n        },\r\n\r\n        /*\r\n        * SubFunction (should be private)\r\n        * Decode a Strip or a Tiles \r\n        */\r\n        decodeBlock: function (stripOffset, stripByteCount, moduleDecompression) {\r\n            var decodedBlock = [];\r\n            var jIncrement = 1, pixel = [];\r\n            var sampleformat = this.getSampleFormat();\r\n            // Decompress strip.\r\n            switch (this.compression) {\r\n                // Uncompressed\r\n                case 1:\r\n                    var bitOffset = 0;\r\n                    var hasBytesPerPixel = false;\r\n                    if ((this.bitsPerPixel % 8) === 0) {\r\n                        hasBytesPerPixel = true;\r\n                        var bytesPerPixel = this.bitsPerPixel / 8;\r\n                    }\r\n\r\n                    if (hasBytesPerPixel) {\r\n                        jIncrement = bytesPerPixel;\r\n                    } else {\r\n                        jIncrement = 0;\r\n                        throw RangeError(\"Cannot handle sub-byte bits per pixel\");\r\n                    }\r\n\r\n                    for (var byteOffset = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\r\n\r\n                        // Loop through samples (sub-pixels).\r\n                        for (var m = 0, pixel = []; m < this.samplesPerPixel; m++) {\r\n                            if (this.sampleProperties[m].hasBytesPerSample) {\r\n                                var sampleOffset = this.sampleProperties[m].bytesPerSample * m;\r\n                                pixel.push(this.getSampleBytes(sampleformat, this.sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\r\n                            } else {\r\n                                var sampleInfo = this.getBits(this.sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\r\n\r\n                                pixel.push(sampleInfo.bits);\r\n\r\n                                byteOffset = sampleInfo.byteOffset - stripOffset;\r\n                                bitOffset = sampleInfo.bitOffset;\r\n\r\n                                throw RangeError(\"Cannot handle sub-byte bits per sample\");\r\n                            }\r\n                        }\r\n\r\n                        decodedBlock.push(pixel);\r\n                    }\r\n                    break;\r\n                case 5:\r\n                    var decompressed = LZString.decompressFromUint8Array(decodedBlock);\r\n\r\n                    break;\r\n                    // Deflate \r\n                    // Code not yes validate \r\n                case 32946:\r\n                    var inflator = new moduleDecompression.Inflate();\r\n                    var bitOffset = 0;\r\n                    var hasBytesPerPixel = false;\r\n                    if ((this.bitsPerPixel % 8) === 0) {\r\n                        hasBytesPerPixel = true;\r\n                        var bytesPerPixel = this.bitsPerPixel / 8;\r\n                    }\r\n\r\n                    if (hasBytesPerPixel) {\r\n                        jIncrement = bytesPerPixel;\r\n                    } else {\r\n                        jIncrement = 0;\r\n\r\n                        throw RangeError(\"Cannot handle sub-byte bits per pixel\");\r\n                    }\r\n\r\n                    var isLast = false;\r\n                    for (var byteOffset = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\r\n\r\n                        // Loop through samples (sub-pixels).\r\n                        for (var m = 0, pixel = []; m < this.samplesPerPixel; m++) {\r\n                            if (this.sampleProperties[m].hasBytesPerSample) {\r\n                                // XXX: This is wrong!\r\n                                var sampleOffset = this.sampleProperties[m].bytesPerSample * m;\r\n\r\n                                pixel.push(this.getBytes(this.sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\r\n                            } else {\r\n                                var sampleInfo = this.getBits(this.sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\r\n\r\n                                pixel.push(sampleInfo.bits);\r\n\r\n                                byteOffset = sampleInfo.byteOffset - stripOffset;\r\n                                bitOffset = sampleInfo.bitOffset;\r\n\r\n                                throw RangeError(\"Cannot handle sub-byte bits per sample\");\r\n                            }\r\n                        }\r\n\r\n                        if (byteOffset + jIncrement >= stripByteCount)\r\n                            isLast = true;\r\n                        inflator.push(pixel, isLast);\r\n\r\n                    }\r\n                    if (inflator.err) {\r\n                        console.log(inflator.msg);\r\n                    }\r\n\r\n                    decodedBlock.push(inflator.result);\r\n                    break;\r\n\r\n                    // PackBits\r\n                case 32773:\r\n                    var currentSample = 0;\r\n                    var sample = 0;\r\n                    var numBytes = 0;\r\n                    var getHeader = true;\r\n                    for (var byteOffset = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\r\n\r\n                        // Are we ready for a new block?\r\n                        if (getHeader) {\r\n                            getHeader = false;\r\n\r\n                            var blockLength = 1;\r\n                            var iterations = 1;\r\n\r\n                            // The header byte is signed.\r\n                            var header = this.tiffDataView.getInt8(stripOffset + byteOffset, this.littleEndian);\r\n\r\n                            if ((header >= 0) && (header <= 127)) { // Normal pixels.\r\n                                blockLength = header + 1;\r\n                            } else if ((header >= -127) && (header <= -1)) { // Collapsed pixels.\r\n                                iterations = -header + 1;\r\n                            } else /*if (header === -128)*/ { // Placeholder byte?\r\n                                getHeader = true;\r\n                            }\r\n                        } else {\r\n                            var currentByte = this.getBytes(1, stripOffset + byteOffset);\r\n\r\n                            // Duplicate bytes, if necessary.\r\n                            for (var m = 0; m < iterations; m++) {\r\n                                if (this.sampleProperties[sample].hasBytesPerSample) {\r\n                                    // We're reading one byte at a time, so we need to handle multi-byte samples.\r\n                                    currentSample = (currentSample << (8 * numBytes)) | currentByte;\r\n                                    numBytes++;\r\n\r\n                                    // Is our sample complete?\r\n                                    if (numBytes === this.sampleProperties[sample].bytesPerSample) {\r\n                                        pixel.push(currentSample);\r\n                                        currentSample = numBytes = 0;\r\n                                        sample++;\r\n                                    }\r\n                                } else {\r\n                                    throw RangeError(\"Cannot handle sub-byte bits per sample\");\r\n                                }\r\n\r\n                                // Is our pixel complete?\r\n                                if (sample === this.samplesPerPixel) {\r\n                                    decodedBlock.push(pixel);\r\n\r\n                                    pixel = [];\r\n                                    sample = 0;\r\n                                }\r\n                            }\r\n\r\n                            blockLength--;\r\n\r\n                            // Is our block complete?\r\n                            if (blockLength === 0) {\r\n                                getHeader = true;\r\n                            }\r\n                        }\r\n\r\n                        jIncrement = 1;\r\n                    }\r\n                    break;\r\n\r\n                    // Unknown compression algorithm\r\n                default:\r\n                    throw Error(\"Do not attempt to parse the data Compression not handled  : \" + this.getCompressionTypeName(this.compression));\r\n                    // Do not attempt to parse the image data.\r\n                    break;\r\n            }\r\n\r\n            var blockInfo = {\r\n                'offset': stripOffset,\r\n                'value': decodedBlock\r\n            };\r\n            return blockInfo;\r\n        },\r\n\r\n\r\n        /* use requireJS to get the decompressionModule\r\n        *\r\n        */\r\n        getDecompressionModule: function (stripOffset, stripByteCount, moduleDecompression) {\r\n            var moduleDecompression = undefined;\r\n            // utiliser requirejs pour charger les modules de décompression \r\n            if (this.compression == 32946) {\r\n                define(function (require) {\r\n                    moduleDecompression = require('pako_inflate');\r\n                });\r\n                //moduleDecompression= require('pako_inflate');\r\n            }\r\n            return moduleDecompression;\r\n        },\r\n\r\n        /**\r\n         * Load Pixels \r\n         */\r\n        loadPixels: function () {\r\n            var FullPixelValues = [];\r\n            var index = 0;\r\n            for (var j = 0; j < this.imageLength; j++)\r\n                for (var i = 0; i < this.imageWidth; i++) {\r\n                    var pixelValue = this.getPixelValueOnDemand(i, j);\r\n                    for (var k = 0; k < this.samplesPerPixel; k++) {\r\n                        FullPixelValues[index] = pixelValue[k];\r\n                        index++;\r\n                    }\r\n                }\r\n            return FullPixelValues;\r\n        },\r\n\r\n        /* getRGBAPixelValue\r\n        *  This function is the default one , you shoul use this function in order to draw the image into a canvas\r\n        *  If you have a multiband image , you should define how to combine bands in order to obtain a RGBA value\r\n        */\r\n        getRGBAPixelValue: function (pixelSamples) {\r\n            var red = 0;\r\n            var green = 0;\r\n            var blue = 0;\r\n            var opacity = 1.0;\r\n\r\n            // To Understand this portion of code from Tiff-JS\r\n            if (this.numExtraSamples > 0) {\r\n                for (var k = 0; k < this.numExtraSamples; k++) {\r\n                    if (this.extraSamplesValues[k] === 1 || this.extraSamplesValues[k] === 2) {\r\n                        // Clamp opacity to the range [0,1].\r\n                        opacity = pixelSamples[3 + k] / 256;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //-------------------------------------------\r\n            var aRGBAPixelValue = [];\r\n            switch (this.photometricInterpretation) {\r\n                // Bilevel or Grayscale\r\n                // WhiteIsZero\r\n                case 0:\r\n                    if (this.sampleProperties[0].hasBytesPerSample) {\r\n                        var invertValue = Math.pow(0x10, this.sampleProperties[0].bytesPerSample * 2);\r\n                    }\r\n\r\n                    // Invert samples.\r\n                    pixelSamples.forEach(function (sample, index, samples) {\r\n                        samples[index] = invertValue - sample;\r\n                    });\r\n\r\n                    // Bilevel or Grayscale\r\n                    // BlackIsZero\r\n                case 1:\r\n                    red = green = blue = this.clampColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample);\r\n                    break;\r\n\r\n                    // RGB Full Color\r\n                case 2:\r\n                    if (this.samplesPerPixel == 1)\r\n                        red = green = blue = this.clampColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample);\r\n                    else if (this.samplesPerPixel > 2) {\r\n                        red = this.clampColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample);\r\n                        green = this.clampColorSample(pixelSamples[1], this.sampleProperties[1].bitsPerSample);\r\n                        blue = this.clampColorSample(pixelSamples[2], this.sampleProperties[2].bitsPerSample);\r\n                    }\r\n                    // Assuming 4 => RGBA \r\n                    if (this.samplesPerPixel == 4) {\r\n                        // Check this function A should be a value between 0->1 ? then devide pixelSamples[3]/this.sampleProperties[3].bitsPerSample\r\n                        var maxValue = Math.pow(2, this.sampleProperties[0].bitsPerSample);\r\n                        opacity = pixelSamples[3] / maxValue;\r\n                    }\r\n                    break;\r\n\r\n                    // RGB Color Palette\r\n                case 3:\r\n                    if (this.colorMapValues === undefined) {\r\n                        throw Error(\"Palette image missing color map\");\r\n                    }\r\n\r\n                    var colorMapIndex = pixelSamples[0];\r\n\r\n                    red = this.clampColorSample(this.colorMapValues[colorMapIndex], 16);\r\n                    green = this.clampColorSample(this.colorMapValues[this.colorMapSampleSize + colorMapIndex], 16);\r\n                    blue = this.clampColorSample(this.colorMapValues[(2 * this.colorMapSampleSize) + colorMapIndex], 16);\r\n\r\n                    break;\r\n\r\n\r\n                    // Unknown Photometric Interpretation\r\n                default:\r\n                    throw RangeError(' Photometric Interpretation Not Yet Implemented::', getPhotometricName(this.photometricInterpretation));\r\n                    break;\r\n            }\r\n            aRGBAPixelValue = [red, green, blue, opacity];\r\n            return aRGBAPixelValue;\r\n        },\r\n\r\n        /* getRGBAPixelValue\r\n        *  This function is the default one , you shoul use this function in order to draw the image into a canvas\r\n        *  If you have a multiband image , you should define how to combine bands in order to obtain a RGBA value\r\n        */\r\n        getMinMaxPixelValue: function (pixelSamples, vmin, vmax) {\r\n            var red = 0;\r\n            var green = 0;\r\n            var blue = 0;\r\n            var opacity = 1.0;\r\n\r\n            // To Understand this portion of code from Tiff-JS\r\n            if (this.numExtraSamples > 0) {\r\n                for (var k = 0; k < this.numExtraSamples; k++) {\r\n                    if (this.extraSamplesValues[k] === 1 || this.extraSamplesValues[k] === 2) {\r\n                        // Clamp opacity to the range [0,1].\r\n                        opacity = pixelSamples[3 + k] / 256;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            //-------------------------------------------\r\n            var aRGBAPixelValue = [];\r\n            switch (this.photometricInterpretation) {\r\n                // Bilevel or Grayscale\r\n                // WhiteIsZero\r\n                case 0:\r\n                    if (this.sampleProperties[0].hasBytesPerSample) {\r\n                        var invertValue = Math.pow(0x10, this.sampleProperties[0].bytesPerSample * 2);\r\n                    }\r\n\r\n                    // Invert samples.\r\n                    pixelSamples.forEach(function (sample, index, samples) {\r\n                        samples[index] = invertValue - sample;\r\n                    });\r\n\r\n                    // Bilevel or Grayscale\r\n                    // BlackIsZero\r\n                case 1:\r\n                    red = green = blue = this.clampAffineColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample, vmin, vmax);\r\n                    break;\r\n\r\n                    // RGB Full Color\r\n                case 2:\r\n                    if (this.samplesPerPixel == 1)\r\n                        red = green = blue = this.clampAffineColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample, vmin, vmax);\r\n                    else if (this.samplesPerPixel > 2) {\r\n                        red = this.clampAffineColorSample(pixelSamples[0], this.sampleProperties[0].bitsPerSample, vmin, vmax);\r\n                        green = this.clampAffineColorSample(pixelSamples[1], this.sampleProperties[1].bitsPerSample, vmin, vmax);\r\n                        blue = this.clampAffineColorSample(pixelSamples[2], this.sampleProperties[2].bitsPerSample, vmin, vmax);\r\n                    }\r\n                    // Assuming 4 => RGBA \r\n                    if (this.samplesPerPixel == 4) {\r\n                        // Check this function A should be a value between 0->1 ? then devide pixelSamples[3]/this.sampleProperties[3].bitsPerSample\r\n                        var maxValue = Math.pow(2, this.sampleProperties[0].bitsPerSample);\r\n                        opacity = pixelSamples[3] / maxValue;\r\n                    }\r\n                    break;\r\n\r\n                    // RGB Color Palette\r\n                case 3:\r\n                    if (this.colorMapValues === undefined) {\r\n                        throw Error(\"Palette image missing color map\");\r\n                    }\r\n\r\n                    var colorMapIndex = pixelSamples[0];\r\n\r\n                    red = this.clampAffineColorSample(this.colorMapValues[colorMapIndex], 16, vmin, vmax);\r\n                    green = this.clampAffineColorSample(this.colorMapValues[this.colorMapSampleSize + colorMapIndex], 16, vmin, vmax);\r\n                    blue = this.clampAffineColorSample(this.colorMapValues[(2 * this.colorMapSampleSize) + colorMapIndex], 16, vmin, vmax);\r\n\r\n                    break;\r\n\r\n\r\n                    // Unknown Photometric Interpretation\r\n                default:\r\n                    throw RangeError(' Photometric Interpretation Not Yet Implemented::', getPhotometricName(this.photometricInterpretation));\r\n                    break;\r\n            }\r\n            aRGBAPixelValue = [red, green, blue, opacity];\r\n            return aRGBAPixelValue;\r\n        },\r\n\r\n        /* Test getPixelValueOnDemand\r\n       *  start implementation : \r\n       *  1 -  check if the block is loaded  if not load the block\r\n       *  2 - get the pixel value in the block\r\n       */\r\n        getClosestPixelValue: function (x, y) {\r\n            x = Math.floor(x);\r\n            y = Math.floor(y);\r\n\r\n            var fileDirectory = this.fileDirectories[0];\r\n            var blockToLoad = 0;\r\n            var offsetValues = [];\r\n            var numoffsetValues = 0;\r\n            var blockByteCountValues = [];\r\n            var rowsPerStrip = 0;\r\n            var decompressionModule = this.getDecompressionModule();\r\n            var xInBlock = x;\r\n            var yInBlock = y;\r\n            var blockWidth = 0;\r\n            var blockInfo = [];\r\n            if (this.hasStripOffset()) {\r\n                // If RowsPerStrip is missing, the whole image is in one strip.\r\n                if (fileDirectory.RowsPerStrip) {\r\n                    rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\r\n                    blockToLoad = Math.floor(y / rowsPerStrip);\r\n                } else {\r\n                    rowsPerStrip = this.imageLength;\r\n                }\r\n                offsetValues = fileDirectory.StripOffsets.values;\r\n                blockWidth = this.imageWidth;\r\n\r\n                var idBlocks = this.isBlockLoaded(offsetValues[blockToLoad]);\r\n                if (idBlocks == -1) {\r\n                    // StripByteCounts is supposed to be required, but see if we can recover anyway.\r\n                    if (fileDirectory.StripByteCounts) {\r\n                        blockByteCountValues = fileDirectory.StripByteCounts.values;\r\n                    } else {\r\n                        console.log(\"Missing StripByteCounts!\");\r\n                        // Infer StripByteCounts, if possible.\r\n                        if (numoffsetValues === 1) {\r\n                            blockByteCountValues = [Math.ceil((this.imageWidth * this.imageLength * bitsPerPixel) / 8)];\r\n                        } else {\r\n                            throw Error(\"Cannot recover from missing StripByteCounts\");\r\n                        }\r\n                    }\r\n                    blockInfo = this.decodeBlock(offsetValues[blockToLoad], blockByteCountValues[blockToLoad], decompressionModule);\r\n                    this.addBlock(blockToLoad, blockInfo);\r\n                    //console.log(\"Load block \" , blockToLoad);\r\n                }\r\n                else {\r\n                    //console.log(\"Block is already load\" , blockToLoad, idBlocks );\r\n                    blockInfo = this.blocks[idBlocks];\r\n                }\r\n                yInBlock = y % rowsPerStrip;\r\n            }\r\n            else if (this.hasTileOffset()) {\r\n                offsetValues = fileDirectory.TileOffsets.values;\r\n                var tileLength = fileDirectory.TileLength.values[0];\r\n                var tileWidth = fileDirectory.TileWidth.values[0];\r\n                var iTile = Math.floor(x / tileWidth);\r\n                var jTile = Math.floor(y / tileLength);\r\n                var TilesAcross = Math.ceil(this.imageWidth / tileWidth);\r\n                blockToLoad = jTile * TilesAcross + iTile;\r\n                blockWidth = tileWidth;\r\n\r\n                var idBlocks = this.isBlockLoaded(offsetValues[blockToLoad]);\r\n                if (idBlocks == -1) {\r\n                    blockByteCountValues = fileDirectory.TileByteCounts.values;\r\n                    blockInfo = this.decodeBlock(offsetValues[blockToLoad], blockByteCountValues[blockToLoad], decompressionModule);\r\n                    this.addBlock(blockToLoad, blockInfo);\r\n                    //console.log(\"Load block \" , blockToLoad);\r\n                }\r\n                else {\r\n                    //console.log(\"Block is already load\" , blockToLoad, idBlocks );\r\n                    blockInfo = this.blocks[idBlocks];\r\n                }\r\n                xInBlock = x % tileWidth;\r\n                yInBlock = y % tileLength;\r\n            }\r\n            var indice = yInBlock * blockWidth + xInBlock;\r\n            return blockInfo.value[indice];\r\n        },\r\n\r\n        /* Test getPixelValueOnDemand\r\n        *  start implementation : \r\n        *  1 -  check if the block is loaded  if not load the block\r\n        *  2 - get the pixel value in the block\r\n        */\r\n        getPixelValueOnDemand: function (x, y) {\r\n            if (this.planarConfiguration != 1)\r\n                throw (\"Other Planar Configuration is not yet implemented\");\r\n\r\n\r\n            if (this.isPixelArea) {\r\n                return this.getClosestPixelValue(x, y);\r\n            }\r\n\r\n            /* Calcul de l'interpolation \r\n            var ix= Math.floor(x);\r\n            var iy= Math.floor(y);\r\n            var  a1 = this.getPixelValueOnDemand(ix, iy);\r\n            var  a2 = this.getPixelValueOnDemand(ix + 1, iy);\r\n            var  a3 = this.getPixelValueOnDemand(ix + 1, iy + 1);\r\n            var  a4 = this.getPixelValueOnDemand(ix, iy + 1);\r\n            // Avant d'inerpoler  : vérifier si on a les même valeurs \r\n\r\n            // puis calculer l'interpolation en tre 4 val (formule ?) \r\n            */\r\n\r\n            // retourne la valeur du pixel le plus proche \r\n            var ix = Math.floor(x + 0.5);\r\n            var iy = Math.floor(y + 0.5);\r\n            return this.getClosestPixelValue(ix, iy);\r\n\r\n\r\n        },\r\n\r\n        /** get the CRS code */\r\n        getCRSCode: function () {\r\n            var CRSCode = 0;\r\n            if (this.geoKeys.hasOwnProperty('GTModelTypeGeoKey') == false)\r\n                return 0;\r\n            if (this.getModelTypeName(this.geoKeys.GTModelTypeGeoKey.value) == 'ModelTypeGeographic'\r\n                && this.geoKeys.hasOwnProperty('GeographicTypeGeoKey'))\r\n                CRSCode = this.geoKeys['GeographicTypeGeoKey'].value;\r\n\r\n            else if (this.getModelTypeName(this.geoKeys.GTModelTypeGeoKey.value) == 'ModelTypeProjected' &&\r\n                this.geoKeys.hasOwnProperty('ProjectedCSTypeGeoKey'))\r\n                CRSCode = this.geoKeys['ProjectedCSTypeGeoKey'].value;\r\n            else if (this.getModelTypeName(this.geoKeys.GTModelTypeGeoKey.value) == 'user-defined') {\r\n                if (this.geoKeys.hasOwnProperty('ProjectedCSTypeGeoKey'))\r\n                    CRSCode = this.geoKeys['ProjectedCSTypeGeoKey'].value;\r\n                else if (this.geoKeys.hasOwnProperty('GeographicTypeGeoKey'))\r\n                    CRSCode = this.geoKeys['GeographicTypeGeoKey'].value;\r\n                else\r\n                    // Littel Hack for 3857\r\n                    if (this.geoKeys.hasOwnProperty('GTCitationGeoKey') &&\r\n                        this.geoKeys['GTCitationGeoKey'].value.search(\"WGS_1984_Web_Mercator_Auxiliary_Sphere\") != -1)\r\n                        CRSCode = 3857;\r\n                    else\r\n                        this.consoleCRSProperty();\r\n\r\n            }\r\n            return CRSCode;\r\n        },\r\n\r\n        /** get the CRS code */\r\n        consoleCRSProperty: function () {\r\n            //GeoTIFF Configuration GeoKeys\r\n            var Configuration_GeoKeys = [1024, 1026];\r\n            // Geographic CS Parameter GeoKeys\r\n            var GeographicCS_GeoKeys = [2048, 2061];\r\n            // Projected CS Parameter GeoKeys\r\n            var ProjectedCS_GeoKeys = [3072, 3073];\r\n            //Projection Definition GeoKeys\r\n            var Projection_GeoKeys = [3074, 3094];\r\n            //Vertical CS Parameter Keys\r\n            var Vertical_GeoKeys = [4096, 4099];\r\n            this.test_consoleGeoKeys(\"GeoTIFF Configuration GeoKeys\", Configuration_GeoKeys);\r\n            this.test_consoleGeoKeys(\"Geographic CS Parameter GeoKeys\", GeographicCS_GeoKeys);\r\n            this.test_consoleGeoKeys(\"Projected CS Parameter GeoKeys\", ProjectedCS_GeoKeys);\r\n            this.test_consoleGeoKeys(\"Projection Definition GeoKeys\", Projection_GeoKeys);\r\n            this.test_consoleGeoKeys(\"Vertical CS Parameter Keys\", Vertical_GeoKeys);\r\n        },\r\n\r\n        /** show consoleGeokey  */\r\n        test_consoleGeoKeys: function (Label, GeoKeyTab) {\r\n            console.log(Label);\r\n            for (var i = GeoKeyTab[0]; i <= GeoKeyTab[1]; i++) {\r\n                var geoKeyName = this.getGeoKeyName(i);\r\n                if (this.geoKeys.hasOwnProperty(geoKeyName))\r\n                    console.log(geoKeyName + \" \" + this.geoKeys[geoKeyName].value);\r\n            }\r\n        },\r\n\r\n        /** isPixelArea */\r\n        isPixelArea: function () {\r\n            if (this.geoKeys.hasOwnProperty('GTRasterTypeGeoKey') == false)\r\n                return true; // default \r\n            if (this.getRasterTypeName(this.geoKeys.GTRasterTypeGeoKey.value) == 'RasterPixelIsArea')\r\n                return true;\r\n\r\n            return false;\r\n        },\r\n\r\n        /**\r\n         * Get the pixel value \r\n         * Ex : var pixels = parse.parseTIFF(response);\r\n         *      var pixel = parse.getPixelValue(pixels,i,j);\r\n         */\r\n        getPixelValue: function (buffer, x, y) {\r\n            if (this.getPlanarConfiguration() != 1) {\r\n                throw (\"Other Planar Configuration is not yet implemented\");\r\n            }\r\n\r\n            var value = [];\r\n            if (x < 0 || x >= this.imageWidth || y < 0 || y >= this.imageLength) {\r\n                return value;\r\n            }\r\n\r\n            var indice = this.samplesPerPixel * (y * this.imageWidth + x);\r\n            for (var i = 0; i < this.samplesPerPixel; i++) {\r\n                //console.log(x,y,this.samplesPerPixel,i,buffer[indice+i] ) ;\r\n                value[i] = buffer[indice + i]; // don't use array.push in big loops\r\n            }\r\n            return value;\r\n        },\r\n\r\n        getLowResPixelValue: function (buffer, x, y) {\r\n            if (this.getPlanarConfiguration() != 1) {\r\n                throw (\"Other Planar Configuration is not yet implemented\");\r\n            }\r\n\r\n            var value = [];\r\n            if (x < 0 || x >= this.imageWidth || y < 0 || y >= this.imageLength) {\r\n                return value;\r\n            }\r\n\r\n            var indice1 = this.samplesPerPixel * (y * this.imageWidth + x);\r\n            var offsetX = (x < this.imageWidth ? x + 1 : x);\r\n            var indice2 = this.samplesPerPixel * (y * this.imageWidth + offsetX);\r\n            var indice3 = this.samplesPerPixel * (y * this.imageWidth + x);\r\n            var indice4 = this.samplesPerPixel * ((y < this.imageLength ? y + 1 : y) * this.imageWidth + offsetX);\r\n            for (var i = 0; i < this.samplesPerPixel; i++) {\r\n                var averageValue = (buffer[indice1 + i] + buffer[indice2 + i] + buffer[indice3 + i] + buffer[indice4 + i]) / 4;\r\n                value[i] = Math.round(averageValue);\r\n            }\r\n            return value;\r\n        },\r\n\r\n        /**\r\n         * This function display the tiff into a canvas \r\n         */\r\n\r\n        toCanvas: function (canvas, xmin, ymin, xmax, ymax, vmin, vmax) {\r\n            var mycanvas = canvas || document.createElement('canvas');\r\n\r\n            if (mycanvas.getContext == null) {\r\n                throw RangeError(\"No Context for canvas\");\r\n            }\r\n\r\n            var ctx = mycanvas.getContext(\"2d\");\r\n            mycanvas.width = xmax - xmin;\r\n            mycanvas.height = ymax - xmin;\r\n            var pixrgba = [];\r\n            // Set a default fill style.\t\r\n            ctx.fillStyle = this.makeRGBAFillValue(255, 255, 255, 0);\r\n            for (var y = ymin; y < ymax; y++) {\r\n                for (var x = xmin; x < xmax; x++) {\r\n                    var pixSample = this.getPixelValueOnDemand(x, y);\r\n                    if (pixSample != 'undefined') {\r\n                        if (vmin != 'undefined' && vmax != 'undefined')\r\n                            pixrgba = this.getMinMaxPixelValue(pixSample, vmin, vmax);\r\n                        else\r\n                            pixrgba = this.getRGBAPixelValue(pixSample);\r\n                    }\r\n                    else\r\n                        pixrgba = [255, 0, 0, 1];\r\n                    ctx.fillStyle = this.makeRGBAFillValue(pixrgba[0], pixrgba[1], pixrgba[2], pixrgba[3]);\r\n                    //ctx.fillStyle = this.makeRGBAFillValue(0, 0,248,1);\r\n                    ctx.fillRect(x - xmin, y - ymin, 1, 1);\r\n                }\r\n            }\r\n            return mycanvas;\r\n        },\r\n\r\n        /** Compute or retreive a PixelScale / Resolution or CellSize */\r\n        getPixelSize: function () {\r\n            var pixel_scale = ['undefined', 'undefined'];\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.ModelPixelScale) != 'undefined' && fileDirectory.ModelPixelScale != null &&\r\n                typeof (fileDirectory.ModelPixelScale.values) != 'undefined' && fileDirectory.ModelPixelScale.values != null)\r\n                return fileDirectory.ModelPixelScale.values;\r\n\r\n            var p0 = this.ImageToPCS(0, 0);\r\n            var p1 = this.ImageToPCS(1, 0);\r\n            var p2 = this.ImageToPCS(0, 1);\r\n            if (p0[0] == 0 || p1[0] == 0 || p2[0] == 0)\r\n                return pixel_scale;\r\n\r\n            var c_pixel_scale = [p1[1] - p0[1], p2[2] - p0[2]];\r\n            return c_pixel_scale;\r\n        },\r\n\r\n        /**\r\n         * See GeoTiff geo_trans.c\r\n         */\r\n        GTIFTiepointTranslate: function (gcp_count, x, y, directTransfo) {\r\n            var fileDirectory = this.fileDirectories[0];\r\n            var modelTiepoint = fileDirectory.ModelTiepoint.values;\r\n            /* I would appreciate a _brief_ block of code for doing second order\r\n               polynomial regression here! */\r\n            return [0, x, y];\r\n        },\r\n\r\n        /**\r\n        * return a BBox of the Image\r\n        */\r\n        GetBBox: function () {\r\n            var pCRS = this.getCRSCode();\r\n\r\n            var ul = this.ImageToPCS(0, 0);\r\n            var ur = this.ImageToPCS(this.imageWidth, 0);\r\n            var ll = this.ImageToPCS(0, this.imageLength);\r\n            var lr = this.ImageToPCS(this.imageWidth, this.imageLength);\r\n            if (ul[0] != 1 || ur[0] != 1 || ll[0] != 1 || lr[0] != 1) {\r\n                throw TypeError(\"BBox error\");\r\n            }\r\n\r\n            // Create the BBox structure\r\n            // Coord a counterclockWise\r\n            var lcoordinates = [];\r\n            lcoordinates.push(ul.splice(1, 2));\r\n            lcoordinates.push(ll.splice(1, 2));\r\n            lcoordinates.push(lr.splice(1, 2));\r\n            lcoordinates.push(ur.splice(1, 2));\r\n\r\n            var projstring = 'EPSG:' + pCRS.toString();\r\n            var bbox = {\r\n                'WKID': pCRS.toString(),\r\n                'EPSG': projstring,\r\n                'coord': lcoordinates,\r\n                'ulidx': 0,\r\n                'llidx': 1,\r\n                'lridx': 2,\r\n                'uridx': 3\r\n            };\r\n            return bbox;\r\n        },\r\n\r\n        /**\r\n         * Translate a pixel/line coordinates to projection coordinate .\r\n         * See GeoTiff geo_trans.c\r\n         */\r\n        ImageToPCS: function (x, y) {\r\n\r\n            var res = [0, x, y];\r\n            var tiepoint_count, count, transform_count;\r\n\r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.ModelTiepoint) == 'undefined' || fileDirectory.ModelTiepoint == null ||\r\n                typeof (fileDirectory.ModelTiepoint.values) == 'undefined' || fileDirectory.ModelTiepoint.values == null)\r\n                tiepoint_count = 0;\r\n            else {\r\n\r\n                var modelTiepoint = fileDirectory.ModelTiepoint.values;\r\n                tiepoint_count = modelTiepoint.length;\r\n            }\r\n\r\n            if (typeof (fileDirectory.ModelPixelScale) == 'undefined' || fileDirectory.ModelPixelScale == null ||\r\n                typeof (fileDirectory.ModelPixelScale.values) == 'undefined' || fileDirectory.ModelPixelScale.values == null)\r\n                count = 0;\r\n            else {\r\n                var modelPixelScale = fileDirectory.ModelPixelScale.values;\r\n                count = modelPixelScale.length;\r\n            }\r\n\r\n            if (typeof (fileDirectory.ModelTransformation) == 'undefined' || fileDirectory.ModelTransformation == null ||\r\n                typeof (fileDirectory.ModelTransformation.values) == 'undefined' || fileDirectory.ModelTransformation.values == null)\r\n                transform_count = 0;\r\n            else {\r\n                var modelTransformation = fileDirectory.ModelTransformation.values;\r\n                transform_count = modelTransformation.length;\r\n            }\r\n\r\n            //--------------------------------------------------------------------\r\n            //If the pixelscale count is zero, but we have tiepoints use      \r\n            //the tiepoint based approach.                                    \r\n            //--------------------------------------------------------------------\r\n            if (tiepoint_count > 6 && count == 0) {\r\n                console.log(\" tiepoint_count \", tiepoint_count);\r\n\r\n                res = this.GTIFTiepointTranslate(tiepoint_count / 6, x, y, true);\r\n            }\r\n\r\n                //--------------------------------------------------------------------\r\n                //If we have a transformation matrix, use it. \t\t\t\r\n                //--------------------------------------------------------------------\r\n            else if (transform_count == 16) {\r\n                var transform = fileDirectory.ModelTransformation.values;\r\n\r\n                var x_in = x;\r\n                var y_in = y;\r\n\r\n                x = x_in * transform[0] + y_in * transform[1] + transform[3];\r\n                y = x_in * transform[4] + y_in * transform[5] + transform[7];\r\n\r\n                res = [1, x, y];\r\n            }\r\n\r\n                //--------------------------------------------------------------------\r\n                //For now we require one tie point, and a valid pixel scale.      \r\n                //-------------------------------------------------------------------- \r\n            else if (count < 3 || tiepoint_count < 6) {\r\n                res = [0, x, y];\r\n            }\r\n\r\n            else {\r\n                var pixel_scale = fileDirectory.ModelPixelScale.values;\r\n                var tiepoints = fileDirectory.ModelTiepoint.values;\r\n                x = (x - tiepoints[0]) * pixel_scale[0] + tiepoints[3];\r\n                y = (y - tiepoints[1]) * (-1 * pixel_scale[1]) + tiepoints[4];\r\n\r\n                res = [1, x, y];\r\n            }\r\n            return res;\r\n        },\r\n\r\n        /**\r\n        * Inverse GeoTransfom\r\n        * See GeoTiff geo_trans.c\r\n        */\r\n        inv_geotransform: function (gt_in) {\r\n            var gt_out = [0, 0, 0, 0, 0, 0];\r\n            var det, inv_det;\r\n\r\n            /* we assume a 3rd row that is [0 0 1] */\r\n\r\n            /* Compute determinate */\r\n\r\n            det = gt_in[0] * gt_in[4] - gt_in[1] * gt_in[3];\r\n\r\n            if (Math.abs(det) < 0.000000000000001)\r\n                return [0, gt_out];\r\n\r\n            inv_det = 1.0 / det;\r\n\r\n            /* compute adjoint, and devide by determinate */\r\n\r\n            gt_out[0] = gt_in[4] * inv_det;\r\n            gt_out[3] = -gt_in[3] * inv_det;\r\n\r\n            gt_out[1] = -gt_in[1] * inv_det;\r\n            gt_out[4] = gt_in[0] * inv_det;\r\n\r\n            gt_out[2] = (gt_in[1] * gt_in[5] - gt_in[2] * gt_in[4]) * inv_det;\r\n            gt_out[5] = (-gt_in[0] * gt_in[5] + gt_in[2] * gt_in[3]) * inv_det;\r\n\r\n            return [1, gt_out];\r\n        },\r\n\r\n        /**\r\n         * Translate a projection coordinate to pixel/line coordinates.\r\n         * See GeoTiff geo_trans.c\r\n         */\r\n\r\n        PCSToImage: function (x, y) {\r\n            var res = [0, x, y];\r\n            var tiepoint_count, count, transform_count = 0;\r\n\r\n            // -------------------------------------------------------------------- \r\n            //      Fetch tiepoints and pixel scale.                                \r\n            // -------------------------------------------------------------------- \r\n            var fileDirectory = this.fileDirectories[0];\r\n            if (typeof (fileDirectory.ModelTiepoint) == 'undefined' || fileDirectory.ModelTiepoint == null ||\r\n                typeof (fileDirectory.ModelTiepoint.values) == 'undefined' || fileDirectory.ModelTiepoint.values == null)\r\n                tiepoint_count = 0;\r\n            else {\r\n\r\n                var modelTiepoint = fileDirectory.ModelTiepoint.values;\r\n                tiepoint_count = modelTiepoint.length;\r\n            }\r\n\r\n            if (typeof (fileDirectory.ModelPixelScale) == 'undefined' || fileDirectory.ModelPixelScale == null ||\r\n                typeof (fileDirectory.ModelPixelScale.values) == 'undefined' || fileDirectory.ModelPixelScale.values == null)\r\n                count = 0;\r\n            else {\r\n                var modelPixelScale = fileDirectory.ModelPixelScale.values;\r\n                count = modelPixelScale.length;\r\n            }\r\n\r\n            if (typeof (fileDirectory.ModelTransformation) == 'undefined' || fileDirectory.ModelTransformation == null ||\r\n                typeof (fileDirectory.ModelTransformation.values) == 'undefined' || fileDirectory.ModelTransformation.values == null)\r\n                transform_count = 0;\r\n            else {\r\n                var modelTransformation = fileDirectory.ModelTransformation.values;\r\n                transform_count = modelTransformation.length;\r\n            }\r\n            // -------------------------------------------------------------------- \r\n            //      If the pixelscale count is zero, but we have tiepoints use      \r\n            //      the tiepoint based approach.                                    \r\n            // -------------------------------------------------------------------- \r\n            if (tiepoint_count > 6 && count == 0) {\r\n                res = this.GTIFTiepointTranslate(tiepoint_count / 6, x, y, false);\r\n            }\r\n\r\n                // -------------------------------------------------------------------- \r\n                //      Handle matrix - convert to \"geotransform\" format, invert and    \r\n                //      apply.                                                          \r\n                // -------------------------------------------------------------------- \r\n            else if (transform_count == 16) {\r\n                var transform = fileDirectory.ModelTransformation.values;\r\n\r\n                var x_in = x;\r\n                var y_in = y;\r\n\r\n                var gt_in = [0, 0, 0, 0, 0, 0];\r\n\r\n                gt_in[0] = transform[0];\r\n                gt_in[1] = transform[1];\r\n                gt_in[2] = transform[3];\r\n                gt_in[3] = transform[4];\r\n                gt_in[4] = transform[5];\r\n                gt_in[5] = transform[7];\r\n\r\n                var result = this.inv_geotransform(gt_in);\r\n\r\n                if (!result[0])\r\n                    res = [0, x, y];\r\n                else {\r\n                    var gt_out = result[1];\r\n                    x = x_in * gt_out[0] + y_in * gt_out[1] + gt_out[2];\r\n                    y = x_in * gt_out[3] + y_in * gt_out[4] + gt_out[5];\r\n\r\n                    res = [1, x, y];\r\n                }\r\n            }\r\n\r\n                // -------------------------------------------------------------------- \r\n                //      For now we require one tie point, and a valid pixel scale.      \r\n                // -------------------------------------------------------------------- \r\n            else if (count >= 3 && tiepoint_count >= 6) {\r\n                var pixel_scale = fileDirectory.ModelPixelScale.values;\r\n                var tiepoints = fileDirectory.ModelTiepoint.values;\r\n                x = (x - tiepoints[3]) / pixel_scale[0] + tiepoints[0];\r\n                y = (y - tiepoints[4]) / (-1 * pixel_scale[1]) + tiepoints[1];\r\n\r\n                res = [1, x, y];\r\n            }\r\n\r\n            return res;\r\n        }\r\n    };\r\n\r\n    var OGCHelper = {};\r\n\r\n    OGCHelper.WCSParser = {};\r\n    /**\r\n     * static array where CRS availables for OGCHelper are defined\r\n     */\r\n    OGCHelper.CRS = [{\r\n        name: \"CRS:84\",\r\n        ellipsoid: cesium.Ellipsoid.WGS84,\r\n        firstAxeIsLatitude: false,\r\n        tilingScheme: cesium.GeographicTilingScheme,\r\n        supportedCRS: \"urn:ogc:def:crs:OGC:2:84\"\r\n    }, {\r\n        name: \"EPSG:4258\",\r\n        ellipsoid: cesium.Ellipsoid.WGS84,\r\n        firstAxeIsLatitude: true,\r\n        tilingScheme: cesium.GeographicTilingScheme,\r\n        SupportedCRS: \"urn:ogc:def:crs:EPSG::4258\"\r\n    }, {\r\n        name: \"EPSG:4326\",\r\n        ellipsoid: cesium.Ellipsoid.WGS84,\r\n        firstAxeIsLatitude: true,\r\n        tilingScheme: cesium.GeographicTilingScheme,\r\n        SupportedCRS: \"urn:ogc:def:crs:EPSG::4326\"\r\n    }, {\r\n        name: \"EPSG:3857\",\r\n        ellipsoid: cesium.Ellipsoid.WGS84,\r\n        firstAxeIsLatitude: false,\r\n        tilingScheme: cesium.WebMercatorTilingScheme,\r\n        SupportedCRS: \"urn:ogc:def:crs:EPSG::3857\"\r\n    }, {\r\n        name: \"OSGEO:41001\",\r\n        ellipsoid: cesium.Ellipsoid.WGS84,\r\n        firstAxeIsLatitude: false,\r\n        tilingScheme: cesium.WebMercatorTilingScheme,\r\n        SupportedCRS: \"urn:ogc:def:crs:EPSG::3857\"\r\n    }];\r\n\r\n    OGCHelper.FormatImage = [{\r\n        format: \"image/png\",\r\n        extension: \"png\"\r\n    }, {\r\n        format: \"image/jpeg\",\r\n        extension: \"jpg\"\r\n    }, {\r\n        format: \"image/jpeg\",\r\n        extension: \"jpeg\"\r\n    }, {\r\n        format: \"image/gif\",\r\n        extension: \"gif\"\r\n    }, {\r\n        format: \"image/png; mode=8bit\",\r\n        extension: \"png\"\r\n    }];\r\n\r\n    OGCHelper.WCSParser.generate = function (description) {\r\n        var resultat;\r\n        description = cesium.defaultValue(description,\r\n            cesium.defaultValue.EMPTY_OBJECT);\r\n        if (cesium.defined(description.url)) {\r\n            var urlofServer = description.url;\r\n            var index = urlofServer.lastIndexOf(\"?\");\r\n            if (index > -1) {\r\n                urlofServer = urlofServer.substring(0, index);\r\n            }\r\n            // get version of wcs\r\n            if (!cesium.defined(description.layerName)) {\r\n                throw new cesium.DeveloperError(\r\n                    'description.layerName is required.');\r\n            }\r\n\r\n            var urlDescribeCoverage = urlofServer + '?SERVICE=WCS&VERSION=1.0.0&request=DescribeCoverage&CoverageId=' + description.layerName;\r\n\r\n            if (cesium.defined(description.proxy)) {\r\n                urlDescribeCoverage = description.proxy.getURL(urlDescribeCoverage);\r\n            }\r\n\r\n            resultat = cesium.when(cesium.Resource.fetchXML({\r\n                url: urlDescribeCoverage\r\n            }), function (xml) {\r\n                return OGCHelper.WCSParser.getDescribeCoverage(xml, description);\r\n            }).otherwise(function () {\r\n                return cesium.when.defer.resolve(null);\r\n            });\r\n\r\n\r\n        } else if (cesium.defined(description.xml)) {\r\n            resultat = OGCHelper.WCSParser.getDescribeCoverage(description.xml, description);\r\n        } else {\r\n            throw new cesium.DeveloperError(\r\n                'either description.url or description.xml are required.');\r\n        }\r\n        return resultat;\r\n    };\r\n\r\n    function convertToFloat(tab) {\r\n        for (var j = 0; j < tab.length; j++) {\r\n            var b = parseFloat(tab[j]);\r\n            if (!isNaN(b))\r\n                tab[j] = b;\r\n        }\r\n        return tab;\r\n    }\r\n\r\n    function invertTab(tab) {\r\n        var b = tab[1];\r\n        tab[1] = tab[0];\r\n        tab[0] = b;\r\n        return tab;\r\n    }\r\n\r\n    OGCHelper.WCSParser.getDescribeCoverage = function (coverage, description) {\r\n\r\n        var resultat = {};\r\n\r\n        if (!cesium.defined(description.layerName)) {\r\n            throw new cesium.DeveloperError(\r\n                'description.layerName is required.');\r\n        }\r\n\r\n        var layerName = description.layerName;\r\n        resultat.minLevel = cesium.defaultValue(description.minLevel, undefined);\r\n        resultat.maxLevel = cesium.defaultValue(description.maxLevel, undefined);\r\n\r\n        resultat.heightMapWidth = cesium.defaultValue(description.heightMapWidth, 65);\r\n        resultat.heightMapHeight = cesium.defaultValue(description.heightMapHeight, resultat.heightMapWidth);\r\n\r\n        var corner = coverage.querySelector('lonLatEnvelope').textContent.trim().split(' ').filter(function (elm) { return elm.trim().length > 0 });\r\n\r\n        var lowerCorner = convertToFloat(corner.slice(0, 2));\r\n        var upperCorner = convertToFloat(corner.slice(2));\r\n\r\n        resultat.upperCorner = upperCorner;\r\n        resultat.lowerCorner = lowerCorner;\r\n\r\n        var low = convertToFloat(coverage.querySelector('gml\\\\:low, low').textContent.split(' '));\r\n        var high = convertToFloat(coverage.querySelector('gml\\\\:high, high').textContent.split(' '));\r\n\r\n        var epsgCode = 4326;\r\n        var projstring = 'EPSG:' + epsgCode.toString();\r\n        var getCRS = OGCHelper.CRS.filter(function (elt) {\r\n            return elt.name === projstring;\r\n        });\r\n        if (getCRS.length > 0)\r\n            resultat.tilingScheme = new getCRS[0].tilingScheme({\r\n                ellipsoid: getCRS[0].ellipsoid\r\n            });\r\n        else\r\n            resultat.tilingScheme = undefined;\r\n\r\n        resultat.pixelSize = [65, 65];\r\n\r\n        resultat.levelZeroMaximumGeometricError = cesium.TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(resultat.tilingScheme._ellipsoid,\r\n            Math.min(resultat.heightMapWidth, resultat.heightMapHeight),\r\n            resultat.tilingScheme.getNumberOfXTilesAtLevel(0));\r\n\r\n        resultat.waterMask = false;\r\n        resultat.ready = true;\r\n\r\n        var bbox = {\r\n            'WKID': epsgCode,\r\n            'EPSG': projstring,\r\n            'coord': [[lowerCorner[0], upperCorner[1]], [lowerCorner[0], lowerCorner[1]], [upperCorner[0], lowerCorner[1]], [upperCorner[0], upperCorner[1]]],\r\n            'ulidx': 0,\r\n            'llidx': 1,\r\n            'lridx': 2,\r\n            'uridx': 3\r\n        };\r\n        resultat.bbox = bbox;\r\n\r\n\r\n        resultat.getTileDataAvailable = function (x, y, level) {\r\n            if (level <= resultat.maxLevel && resultat.isInTile(x, y, level))\r\n                return true;\r\n            return false;\r\n        };\r\n\r\n        // Define the URL for GetCoverage\r\n        var urlofServer = description.url;\r\n        var index = urlofServer.lastIndexOf(\"?\");\r\n        if (index > -1) {\r\n            urlofServer = urlofServer.substring(0, index);\r\n        }\r\n\r\n        /* WCS 1.0.0 */\r\n        var urlGetCoverage = urlofServer +\r\n            \"?SERVICE=WCS&VERSION=1.0.0&REQUEST=GetCoverage\" +\r\n            \"&COVERAGE=\" + description.layerName + \"&FORMAT=\" + description.format + \"&BBOX=\" + \"{west},{south},{east},{north}\" + \"&WIDTH=\" + 65 + \"&HEIGHT=\" + 65 + \"&CRS=EPSG:4326\";\r\n\r\n        resultat.urlGetCoverage = urlGetCoverage;\r\n\r\n        // Is the X,Y,Level define a tile that is contains in our bbox\r\n        resultat.isTileInside = function (x, y, level, provider) {\r\n            var inside = true;\r\n            var bbox = resultat.bbox;\r\n            var rect = provider.tilingScheme.tileXYToNativeRectangle(x, y, level);\r\n\r\n            if (bbox.coord[bbox.ulidx][0] >= rect.east || bbox.coord[bbox.lridx][0] <= rect.west ||\r\n                bbox.coord[bbox.lridx][1] >= rect.north || bbox.coord[bbox.ulidx][1] <= rect.south) {\r\n                inside = false;\r\n            }\r\n            return inside;\r\n        };\r\n        // Is the X,Y,Level define a tile that contains or ovelaps our bbox\r\n        resultat.isInTile = function (x, y, level) {\r\n            var inside = false;\r\n            var bbox = resultat.bbox;\r\n            var rect = resultat.tilingScheme.tileXYToNativeRectangle(x, y, level);\r\n            // One point of the bbox is in the tile\r\n            if ((bbox.coord[bbox.ulidx][0] >= rect.west && bbox.coord[bbox.ulidx][0] <= rect.east &&\r\n                bbox.coord[bbox.ulidx][1] >= rect.south && bbox.coord[bbox.ulidx][1] <= rect.north) ||\r\n                (bbox.coord[bbox.uridx][0] >= rect.west && bbox.coord[bbox.uridx][0] <= rect.east &&\r\n                    bbox.coord[bbox.uridx][1] >= rect.south && bbox.coord[bbox.uridx][1] <= rect.north) ||\r\n                (bbox.coord[bbox.llidx][0] >= rect.west && bbox.coord[bbox.llidx][0] <= rect.east &&\r\n                    bbox.coord[bbox.llidx][1] >= rect.south && bbox.coord[bbox.llidx][1] <= rect.north) ||\r\n                (bbox.coord[bbox.lridx][0] >= rect.west && bbox.coord[bbox.lridx][0] <= rect.east &&\r\n                    bbox.coord[bbox.lridx][1] >= rect.south && bbox.coord[bbox.lridx][1] <= rect.north) ||\r\n                // or the tile is in the bbox\r\n                (bbox.coord[bbox.ulidx][0] < rect.east && bbox.coord[bbox.lridx][0] > rect.west &&\r\n                    bbox.coord[bbox.lridx][1] < rect.north && bbox.coord[bbox.ulidx][1] > rect.south)\r\n            ) {\r\n                inside = true;\r\n            }\r\n            return inside;\r\n\r\n        };\r\n\r\n        return resultat;\r\n    };\r\n})();"]}