{"version":3,"sources":["cesium/cesium.js"],"names":["root","factory","define","amd","exports","module","require","cesium","this","window","CESIUM_BASE_URL","TC","apiLocation","TOO_MANY_PARALLEL_REQUESTS","WCSTerrainProvider","syncLoadJS","Resource","prototype","_clone","clone","cloned","apply","arguments","tcLayer","ImageryLayer","__requestImagery","_requestImagery","imagery","imageryProvider","_imageryProvider","that","success","image","defined","failure","state","ImageryState","RECEIVED","request","undefined","TileProviderError","handleSuccess","_requestImageError","e","status","toString","FAILED","RequestState","CANCELLED","message","x","y","level","handleError","errorEvent","doRequest","UNLOADED","Request","throttle","throttleByServer","type","RequestType","IMAGERY","TRANSITIONING","imagePromise","requestImage","getTileCredits","credits","when","_fetchImage","fetchImage","self","options","deferred","defer","getWebGLUrl","call","url","then","resolve","reject","catch","error","promise"],"mappings":"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","sourcesContent":["; (function (root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(['../../lib/cesium/build/cesium-sitna'], factory);\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = factory(require('../../lib/cesium/build/cesium-sitna'));\r\n    } else {\r\n        root.cesium = factory(root.cesium);\r\n    }\r\n\r\n})(this, function (cesium) {\r\n\r\n    window.CESIUM_BASE_URL = TC.apiLocation + 'lib/cesium/build/';\r\n\r\n    const TOO_MANY_PARALLEL_REQUESTS = \"Too many parallel requests, so postpone loading tile\";\r\n\r\n    if (!cesium.WCSTerrainProvider) {\r\n        TC.syncLoadJS(TC.apiLocation + 'TC/cesium/mergeTerrainProvider/MergeTerrainProvider');\r\n    }\r\n\r\n    /* sobrescribimos y extendemos lo necesario para que todas las peticiones pasen por el algoritmo de proxificación */\r\n    // requerido para añadir la referencia a la capa TC\r\n    cesium.Resource.prototype._clone = cesium.Resource.prototype.clone;\r\n    cesium.Resource.prototype.clone = function () {\r\n        let cloned = cesium.Resource.prototype._clone.apply(this, arguments);\r\n        cloned.tcLayer = this.tcLayer;\r\n        return cloned;\r\n    };\r\n\r\n    // requerido para gestionar la promesa rechaza directamente que vamos a retornar en lugar del undefined que retorna cesium en fetchImage\r\n    cesium.ImageryLayer.prototype.__requestImagery = cesium.ImageryLayer.prototype._requestImagery;\r\n    cesium.ImageryLayer.prototype._requestImagery = function (imagery) {\r\n        var imageryProvider = this._imageryProvider;\r\n\r\n        var that = this;\r\n\r\n        function success(image) {\r\n            if (!cesium.defined(image)) {\r\n                return failure();\r\n            }\r\n\r\n            imagery.image = image;\r\n            imagery.state = cesium.ImageryState.RECEIVED;\r\n            imagery.request = undefined;\r\n\r\n            cesium.TileProviderError.handleSuccess(that._requestImageError);\r\n        }\r\n\r\n        function failure(e) {            \r\n            if (typeof e === 'string' && e === TOO_MANY_PARALLEL_REQUESTS) {\r\n                // Too many parallel requests, so postpone loading tile.\r\n                imagery.state = cesium.ImageryState.UNLOADED;\r\n                imagery.request = undefined;\r\n                return;\r\n            } else if (e.status && e.status.toString() === \"200\") {\r\n                // si llega alguna excepción en XML como cuerpo de la petición de una imagen, pasamos de ella\r\n                imagery.state = cesium.ImageryState.FAILED;\r\n                imagery.request = undefined;\r\n                return;\r\n            }\r\n\r\n            if (imagery.request.state === cesium.RequestState.CANCELLED) {\r\n                // Cancelled due to low priority - try again later.\r\n                imagery.state = cesium.ImageryState.UNLOADED;\r\n                imagery.request = undefined;\r\n                return;\r\n            }\r\n\r\n            // Initially assume failure.  handleError may retry, in which case the state will\r\n            // change to TRANSITIONING.\r\n            imagery.state = cesium.ImageryState.FAILED;\r\n            imagery.request = undefined;\r\n\r\n            var message =\r\n                \"Failed to obtain image tile X: \" +\r\n                imagery.x +\r\n                \" Y: \" +\r\n                imagery.y +\r\n                \" Level: \" +\r\n                imagery.level +\r\n                \".\";\r\n            that._requestImageError = cesium.TileProviderError.handleError(\r\n                that._requestImageError,\r\n                imageryProvider,\r\n                imageryProvider.errorEvent,\r\n                message,\r\n                imagery.x,\r\n                imagery.y,\r\n                imagery.level,\r\n                doRequest,\r\n                e\r\n            );\r\n        }\r\n\r\n        function doRequest() {\r\n            var request = new cesium.Request({\r\n                throttle: false,\r\n                throttleByServer: true,\r\n                type: cesium.RequestType.IMAGERY,\r\n            });\r\n            imagery.request = request;\r\n            imagery.state = cesium.ImageryState.TRANSITIONING;\r\n            var imagePromise = imageryProvider.requestImage(\r\n                imagery.x,\r\n                imagery.y,\r\n                imagery.level,\r\n                request\r\n            );\r\n\r\n            // cesium hace lo siguiente y es lo que no nos encaja y que nosotros gestionamos en failure\r\n            if (!cesium.defined(imagePromise)) {\r\n                // Too many parallel requests, so postpone loading tile.\r\n                imagery.state = cesium.ImageryState.UNLOADED;\r\n                imagery.request = undefined;\r\n                return;\r\n            }\r\n\r\n            if (cesium.defined(imageryProvider.getTileCredits)) {\r\n                imagery.credits = imageryProvider.getTileCredits(\r\n                    imagery.x,\r\n                    imagery.y,\r\n                    imagery.level\r\n                );\r\n            }\r\n\r\n            cesium.when(imagePromise, success, failure);\r\n        }\r\n\r\n        doRequest();\r\n    };\r\n\r\n    // requerido para que pasar por el algoritmo de proxificación\r\n    cesium.Resource.prototype._fetchImage = cesium.Resource.prototype.fetchImage;\r\n    cesium.Resource.prototype.fetchImage = function () {\r\n        if (this.tcLayer) {\r\n            let self = this;\r\n            let options = arguments;\r\n\r\n            let deferred = cesium.when.defer();\r\n\r\n            this.tcLayer.getWebGLUrl.call(this.tcLayer, this.url)\r\n                .then(function (url) {\r\n                    self.url = url;\r\n                    let image = cesium.Resource.prototype._fetchImage.apply(self, options);\r\n                    if (image) {\r\n                        image.then(deferred.resolve);\r\n                    } else {\r\n                        deferred.reject(TOO_MANY_PARALLEL_REQUESTS);\r\n                    }\r\n                })\r\n                .catch(function (error) {                    \r\n                    deferred.reject(error);\r\n                });\r\n\r\n            return deferred.promise;\r\n        } else {\r\n            return cesium.Resource.prototype._fetchImage.apply(this, arguments);\r\n        }\r\n    };    \r\n\r\n    return cesium;\r\n});"]}